HTTP/1.1 200 OK
Accept-Ranges: bytes
Content-Type: text/html
ETag: "cae0b83ea40bb64ba0b724651bab9474:1586883287.394427"
Last-Modified: Tue, 14 Apr 2020 16:54:47 GMT
Server: AkamaiNetStorage
Vary: Accept-Encoding
Cache-Control: max-age=312
Expires: Sun, 19 Jul 2020 15:36:18 GMT
Date: Sun, 19 Jul 2020 15:31:06 GMT
Connection: keep-alive
Connection: Transfer-Encoding
X-Frame-Options: ALLOW-FROM https://store.playstation.com/;
Content-Security-Policy: frame-ancestors https://vue.playstation.com https://id.sonyentertainmentnetwork.com https://transact.playstation.com https://store.playstation.com;
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
Content-Length: 1198077

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>PlayStation&reg;Store Transact</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <base href="/" />
<meta name="psst/config/environment" content="%7B%22modulePrefix%22%3A%22psst%22%2C%22environment%22%3A%22production%22%2C%22baseURL%22%3A%22/%22%2C%22buildVersion%22%3A%22V34.2.0-0-g6361dcca%22%2C%22version%22%3A%221.0.9%22%2C%22rootElement%22%3A%22%23psst%22%2C%22locationType%22%3A%22auto%22%2C%22lines%22%3A%5B%22e1-np%22%2C%22q1-np%22%2C%22mgmt%22%2C%22sp-int%22%2C%22prod-qa%22%2C%22np%22%5D%2C%22localUrl%22%3A%22localdev.sonyentertainmentnetwork.com%22%2C%22EmberENV%22%3A%7B%22FEATURES%22%3A%7B%7D%7D%2C%22APP%22%3A%7B%22fixtures%22%3Afalse%2C%22navigateAwayTimeoutMs%22%3A500%2C%22name%22%3A%22psst%22%2C%22version%22%3A%22V34.2.0+6361dcca%22%7D%2C%22i18n%22%3A%7B%22defaultLocale%22%3A%22en-GB%22%7D%2C%22exportApplicationGlobal%22%3Atrue%2C%22ember-component-css%22%3A%7B%22namespacing%22%3Afalse%2C%22terseClassNames%22%3Atrue%7D%7D" />

    

    <style>
.index__overlay {
    position: fixed;
    top: 0;
    left: 0;
    margin: auto;
    width: 100%;
    height: 100%;
    z-index: 10000;
    background-color: #ffffff;
}

.show-header {
  z-index: 8000;
}

.index__overlay-image {
    margin-left: auto;
    margin-right: auto;
    display: block;
    position: relative;
    height: 100px;
    top: calc(50% - 55px);
}

.index__threeds-icon-container {	
  display: -webkit-box;	
  display: -ms-flexbox;	
  display: flex;	
  -webkit-box-align: center;	
      -ms-flex-align: center;	
          align-items: center;	
  height: 100%;	
  margin-top: 10px;	
  margin-left: auto;	
  margin-right: auto;	
}	

.index__threeds-icon {	
  display: none;
  width: 100px;
  margin-left: auto;
  margin-right: auto;
  position: relative;
}	

.show-icon {
  display: block !important;
}

@-webkit-keyframes hideshow {
  0% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.2; }
}

@keyframes hideshow {
  0% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.2; }
}

.shape_square {
    opacity: 0.2;
    -webkit-animation: hideshow 2.5s ease infinite;
            animation: hideshow 2.5s ease infinite;
}

.shape_triangle {
    opacity: 0.2;
    -webkit-animation: hideshow 2.5s 0.25s ease infinite;
            animation: hideshow 2.5s 0.25s ease infinite;
}

.shape_circle {
    opacity: 0.2;
    -webkit-animation: hideshow 2.5s .5s ease infinite;
            animation: hideshow 2.5s .5s ease infinite;
}

.shape_x {
    opacity: 0.2;
    -webkit-animation: hideshow 2.5s .75s ease infinite;
            animation: hideshow 2.5s .75s ease infinite;
}

@media (max-width: 480px) {
  .index__overlay-image {
    height: 75px;
  }
}


/* Copied from _animate.scss */
/*!
Animate.css - http://daneden.me/animate
Licensed under the MIT license - http://opensource.org/licenses/MIT

Copyright (c) 2015 Daniel Eden
*/

.animated {
  -webkit-animation-duration: 1s;
  animation-duration: 1s;
  -webkit-animation-fill-mode: both;
  animation-fill-mode: both;
}

@-webkit-keyframes fadeOut {
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
}

@keyframes fadeOut {
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
}

.fadeOut {
  -webkit-animation-name: fadeOut;
  animation-name: fadeOut;
}


</style>
  </head>
  <body>
    <div class="animated index__overlay">
      <svg version="1.1" class="index__overlay-image" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
   width="330px" height="328px" viewBox="0 0 330 328" enable-background="new 0 0 330 328" xml:space="preserve">
<path class="shape_square" fill="#0085E8" d="M52.073,147.867c0-35.294,0-70.389,0-105.938c35.244,0,70.462,0,106.142,0c0,35.067,0,70.281,0,105.938
  C123.167,147.867,87.944,147.867,52.073,147.867z M66.772,132.933c26.076,0,51.295,0,76.521,0c0-25.606,0-50.82,0-76.121
  c-0.999-0.15-1.641-0.331-2.279-0.332c-23.316-0.02-46.635,0.041-69.951-0.088c-3.775-0.021-4.347,1.724-4.334,4.896
  c0.086,20.651,0.045,41.304,0.045,61.955C66.772,126.37,66.772,129.496,66.772,132.933z"></path>
<path class="shape_circle" fill="#0085E8" d="M290.342,230.181c-0.004,32.741-26.022,59.011-58.432,58.995c-32.201-0.016-58.496-26.746-58.301-59.262
  c0.196-32.445,26.295-58.735,58.317-58.746C264.334,171.156,290.346,197.435,290.342,230.181z M189.914,230.271
  c0.051,23.688,19.039,42.805,42.364,42.654c23.308-0.15,42.056-19.412,41.956-43.104c-0.099-23.309-19.102-42.422-42.156-42.404
  C208.688,187.438,189.863,206.568,189.914,230.271z"></path>
<path class="shape_triangle" fill="#0085E8" d="M169.165,147.971c20.899-36.745,41.522-73.006,62.646-110.146c21.782,36.926,43.182,73.2,64.975,110.146
  C254.021,147.971,211.941,147.971,169.165,147.971z M231.504,64.983c-13.158,23.965-25.826,47.034-38.591,70.281
  c27.168,0,53.513,0,80.453,0C259.346,111.728,245.654,88.74,231.504,64.983z"></path>
<path class="shape_x" fill="#0085E8" d="M52.826,189.27c3.569-3.879,6.909-7.51,10.814-11.752c14.005,14.01,27.92,27.931,41.438,41.453
  c14.557-13.877,28.615-27.279,42.717-40.725c3.39,3.479,6.941,7.125,10.692,10.975c-13.655,13.68-27.362,27.411-41.67,41.746
  c14.009,13.812,27.69,27.301,41.548,40.963c-4.195,4.062-7.72,7.473-11.255,10.896c-13.401-13.52-26.85-27.087-40.653-41.012
  c-2.161,1.992-3.498,3.146-4.745,4.39c-11.325,11.296-22.736,22.51-33.882,33.981c-2.974,3.061-4.838,2.957-7.553-0.117
  c-2.167-2.453-4.965-4.352-8.476-7.342c5.339-4.895,9.725-8.693,13.857-12.752c8.559-8.406,16.892-17.043,25.516-25.381
  c2.683-2.594,2.689-4.203,0.006-6.824c-11.562-11.291-22.927-22.787-34.35-34.221C55.558,192.273,54.365,190.919,52.826,189.27z"></path>
</svg>

      <div class="index__threeds-icon-container">	
        <img class="index__threeds-icon"></img>	
      </div>
    </div>

    <script type="text/javascript">
      // Need to make null, for whatwg-fetch polyfill to work.
      // We need this polyfill so that we can use XHRPromise for pretender.
      // Pretender currently does not support fetch
      window.fetch = null;
    </script>

    <script>
/* eslint-disable */

;(function setUpPolyfills() {
  var noop = function () {};

  // console
  window.console = window.console || { log: noop };
  window.console.debug = window.console.debug || window.console.log;
  window.console.warn = window.console.warn || window.console.log;
  window.console.error = window.console.error || window.console.log;

  // Number.isNaN
  Number.isNaN = Number.isNaN || function (value) {
    return typeof value === "number" && isNaN(value);
  };

  // String.endsWith()
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }

  // Array.find()
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
  if (!Array.prototype.find) {
    Array.prototype.find = function (predicate) {
      if (this === null) {
        throw new TypeError('Array.prototype.find called on null or undefined');
      }
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate must be a function');
      }
      var list = Object(this);
      var length = list.length >>> 0;
      var thisArg = arguments[1];
      var value;

      for (var i = 0; i < length; i++) {
        value = list[i];
        if (predicate.call(thisArg, value, i, list)) {
          return value;
        }
      }
      return undefined;
    };
  }

  // TypedArray reduce (needed by Grand Central Core)
  Uint16Array.prototype.reduce = Uint16Array.prototype.reduce || Array.prototype.reduce;

  // Object.assign()
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
  if (typeof Object.assign !== 'function') {
    (function () {
      Object.assign = function (target) {
        'use strict';
        // We must check against these specific cases.

        if (target === undefined || target === null) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];
          if (source !== undefined && source !== null) {
            for (var nextKey in source) {
              if (source.hasOwnProperty(nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    })();
  }
})();
</script>

    <script>
(function(self) {
  'use strict';

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob()
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ]

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    }

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    }
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift()
        return {done: value === undefined, value: value}
      }
    }

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      }
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1])
      }, this)
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var oldValue = this.map[name]
    this.map[name] = oldValue ? oldValue+','+value : value
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    name = normalizeName(name)
    return this.has(name) ? this.map[name] : null
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value)
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this)
      }
    }
  }

  Headers.prototype.keys = function() {
    var items = []
    this.forEach(function(value, name) { items.push(name) })
    return iteratorFor(items)
  }

  Headers.prototype.values = function() {
    var items = []
    this.forEach(function(value) { items.push(value) })
    return iteratorFor(items)
  }

  Headers.prototype.entries = function() {
    var items = []
    this.forEach(function(value, name) { items.push([name, value]) })
    return iteratorFor(items)
  }

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsArrayBuffer(blob)
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader()
    var promise = fileReaderReady(reader)
    reader.readAsText(blob)
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf)
    var chars = new Array(view.length)

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i])
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength)
      view.set(new Uint8Array(buf))
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false

    this._initBody = function(body) {
      this._bodyInit = body
      if (!body) {
        this._bodyText = ''
      } else if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString()
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer)
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer])
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body)
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8')
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type)
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
        }
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      }
    }

    this.text = function() {
      var rejected = consumed(this)
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body && input._bodyInit != null) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = String(input)
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body)
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers()
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ')
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':')
      var key = parts.shift().trim()
      if (key) {
        var value = parts.join(':').trim()
        headers.append(key, value)
      }
    })
    return headers
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this.type = 'default'
    this.status = options.status === undefined ? 200 : options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = 'statusText' in options ? options.statusText : 'OK'
    this.headers = new Headers(options.headers)
    this.url = options.url || ''
    this._initBody(bodyInit)
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers
  self.Request = Request
  self.Response = Response

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init)
      var xhr = new XMLHttpRequest()

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        }
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
        var body = 'response' in xhr ? xhr.response : xhr.responseText
        resolve(new Response(body, options))
      }

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      if (request.credentials === 'include') {
        xhr.withCredentials = true
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true
})(typeof self !== 'undefined' ? self : this);

</script>

    <script>
/** bootstrap strings.  This is an auto-generated file, and must not be
*   modified.  You _can_ modify it, but it'd be pretty pointless and unproductive.
*
*   If you want to modify this, it currently (sept 9 2015) lives in valkyrie-checkout/gruntfile.js,
*   in the generateBootstrapStrings() function.
*
*   This gets baked into index.html via a content-for directive
*/
/* eslint-disable */
window.valkyrie = window.valkyrie || {};
window.valkyrie.transact = window.valkyrie.transact || {};
window.valkyrie.transact.bootstrapStrings = {};

// translation function
window.valkyrie.transact.bootstrap = function(language, stringKey, interpolations, pendingBootstrapStrings) {
  var translatedString = pendingBootstrapStrings && pendingBootstrapStrings[stringKey];
  if (!translatedString) {
    language = language || 'en-gb';
    language = language.toLowerCase();
    // if we don't have a direct locale match in our bootstrap strings,
    // look for the first entry that starts with the provided locale
    if (!window.valkyrie.transact.bootstrapStrings[stringKey]) {
      for (var key in window.valkyrie.transact.bootstrapStrings) {
        if (window.valkyrie.transact.bootstrapStrings.hasOwnProperty(key) &&
            key.indexOf(language) === 0) {
          language = key;
          break;
        }
      }
    }
    translatedString = window.valkyrie.transact.bootstrapStrings[language][stringKey];
  }
  if (!translatedString) {
    // I can't think of a scenario where this isn't a big bug.
    // string not found in bootstraps.  This means the user would see a very ugly error message.
    debugger;
    console.error('We are _completely_ missing translations for ' + stringKey);
    return 'Unknown bootstrap string: ' + stringKey;
  }
  for(var key in interpolations) {
    translatedString = translatedString.replace('{{{' + key + '}}}', interpolations[key]);
    translatedString = translatedString.replace('{{' + key + '}}', interpolations[key]);
  }
  return translatedString;
};

</script>

    <script>
/*!
 * @overview RSVP - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2016 Yehuda Katz, Tom Dale, Stefan Penner and contributors
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE
 * @version   4.7.0
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.RSVP = global.RSVP || {})));
}(this, (function (exports) { 'use strict';

function callbacksFor(object) {
  var callbacks = object._promiseCallbacks;

  if (!callbacks) {
    callbacks = object._promiseCallbacks = {};
  }

  return callbacks;
}

/**
  @class RSVP.EventTarget
*/
var EventTarget = {

  /**
    `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For
    Example:
     ```javascript
    let object = {};
     RSVP.EventTarget.mixin(object);
     object.on('finished', function(event) {
      // handle event
    });
     object.trigger('finished', { detail: value });
    ```
     `EventTarget.mixin` also works with prototypes:
     ```javascript
    let Person = function() {};
    RSVP.EventTarget.mixin(Person.prototype);
     let yehuda = new Person();
    let tom = new Person();
     yehuda.on('poke', function(event) {
      console.log('Yehuda says OW');
    });
     tom.on('poke', function(event) {
      console.log('Tom says OW');
    });
     yehuda.trigger('poke');
    tom.trigger('poke');
    ```
     @method mixin
    @for RSVP.EventTarget
    @private
    @param {Object} object object to extend with EventTarget methods
  */
  mixin: function (object) {
    object['on'] = this['on'];
    object['off'] = this['off'];
    object['trigger'] = this['trigger'];
    object._promiseCallbacks = undefined;
    return object;
  },


  /**
    Registers a callback to be executed when `eventName` is triggered
     ```javascript
    object.on('event', function(eventInfo){
      // handle the event
    });
     object.trigger('event');
    ```
     @method on
    @for RSVP.EventTarget
    @private
    @param {String} eventName name of the event to listen for
    @param {Function} callback function to be called when the event is triggered.
  */
  on: function (eventName, callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('Callback must be a function');
    }

    var allCallbacks = callbacksFor(this),
        callbacks = void 0;

    callbacks = allCallbacks[eventName];

    if (!callbacks) {
      callbacks = allCallbacks[eventName] = [];
    }

    if (callbacks.indexOf(callback)) {
      callbacks.push(callback);
    }
  },


  /**
    You can use `off` to stop firing a particular callback for an event:
     ```javascript
    function doStuff() { // do stuff! }
    object.on('stuff', doStuff);
     object.trigger('stuff'); // doStuff will be called
     // Unregister ONLY the doStuff callback
    object.off('stuff', doStuff);
    object.trigger('stuff'); // doStuff will NOT be called
    ```
     If you don't pass a `callback` argument to `off`, ALL callbacks for the
    event will not be executed when the event fires. For example:
     ```javascript
    let callback1 = function(){};
    let callback2 = function(){};
     object.on('stuff', callback1);
    object.on('stuff', callback2);
     object.trigger('stuff'); // callback1 and callback2 will be executed.
     object.off('stuff');
    object.trigger('stuff'); // callback1 and callback2 will not be executed!
    ```
     @method off
    @for RSVP.EventTarget
    @private
    @param {String} eventName event to stop listening to
    @param {Function} callback optional argument. If given, only the function
    given will be removed from the event's callback queue. If no `callback`
    argument is given, all callbacks will be removed from the event's callback
    queue.
  */
  off: function (eventName, callback) {
    var allCallbacks = callbacksFor(this),
        callbacks = void 0,
        index = void 0;

    if (!callback) {
      allCallbacks[eventName] = [];
      return;
    }

    callbacks = allCallbacks[eventName];

    index = callbacks.indexOf(callback);

    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  },


  /**
    Use `trigger` to fire custom events. For example:
     ```javascript
    object.on('foo', function(){
      console.log('foo event happened!');
    });
    object.trigger('foo');
    // 'foo event happened!' logged to the console
    ```
     You can also pass a value as a second argument to `trigger` that will be
    passed as an argument to all event listeners for the event:
     ```javascript
    object.on('foo', function(value){
      console.log(value.name);
    });
     object.trigger('foo', { name: 'bar' });
    // 'bar' logged to the console
    ```
     @method trigger
    @for RSVP.EventTarget
    @private
    @param {String} eventName name of the event to be triggered
    @param {*} options optional value to be passed to any event handlers for
    the given `eventName`
  */
  trigger: function (eventName, options, label) {
    var allCallbacks = callbacksFor(this),
        callbacks = void 0,
        callback = void 0;

    if (callbacks = allCallbacks[eventName]) {
      // Don't cache the callbacks.length since it may grow
      for (var i = 0; i < callbacks.length; i++) {
        callback = callbacks[i];

        callback(options, label);
      }
    }
  }
};

var config = {
  instrument: false
};

EventTarget['mixin'](config);

function configure(name, value) {
  if (arguments.length === 2) {
    config[name] = value;
  } else {
    return config[name];
  }
}

var queue = [];

function scheduleFlush() {
  setTimeout(function () {
    for (var i = 0; i < queue.length; i++) {
      var entry = queue[i];

      var payload = entry.payload;

      payload.guid = payload.key + payload.id;
      payload.childGuid = payload.key + payload.childId;
      if (payload.error) {
        payload.stack = payload.error.stack;
      }

      config['trigger'](entry.name, entry.payload);
    }
    queue.length = 0;
  }, 50);
}

function instrument(eventName, promise, child) {
  if (1 === queue.push({
    name: eventName,
    payload: {
      key: promise._guidKey,
      id: promise._id,
      eventName: eventName,
      detail: promise._result,
      childId: child && child._id,
      label: promise._label,
      timeStamp: Date.now(),
      error: config["instrument-with-stack"] ? new Error(promise._label) : null
    } })) {
    scheduleFlush();
  }
}

/**
  `RSVP.Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new RSVP.Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = RSVP.Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {*} object value that the returned promise will be resolved with
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object, label) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop, label);
  resolve(promise, object);
  return promise;
}

function withOwnPromise() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function ErrorObject() {
  this.error = null;
}

var GET_THEN_ERROR = new ErrorObject();

function getThen(promise) {
  try {
    return promise.then;
  } catch (error) {
    GET_THEN_ERROR.error = error;
    return GET_THEN_ERROR;
  }
}

var TRY_CATCH_ERROR = new ErrorObject();

var tryCatchCallback = void 0;
function tryCatcher() {
  try {
    var target = tryCatchCallback;
    tryCatchCallback = null;
    return target.apply(this, arguments);
  } catch (e) {
    TRY_CATCH_ERROR.error = e;
    return TRY_CATCH_ERROR;
  }
}

function tryCatch(fn) {
  tryCatchCallback = fn;
  return tryCatcher;
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  config.async(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value, undefined);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    thenable._onError = null;
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      if (thenable === value) {
        fulfill(promise, value);
      } else {
        resolve(promise, value);
      }
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  var isOwnThenable = maybeThenable.constructor === promise.constructor && then$$1 === then && promise.constructor.resolve === resolve$1;

  if (isOwnThenable) {
    handleOwnThenable(promise, maybeThenable);
  } else if (then$$1 === GET_THEN_ERROR) {
    var error = GET_THEN_ERROR.error;
    GET_THEN_ERROR.error = null;
    reject(promise, error);
  } else if (typeof then$$1 === 'function') {
    handleForeignThenable(promise, maybeThenable, then$$1);
  } else {
    fulfill(promise, maybeThenable);
  }
}

function resolve(promise, value) {
  if (promise === value) {
    fulfill(promise, value);
  } else if (objectOrFunction(value)) {
    handleMaybeThenable(promise, value, getThen(value));
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onError) {
    promise._onError(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length === 0) {
    if (config.instrument) {
      instrument('fulfilled', promise);
    }
  } else {
    config.async(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;
  config.async(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var subscribers = parent._subscribers;
  var length = subscribers.length;

  parent._onError = null;

  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    config.async(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (config.instrument) {
    instrument(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);
  }

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      result = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, result);
    } else {
      callback(result);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(state, promise, callback, result) {
  var hasCallback = typeof callback === 'function';
  var value = void 0;

  if (hasCallback) {
    value = tryCatch(callback)(result);
  } else {
    value = result;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (value === promise) {
    reject(promise, withOwnPromise());
  } else if (value === TRY_CATCH_ERROR) {
    var error = value.error;
    value.error = null; // release
    reject(promise, error);
  } else if (hasCallback) {
    resolve(promise, value);
  } else if (state === FULFILLED) {
    fulfill(promise, value);
  } else if (state === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  var resolved = false;
  try {
    resolver(function (value) {
      if (resolved) {
        return;
      }
      resolved = true;
      resolve(promise, value);
    }, function (reason) {
      if (resolved) {
        return;
      }
      resolved = true;
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

function then(onFulfillment, onRejection, label) {
  var parent = this;
  var state = parent._state;

  if (state === FULFILLED && !onFulfillment || state === REJECTED && !onRejection) {
    config.instrument && instrument('chained', parent, parent);
    return parent;
  }

  parent._onError = null;

  var child = new parent.constructor(noop, label);
  var result = parent._result;

  config.instrument && instrument('chained', parent, child);

  if (state === PENDING) {
    subscribe(parent, child, onFulfillment, onRejection);
  } else {
    var callback = state === FULFILLED ? onFulfillment : onRejection;
    config.async(function () {
      return invokeCallback(state, child, callback, result);
    });
  }

  return child;
}

var Enumerator = function () {
  function Enumerator(Constructor, input, abortOnReject, label) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop, label);
    this._abortOnReject = abortOnReject;
    this.isUsingOwnPromise = Constructor === Promise;

    this._init.apply(this, arguments);
  }

  Enumerator.prototype._init = function _init(Constructor, input) {
    var len = input.length || 0;
    this.length = len;
    this._remaining = len;
    this._result = new Array(len);

    this._enumerate(input);
  };

  Enumerator.prototype._enumerate = function _enumerate(input) {
    var length = this.length;
    var promise = this.promise;

    for (var i = 0; promise._state === PENDING && i < length; i++) {
      this._eachEntry(input[i], i, true);
    }

    this._checkFullfillment();
  };

  Enumerator.prototype._checkFullfillment = function _checkFullfillment() {
    if (this._remaining === 0) {
      fulfill(this.promise, this._result);
    }
  };

  Enumerator.prototype._settleMaybeThenable = function _settleMaybeThenable(entry, i, firstPass) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;

    if (resolve$$1 === resolve$1) {
      var then$$1 = getThen(entry);

      if (then$$1 === then && entry._state !== PENDING) {
        entry._onError = null;
        this._settledAt(entry._state, i, entry._result, firstPass);
      } else if (typeof then$$1 !== 'function') {
        this._settledAt(FULFILLED, i, entry, firstPass);
      } else if (this.isUsingOwnPromise) {
        var promise = new c(noop);
        handleMaybeThenable(promise, entry, then$$1);
        this._willSettleAt(promise, i, firstPass);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i, firstPass);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i, firstPass);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i, firstPass) {
    if (entry !== null && typeof entry === 'object') {
      this._settleMaybeThenable(entry, i, firstPass);
    } else {
      this._setResultAt(FULFILLED, i, entry, firstPass);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value, firstPass) {
    var promise = this.promise;

    if (promise._state === PENDING) {
      if (this._abortOnReject && state === REJECTED) {
        reject(promise, value);
      } else {
        this._setResultAt(state, i, value, firstPass);
        this._checkFullfillment();
      }
    }
  };

  Enumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
    this._remaining--;
    this._result[i] = value;
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i, firstPass) {
    var _this = this;

    subscribe(promise, undefined, function (value) {
      return _this._settledAt(FULFILLED, i, value, firstPass);
    }, function (reason) {
      return _this._settledAt(REJECTED, i, reason, firstPass);
    });
  };

  return Enumerator;
}();

function setSettledResult(state, i, value) {
  this._remaining--;
  if (state === FULFILLED) {
    this._result[i] = {
      state: 'fulfilled',
      value: value
    };
  } else {
    this._result[i] = {
      state: 'rejected',
      reason: value
    };
  }
}

/**
  `RSVP.Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  RSVP.Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `RSVP.all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error("2"));
  let promise3 = RSVP.reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  RSVP.Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries, label) {
  if (!Array.isArray(entries)) {
    return this.reject(new TypeError("Promise.all must be called with an array"), label);
  }
  return new Enumerator(this, entries, true /* abort on reject */, label).promise;
}

/**
  `RSVP.Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  RSVP.Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `RSVP.Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  RSVP.Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  RSVP.Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} entries array of promises to observe
  @param {String} label optional string for describing the promise returned.
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries, label) {
  /*jshint validthis:true */
  var Constructor = this;

  var promise = new Constructor(noop, label);

  if (!Array.isArray(entries)) {
    reject(promise, new TypeError('Promise.race must be called with an array'));
    return promise;
  }

  for (var i = 0; promise._state === PENDING && i < entries.length; i++) {
    subscribe(Constructor.resolve(entries[i]), undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }

  return promise;
}

/**
  `RSVP.Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new RSVP.Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = RSVP.Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {*} reason value that the returned promise will be rejected with.
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason, label) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop, label);
  reject(promise, reason);
  return promise;
}

var guidKey = 'rsvp_' + Date.now() + '-';
var counter = 0;

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promiseâ€™s eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class RSVP.Promise
  @param {function} resolver
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @constructor
*/

var Promise = function () {
  function Promise(resolver, label) {
    this._id = counter++;
    this._label = label;
    this._state = undefined;
    this._result = undefined;
    this._subscribers = [];

    config.instrument && instrument('created', this);

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  Promise.prototype._onError = function _onError(reason) {
    var _this = this;

    config.after(function () {
      if (_this._onError) {
        config.trigger('error', reason, _this._label);
      }
    });
  };

  /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
  
    ```js
    function findAuthor(){
      throw new Error('couldn\'t find that author');
    }
  
    // synchronous
    try {
      findAuthor();
    } catch(reason) {
      // something went wrong
    }
  
    // async with promises
    findAuthor().catch(function(reason){
      // something went wrong
    });
    ```
  
    @method catch
    @param {Function} onRejection
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection, label) {
    return this.then(undefined, onRejection, label);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuthor();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuthor();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback, label) {
    var promise = this;
    var constructor = promise.constructor;

    return promise.then(function (value) {
      return constructor.resolve(callback()).then(function () {
        return value;
      });
    }, function (reason) {
      return constructor.resolve(callback()).then(function () {
        throw reason;
      });
    }, label);
  };

  return Promise;
}();

Promise.cast = resolve$1; // deprecated
Promise.all = all;
Promise.race = race;
Promise.resolve = resolve$1;
Promise.reject = reject$1;

Promise.prototype._guidKey = guidKey;

/**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.

  ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```

  Chaining
  --------

  The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.

  ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });

  findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we\'re unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we\'re unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

  ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```

  Assimilation
  ------------

  Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.

  ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```

  If the assimliated promise rejects, then the downstream promise will also reject.

  ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```

  Simple Example
  --------------

  Synchronous Example

  ```javascript
  let result;

  try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```

  Errback Example

  ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```

  Promise Example;

  ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```

  Advanced Example
  --------------

  Synchronous Example

  ```javascript
  let author, books;

  try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```

  Errback Example

  ```js

  function foundBooks(books) {

  }

  function failure(reason) {

  }

  findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```

  Promise Example;

  ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```

  @method then
  @param {Function} onFulfillment
  @param {Function} onRejection
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise}
*/
Promise.prototype.then = then;

function Result() {
  this.value = undefined;
}

var ERROR = new Result();
var GET_THEN_ERROR$1 = new Result();

function getThen$1(obj) {
  try {
    return obj.then;
  } catch (error) {
    ERROR.value = error;
    return ERROR;
  }
}

function tryApply(f, s, a) {
  try {
    f.apply(s, a);
  } catch (error) {
    ERROR.value = error;
    return ERROR;
  }
}

function makeObject(_, argumentNames) {
  var obj = {};
  var length = _.length;
  var args = new Array(length);

  for (var x = 0; x < length; x++) {
    args[x] = _[x];
  }

  for (var i = 0; i < argumentNames.length; i++) {
    var name = argumentNames[i];
    obj[name] = args[i + 1];
  }

  return obj;
}

function arrayResult(_) {
  var length = _.length;
  var args = new Array(length - 1);

  for (var i = 1; i < length; i++) {
    args[i - 1] = _[i];
  }

  return args;
}

function wrapThenable(then, promise) {
  return {
    then: function (onFulFillment, onRejection) {
      return then.call(promise, onFulFillment, onRejection);
    }
  };
}

/**
  `RSVP.denodeify` takes a 'node-style' function and returns a function that
  will return an `RSVP.Promise`. You can use `denodeify` in Node.js or the
  browser when you'd prefer to use promises over using callbacks. For example,
  `denodeify` transforms the following:

  ```javascript
  let fs = require('fs');

  fs.readFile('myfile.txt', function(err, data){
    if (err) return handleError(err);
    handleData(data);
  });
  ```

  into:

  ```javascript
  let fs = require('fs');
  let readFile = RSVP.denodeify(fs.readFile);

  readFile('myfile.txt').then(handleData, handleError);
  ```

  If the node function has multiple success parameters, then `denodeify`
  just returns the first one:

  ```javascript
  let request = RSVP.denodeify(require('request'));

  request('http://example.com').then(function(res) {
    // ...
  });
  ```

  However, if you need all success parameters, setting `denodeify`'s
  second parameter to `true` causes it to return all success parameters
  as an array:

  ```javascript
  let request = RSVP.denodeify(require('request'), true);

  request('http://example.com').then(function(result) {
    // result[0] -> res
    // result[1] -> body
  });
  ```

  Or if you pass it an array with names it returns the parameters as a hash:

  ```javascript
  let request = RSVP.denodeify(require('request'), ['res', 'body']);

  request('http://example.com').then(function(result) {
    // result.res
    // result.body
  });
  ```

  Sometimes you need to retain the `this`:

  ```javascript
  let app = require('express')();
  let render = RSVP.denodeify(app.render.bind(app));
  ```

  The denodified function inherits from the original function. It works in all
  environments, except IE 10 and below. Consequently all properties of the original
  function are available to you. However, any properties you change on the
  denodeified function won't be changed on the original function. Example:

  ```javascript
  let request = RSVP.denodeify(require('request')),
      cookieJar = request.jar(); // <- Inheritance is used here

  request('http://example.com', {jar: cookieJar}).then(function(res) {
    // cookieJar.cookies holds now the cookies returned by example.com
  });
  ```

  Using `denodeify` makes it easier to compose asynchronous operations instead
  of using callbacks. For example, instead of:

  ```javascript
  let fs = require('fs');

  fs.readFile('myfile.txt', function(err, data){
    if (err) { ... } // Handle error
    fs.writeFile('myfile2.txt', data, function(err){
      if (err) { ... } // Handle error
      console.log('done')
    });
  });
  ```

  you can chain the operations together using `then` from the returned promise:

  ```javascript
  let fs = require('fs');
  let readFile = RSVP.denodeify(fs.readFile);
  let writeFile = RSVP.denodeify(fs.writeFile);

  readFile('myfile.txt').then(function(data){
    return writeFile('myfile2.txt', data);
  }).then(function(){
    console.log('done')
  }).catch(function(error){
    // Handle error
  });
  ```

  @method denodeify
  @static
  @for RSVP
  @param {Function} nodeFunc a 'node-style' function that takes a callback as
  its last argument. The callback expects an error to be passed as its first
  argument (if an error occurred, otherwise null), and the value from the
  operation as its second argument ('function(err, value){ }').
  @param {Boolean|Array} [options] An optional paramter that if set
  to `true` causes the promise to fulfill with the callback's success arguments
  as an array. This is useful if the node function has multiple success
  paramters. If you set this paramter to an array with names, the promise will
  fulfill with a hash with these names as keys and the success parameters as
  values.
  @return {Function} a function that wraps `nodeFunc` to return an
  `RSVP.Promise`
  @static
*/
function denodeify(nodeFunc, options) {
  var fn = function () {
    var self = this;
    var l = arguments.length;
    var args = new Array(l + 1);
    var promiseInput = false;

    for (var i = 0; i < l; ++i) {
      var arg = arguments[i];

      if (!promiseInput) {
        // TODO: clean this up
        promiseInput = needsPromiseInput(arg);
        if (promiseInput === GET_THEN_ERROR$1) {
          var p = new Promise(noop);
          reject(p, GET_THEN_ERROR$1.value);
          return p;
        } else if (promiseInput && promiseInput !== true) {
          arg = wrapThenable(promiseInput, arg);
        }
      }
      args[i] = arg;
    }

    var promise = new Promise(noop);

    args[l] = function (err, val) {
      if (err) reject(promise, err);else if (options === undefined) resolve(promise, val);else if (options === true) resolve(promise, arrayResult(arguments));else if (Array.isArray(options)) resolve(promise, makeObject(arguments, options));else resolve(promise, val);
    };

    if (promiseInput) {
      return handlePromiseInput(promise, args, nodeFunc, self);
    } else {
      return handleValueInput(promise, args, nodeFunc, self);
    }
  };

  fn.__proto__ = nodeFunc;

  return fn;
}

function handleValueInput(promise, args, nodeFunc, self) {
  var result = tryApply(nodeFunc, self, args);
  if (result === ERROR) {
    reject(promise, result.value);
  }
  return promise;
}

function handlePromiseInput(promise, args, nodeFunc, self) {
  return Promise.all(args).then(function (args) {
    var result = tryApply(nodeFunc, self, args);
    if (result === ERROR) {
      reject(promise, result.value);
    }
    return promise;
  });
}

function needsPromiseInput(arg) {
  if (arg && typeof arg === 'object') {
    if (arg.constructor === Promise) {
      return true;
    } else {
      return getThen$1(arg);
    }
  } else {
    return false;
  }
}

/**
  This is a convenient alias for `RSVP.Promise.all`.

  @method all
  @static
  @for RSVP
  @param {Array} array Array of promises.
  @param {String} label An optional label. This is useful
  for tooling.
*/
function all$1(array, label) {
  return Promise.all(array, label);
}

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var AllSettled = function (_Enumerator) {
  _inherits(AllSettled, _Enumerator);

  function AllSettled(Constructor, entries, label) {
    return _possibleConstructorReturn(this, _Enumerator.call(this, Constructor, entries, false /* don't abort on reject */, label));
  }

  return AllSettled;
}(Enumerator);

AllSettled.prototype._setResultAt = setSettledResult;

/**
`RSVP.allSettled` is similar to `RSVP.all`, but instead of implementing
a fail-fast method, it waits until all the promises have returned and
shows you all the results. This is useful if you want to handle multiple
promises' failure states together as a set.
 Returns a promise that is fulfilled when all the given promises have been
settled. The return promise is fulfilled with an array of the states of
the promises passed into the `promises` array argument.
 Each state object will either indicate fulfillment or rejection, and
provide the corresponding value or reason. The states will take one of
the following formats:
 ```javascript
{ state: 'fulfilled', value: value }
  or
{ state: 'rejected', reason: reason }
```
 Example:
 ```javascript
let promise1 = RSVP.Promise.resolve(1);
let promise2 = RSVP.Promise.reject(new Error('2'));
let promise3 = RSVP.Promise.reject(new Error('3'));
let promises = [ promise1, promise2, promise3 ];
 RSVP.allSettled(promises).then(function(array){
  // array == [
  //   { state: 'fulfilled', value: 1 },
  //   { state: 'rejected', reason: Error },
  //   { state: 'rejected', reason: Error }
  // ]
  // Note that for the second item, reason.message will be '2', and for the
  // third item, reason.message will be '3'.
}, function(error) {
  // Not run. (This block would only be called if allSettled had failed,
  // for instance if passed an incorrect argument type.)
});
```
 @method allSettled
@static
@for RSVP
@param {Array} entries
@param {String} label - optional string that describes the promise.
Useful for tooling.
@return {Promise} promise that is fulfilled with an array of the settled
states of the constituent promises.
*/

function allSettled(entries, label) {
  if (!Array.isArray(entries)) {
    return Promise.reject(new TypeError("Promise.allSettled must be called with an array"), label);
  }

  return new AllSettled(Promise, entries, label).promise;
}

/**
  This is a convenient alias for `RSVP.Promise.race`.

  @method race
  @static
  @for RSVP
  @param {Array} array Array of promises.
  @param {String} label An optional label. This is useful
  for tooling.
 */
function race$1(array, label) {
  return Promise.race(array, label);
}

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hasOwnProperty = Object.prototype.hasOwnProperty;

var PromiseHash = function (_Enumerator) {
  _inherits$1(PromiseHash, _Enumerator);

  function PromiseHash(Constructor, object) {
    var abortOnReject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    var label = arguments[3];
    return _possibleConstructorReturn$1(this, _Enumerator.call(this, Constructor, object, abortOnReject, label));
  }

  PromiseHash.prototype._init = function _init(Constructor, object) {
    this._result = {};

    this._enumerate(object);
    if (this._remaining === 0) {
      fulfill(this.promise, this._result);
    }
  };

  PromiseHash.prototype._enumerate = function _enumerate(input) {
    var promise = this.promise;
    var results = [];

    for (var key in input) {
      if (hasOwnProperty.call(input, key)) {
        results.push({
          position: key,
          entry: input[key]
        });
      }
    }

    var length = results.length;
    this._remaining = length;
    var result = void 0;

    for (var i = 0; promise._state === PENDING && i < length; i++) {
      result = results[i];
      this._eachEntry(result.entry, result.position);
    }
  };

  return PromiseHash;
}(Enumerator);

/**
  `RSVP.hash` is similar to `RSVP.all`, but takes an object instead of an array
  for its `promises` argument.

  Returns a promise that is fulfilled when all the given promises have been
  fulfilled, or rejected if any of them become rejected. The returned promise
  is fulfilled with a hash that has the same key names as the `promises` object
  argument. If any of the values in the object are not promises, they will
  simply be copied over to the fulfilled object.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.resolve(1),
    yourPromise: RSVP.resolve(2),
    theirPromise: RSVP.resolve(3),
    notAPromise: 4
  };

  RSVP.hash(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise: 1,
    //   yourPromise: 2,
    //   theirPromise: 3,
    //   notAPromise: 4
    // }
  });
  ````

  If any of the `promises` given to `RSVP.hash` are rejected, the first promise
  that is rejected will be given as the reason to the rejection handler.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.resolve(1),
    rejectedPromise: RSVP.reject(new Error('rejectedPromise')),
    anotherRejectedPromise: RSVP.reject(new Error('anotherRejectedPromise')),
  };

  RSVP.hash(promises).then(function(hash){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === 'rejectedPromise'
  });
  ```

  An important note: `RSVP.hash` is intended for plain JavaScript objects that
  are just a set of keys and values. `RSVP.hash` will NOT preserve prototype
  chains.

  Example:

  ```javascript
  function MyConstructor(){
    this.example = RSVP.resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: RSVP.resolve('Proto Property')
  };

  let myObject = new MyConstructor();

  RSVP.hash(myObject).then(function(hash){
    // protoProperty will not be present, instead you will just have an
    // object that looks like:
    // {
    //   example: 'Example'
    // }
    //
    // hash.hasOwnProperty('protoProperty'); // false
    // 'undefined' === typeof hash.protoProperty
  });
  ```

  @method hash
  @static
  @for RSVP
  @param {Object} object
  @param {String} label optional string that describes the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all properties of `promises`
  have been fulfilled, or rejected if any of them become rejected.
*/
function hash(object, label) {
  if (object === null || typeof object !== 'object') {
    return Promise.reject(new TypeError("Promise.hash must be called with an object"), label);
  }

  return new PromiseHash(Promise, object, label).promise;
}

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var HashSettled = function (_PromiseHash) {
  _inherits$2(HashSettled, _PromiseHash);

  function HashSettled(Constructor, object, label) {
    return _possibleConstructorReturn$2(this, _PromiseHash.call(this, Constructor, object, false, label));
  }

  return HashSettled;
}(PromiseHash);

HashSettled.prototype._setResultAt = setSettledResult;

/**
  `RSVP.hashSettled` is similar to `RSVP.allSettled`, but takes an object
  instead of an array for its `promises` argument.

  Unlike `RSVP.all` or `RSVP.hash`, which implement a fail-fast method,
  but like `RSVP.allSettled`, `hashSettled` waits until all the
  constituent promises have returned and then shows you all the results
  with their states and values/reasons. This is useful if you want to
  handle multiple promises' failure states together as a set.

  Returns a promise that is fulfilled when all the given promises have been
  settled, or rejected if the passed parameters are invalid.

  The returned promise is fulfilled with a hash that has the same key names as
  the `promises` object argument. If any of the values in the object are not
  promises, they will be copied over to the fulfilled object and marked with state
  'fulfilled'.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.Promise.resolve(1),
    yourPromise: RSVP.Promise.resolve(2),
    theirPromise: RSVP.Promise.resolve(3),
    notAPromise: 4
  };

  RSVP.hashSettled(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise: { state: 'fulfilled', value: 1 },
    //   yourPromise: { state: 'fulfilled', value: 2 },
    //   theirPromise: { state: 'fulfilled', value: 3 },
    //   notAPromise: { state: 'fulfilled', value: 4 }
    // }
  });
  ```

  If any of the `promises` given to `RSVP.hash` are rejected, the state will
  be set to 'rejected' and the reason for rejection provided.

  Example:

  ```javascript
  let promises = {
    myPromise: RSVP.Promise.resolve(1),
    rejectedPromise: RSVP.Promise.reject(new Error('rejection')),
    anotherRejectedPromise: RSVP.Promise.reject(new Error('more rejection')),
  };

  RSVP.hashSettled(promises).then(function(hash){
    // hash here is an object that looks like:
    // {
    //   myPromise:              { state: 'fulfilled', value: 1 },
    //   rejectedPromise:        { state: 'rejected', reason: Error },
    //   anotherRejectedPromise: { state: 'rejected', reason: Error },
    // }
    // Note that for rejectedPromise, reason.message == 'rejection',
    // and for anotherRejectedPromise, reason.message == 'more rejection'.
  });
  ```

  An important note: `RSVP.hashSettled` is intended for plain JavaScript objects that
  are just a set of keys and values. `RSVP.hashSettled` will NOT preserve prototype
  chains.

  Example:

  ```javascript
  function MyConstructor(){
    this.example = RSVP.Promise.resolve('Example');
  }

  MyConstructor.prototype = {
    protoProperty: RSVP.Promise.resolve('Proto Property')
  };

  let myObject = new MyConstructor();

  RSVP.hashSettled(myObject).then(function(hash){
    // protoProperty will not be present, instead you will just have an
    // object that looks like:
    // {
    //   example: { state: 'fulfilled', value: 'Example' }
    // }
    //
    // hash.hasOwnProperty('protoProperty'); // false
    // 'undefined' === typeof hash.protoProperty
  });
  ```

  @method hashSettled
  @for RSVP
  @param {Object} object
  @param {String} label optional string that describes the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when when all properties of `promises`
  have been settled.
  @static
*/

function hashSettled(object, label) {
  if (object === null || typeof object !== 'object') {
    return Promise.reject(new TypeError("RSVP.hashSettled must be called with an object"), label);
  }

  return new HashSettled(Promise, object, false, label).promise;
}

/**
  `RSVP.rethrow` will rethrow an error on the next turn of the JavaScript event
  loop in order to aid debugging.

  Promises A+ specifies that any exceptions that occur with a promise must be
  caught by the promises implementation and bubbled to the last handler. For
  this reason, it is recommended that you always specify a second rejection
  handler function to `then`. However, `RSVP.rethrow` will throw the exception
  outside of the promise, so it bubbles up to your console if in the browser,
  or domain/cause uncaught exception in Node. `rethrow` will also throw the
  error again so the error can be handled by the promise per the spec.

  ```javascript
  function throws(){
    throw new Error('Whoops!');
  }

  let promise = new RSVP.Promise(function(resolve, reject){
    throws();
  });

  promise.catch(RSVP.rethrow).then(function(){
    // Code here doesn't run because the promise became rejected due to an
    // error!
  }, function (err){
    // handle the error here
  });
  ```

  The 'Whoops' error will be thrown on the next turn of the event loop
  and you can watch for it in your console. You can also handle it using a
  rejection handler given to `.then` or `.catch` on the returned promise.

  @method rethrow
  @static
  @for RSVP
  @param {Error} reason reason the promise became rejected.
  @throws Error
  @static
*/
function rethrow(reason) {
  setTimeout(function () {
    throw reason;
  });
  throw reason;
}

/**
  `RSVP.defer` returns an object similar to jQuery's `$.Deferred`.
  `RSVP.defer` should be used when porting over code reliant on `$.Deferred`'s
  interface. New code should use the `RSVP.Promise` constructor instead.

  The object returned from `RSVP.defer` is a plain object with three properties:

  * promise - an `RSVP.Promise`.
  * reject - a function that causes the `promise` property on this object to
    become rejected
  * resolve - a function that causes the `promise` property on this object to
    become fulfilled.

  Example:

   ```javascript
   let deferred = RSVP.defer();

   deferred.resolve("Success!");

   deferred.promise.then(function(value){
     // value here is "Success!"
   });
   ```

  @method defer
  @static
  @for RSVP
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Object}
 */

function defer(label) {
  var deferred = { resolve: undefined, reject: undefined };

  deferred.promise = new Promise(function (resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  }, label);

  return deferred;
}

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MapEnumerator = function (_Enumerator) {
  _inherits$3(MapEnumerator, _Enumerator);

  function MapEnumerator(Constructor, entries, mapFn, label) {
    return _possibleConstructorReturn$3(this, _Enumerator.call(this, Constructor, entries, true, label, mapFn));
  }

  MapEnumerator.prototype._init = function _init(Constructor, input, bool, label, mapFn) {
    var len = input.length || 0;
    this.length = len;
    this._remaining = len;
    this._result = new Array(len);
    this._mapFn = mapFn;

    this._enumerate(input);
  };

  MapEnumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
    if (firstPass) {
      var val = tryCatch(this._mapFn)(value, i);
      if (val === TRY_CATCH_ERROR) {
        this._settledAt(REJECTED, i, val.error, false);
      } else {
        this._eachEntry(val, i, false);
      }
    } else {
      this._remaining--;
      this._result[i] = value;
    }
  };

  return MapEnumerator;
}(Enumerator);

/**
 `RSVP.map` is similar to JavaScript's native `map` method. `mapFn` is eagerly called
  meaning that as soon as any promise resolves its value will be passed to `mapFn`.
  `RSVP.map` returns a promise that will become fulfilled with the result of running
  `mapFn` on the values the promises become fulfilled with.

  For example:

  ```javascript

  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

  RSVP.map(promises, mapFn).then(function(result){
    // result is [ 2, 3, 4 ]
  });
  ```

  If any of the `promises` given to `RSVP.map` are rejected, the first promise
  that is rejected will be given as an argument to the returned promise's
  rejection handler. For example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error('2'));
  let promise3 = RSVP.reject(new Error('3'));
  let promises = [ promise1, promise2, promise3 ];

  let mapFn = function(item){
    return item + 1;
  };

  RSVP.map(promises, mapFn).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === '2'
  });
  ```

  `RSVP.map` will also wait if a promise is returned from `mapFn`. For example,
  say you want to get all comments from a set of blog posts, but you need
  the blog posts first because they contain a url to those comments.

  ```javscript

  let mapFn = function(blogPost){
    // getComments does some ajax and returns an RSVP.Promise that is fulfilled
    // with some comments data
    return getComments(blogPost.comments_url);
  };

  // getBlogPosts does some ajax and returns an RSVP.Promise that is fulfilled
  // with some blog post data
  RSVP.map(getBlogPosts(), mapFn).then(function(comments){
    // comments is the result of asking the server for the comments
    // of all blog posts returned from getBlogPosts()
  });
  ```

  @method map
  @static
  @for RSVP
  @param {Array} promises
  @param {Function} mapFn function to be called on each fulfilled promise.
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled with the result of calling
  `mapFn` on each fulfilled promise or value when they become fulfilled.
   The promise will be rejected if any of the given `promises` become rejected.
  @static
*/


function map(promises, mapFn, label) {
  if (!Array.isArray(promises)) {
    return Promise.reject(new TypeError("RSVP.map must be called with an array"), label);
  }

  if (typeof mapFn !== 'function') {
    return Promise.reject(new TypeError("RSVP.map expects a function as a second argument"), label);
  }

  return new MapEnumerator(Promise, promises, mapFn, label).promise;
}

/**
  This is a convenient alias for `RSVP.Promise.resolve`.

  @method resolve
  @static
  @for RSVP
  @param {*} value value that the returned promise will be resolved with
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$2(value, label) {
  return Promise.resolve(value, label);
}

/**
  This is a convenient alias for `RSVP.Promise.reject`.

  @method reject
  @static
  @for RSVP
  @param {*} reason value that the returned promise will be rejected with.
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$2(reason, label) {
  return Promise.reject(reason, label);
}

function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EMPTY_OBJECT = {};

var FilterEnumerator = function (_Enumerator) {
  _inherits$4(FilterEnumerator, _Enumerator);

  function FilterEnumerator(Constructor, entries, filterFn, label) {
    return _possibleConstructorReturn$4(this, _Enumerator.call(this, Constructor, entries, true, label, filterFn));
  }

  FilterEnumerator.prototype._init = function _init(Constructor, input, bool, label, filterFn) {
    var len = input.length || 0;
    this.length = len;
    this._remaining = len;

    this._result = new Array(len);
    this._filterFn = filterFn;

    this._enumerate(input);
  };

  FilterEnumerator.prototype._checkFullfillment = function _checkFullfillment() {
    if (this._remaining === 0) {
      this._result = this._result.filter(function (val) {
        return val !== EMPTY_OBJECT;
      });
      fulfill(this.promise, this._result);
    }
  };

  FilterEnumerator.prototype._setResultAt = function _setResultAt(state, i, value, firstPass) {
    if (firstPass) {
      this._result[i] = value;
      var val = tryCatch(this._filterFn)(value, i);
      if (val === TRY_CATCH_ERROR) {
        this._settledAt(REJECTED, i, val.error, false);
      } else {
        this._eachEntry(val, i, false);
      }
    } else {
      this._remaining--;
      if (!value) {
        this._result[i] = EMPTY_OBJECT;
      }
    }
  };

  return FilterEnumerator;
}(Enumerator);

/**
 `RSVP.filter` is similar to JavaScript's native `filter` method.
 `filterFn` is eagerly called meaning that as soon as any promise
  resolves its value will be passed to `filterFn`. `RSVP.filter` returns
  a promise that will become fulfilled with the result of running
  `filterFn` on the values the promises become fulfilled with.

  For example:

  ```javascript

  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.resolve(2);
  let promise3 = RSVP.resolve(3);

  let promises = [promise1, promise2, promise3];

  let filterFn = function(item){
    return item > 1;
  };

  RSVP.filter(promises, filterFn).then(function(result){
    // result is [ 2, 3 ]
  });
  ```

  If any of the `promises` given to `RSVP.filter` are rejected, the first promise
  that is rejected will be given as an argument to the returned promise's
  rejection handler. For example:

  ```javascript
  let promise1 = RSVP.resolve(1);
  let promise2 = RSVP.reject(new Error('2'));
  let promise3 = RSVP.reject(new Error('3'));
  let promises = [ promise1, promise2, promise3 ];

  let filterFn = function(item){
    return item > 1;
  };

  RSVP.filter(promises, filterFn).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(reason) {
    // reason.message === '2'
  });
  ```

  `RSVP.filter` will also wait for any promises returned from `filterFn`.
  For instance, you may want to fetch a list of users then return a subset
  of those users based on some asynchronous operation:

  ```javascript

  let alice = { name: 'alice' };
  let bob   = { name: 'bob' };
  let users = [ alice, bob ];

  let promises = users.map(function(user){
    return RSVP.resolve(user);
  });

  let filterFn = function(user){
    // Here, Alice has permissions to create a blog post, but Bob does not.
    return getPrivilegesForUser(user).then(function(privs){
      return privs.can_create_blog_post === true;
    });
  };
  RSVP.filter(promises, filterFn).then(function(users){
    // true, because the server told us only Alice can create a blog post.
    users.length === 1;
    // false, because Alice is the only user present in `users`
    users[0] === bob;
  });
  ```

  @method filter
  @static
  @for RSVP
  @param {Array} promises
  @param {Function} filterFn - function to be called on each resolved value to
  filter the final results.
  @param {String} label optional string describing the promise. Useful for
  tooling.
  @return {Promise}
*/

function filter(promises, filterFn, label) {
  if (!Array.isArray(promises) && !(promises !== null && typeof promises === 'object' && promises.then !== undefined)) {
    return Promise.reject(new TypeError("RSVP.filter must be called with an array or promise"), label);
  }

  if (typeof filterFn !== 'function') {
    return Promise.reject(new TypeError("RSVP.filter expects function as a second argument"), label);
  }

  return Promise.resolve(promises, label).then(function (promises) {
    return new FilterEnumerator(Promise, promises, filterFn, label).promise;
  });
}

var len = 0;
var vertxNext = void 0;
function asap(callback, arg) {
  queue$1[len] = callback;
  queue$1[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 1, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    scheduleFlush$1();
  }
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  var nextTick = process.nextTick;
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // setImmediate should be used instead instead
  var version = process.versions.node.match(/^(?:(\d+)\.)?(?:(\d+)\.)?(\*|\d+)$/);
  if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {
    nextTick = setImmediate;
  }
  return function () {
    return nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }
  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    return node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  return function () {
    return setTimeout(flush, 1);
  };
}

var queue$1 = new Array(1000);

function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue$1[i];
    var arg = queue$1[i + 1];

    callback(arg);

    queue$1[i] = undefined;
    queue$1[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertex() {
  try {
    var r = require;
    var vertx = r('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush$1 = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush$1 = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush$1 = useMutationObserver();
} else if (isWorker) {
  scheduleFlush$1 = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush$1 = attemptVertex();
} else {
  scheduleFlush$1 = useSetTimeout();
}

var platform = void 0;

/* global self */
if (typeof self === 'object') {
  platform = self;

  /* global global */
} else if (typeof global === 'object') {
  platform = global;
} else {
  throw new Error('no global: `self` or `global` found');
}

var _asap$cast$Promise$Ev;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// defaults
config.async = asap;
config.after = function (cb) {
  return setTimeout(cb, 0);
};
var cast = resolve$2;

var async = function (callback, arg) {
  return config.async(callback, arg);
};

function on() {
  config['on'].apply(config, arguments);
}

function off() {
  config['off'].apply(config, arguments);
}

// Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`
if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {
  var callbacks = window['__PROMISE_INSTRUMENTATION__'];
  configure('instrument', true);
  for (var eventName in callbacks) {
    if (callbacks.hasOwnProperty(eventName)) {
      on(eventName, callbacks[eventName]);
    }
  }
}

// the default export here is for backwards compat:
//   https://github.com/tildeio/rsvp.js/issues/434
var rsvp = (_asap$cast$Promise$Ev = {
  asap: asap,
  cast: cast,
  Promise: Promise,
  EventTarget: EventTarget,
  all: all$1,
  allSettled: allSettled,
  race: race$1,
  hash: hash,
  hashSettled: hashSettled,
  rethrow: rethrow,
  defer: defer,
  denodeify: denodeify,
  configure: configure,
  on: on,
  off: off,
  resolve: resolve$2,
  reject: reject$2,
  map: map
}, _defineProperty(_asap$cast$Promise$Ev, 'async', async), _defineProperty(_asap$cast$Promise$Ev, 'filter', filter), _asap$cast$Promise$Ev);

exports['default'] = rsvp;
exports.asap = asap;
exports.cast = cast;
exports.Promise = Promise;
exports.EventTarget = EventTarget;
exports.all = all$1;
exports.allSettled = allSettled;
exports.race = race$1;
exports.hash = hash;
exports.hashSettled = hashSettled;
exports.rethrow = rethrow;
exports.defer = defer;
exports.denodeify = denodeify;
exports.configure = configure;
exports.on = on;
exports.off = off;
exports.resolve = resolve$2;
exports.reject = reject$2;
exports.map = map;
exports.async = async;
exports.filter = filter;

Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=rsvp.map

</script>
    <script>window.Promise = RSVP.Promise;</script>

    <script>
/* eslint-disable */
/**
 * å±é™º! ACHTUNG! PELIGRO! WARNING! DO NOT DIRECTLY EDIT!
 * This file has been auto-generated by grunt-clairvoyance
 * Date generated: Mon Feb 10 2020 11:27:18 GMT-0600 (Central Standard Time)
 * @see https://github.snei.sony.com/SNEI/grunt-clairvoyance/
 */
window.valkyrie = window.valkyrie || {};
window.valkyrie.transact = window.valkyrie.transact || {};
window.valkyrie.transact.clairvoyance = window.valkyrie.transact.clairvoyance || {};
window.valkyrie.transact.clairvoyance.metrics = {
  "web:cam:supplemental api call:timing:api-topup-apm-patch:mistercash": 5232,
  "web:cam:add funds:apm chinaunionpay:timing:overall": 5250,
  "web:cam:voucher redeem:subscription review:timing:api-fetchPaymentInstruments": 2213,
  "web:cam:payment settings:paypal reverify:timing:overall": 3016,
  "web:cam:supplemental api call:timing:api-topup-apm-post:mistercash": 5231,
  "web:cam:add funds:mobile start:timing:overall": 2247,
  "web:cam:payment settings:choose payment method:timing:api-fetchDmaByZip": 2508,
  "web:cam:voucher redeem:update address:timing:api-fetchWallet-cached": 2176,
  "web:cam:payment settings:select payment method:timing:api-fetchPaymentInstruments-cached": 2201,
  "web:cam:payment settings:edit payment method:timing:overall": 2224,
  "web:cam:supplemental api call:timing:api-fetchTransactions-cached": 5267,
  "web:cam:transaction history:results loaded": 5169,
  "web:cam:application:route:timing:preflight-accountDetails": 2229,
  "web:cam:voucher redeem:multiple product review:timing:api-fetchWallet": 2157,
  "web:cam:voucher redeem:multiple product review:timing:api-previewVoucher": 2162,
  "web:cam:application:route:timing:preflight-gcAuth": 2227,
  "web:cam:payment settings:choose payment method:timing:api-putDma": 2509,
  "web:cam:supplemental api call:timing:api-topup-apm-post:yandexmoney": 5239,
  "web:cam:voucher redeem:single product review:timing:overall": 2167,
  "web:cam:voucher redeem:product voucher redeemed:timing:api-redeem": 2217,
  "web:cam:payment settings:add payment method:timing:api-fetchPaymentMethods-cached": 2174,
  "web:cam:voucher redeem:multiple product review:timing:overall": 2236,
  "web:cam:payment settings:set default method:timing:api-fetchPaymentInstruments": 2150,
  "web:cam:payment settings:verify mobile phone:timing:api-completeAddBokuDI": 5923,
  "web:cam:add funds:start page:timing:overall": 2240,
  "web:cam:payment settings:payment method detail:timing:overall": 2188,
  "web:cam:payment settings:add paypal method:timing:api-fetchPaymentInstrument": 2191,
  "web:cam:add funds:apm ideal:timing:overall": 5252,
  "web:cam:voucher redeem:subscription review:timing:api-fetchWallet": 2210,
  "web:cam:payment settings:choose payment method:timing:api-fetchPaymentInstruments": 2143,
  "web:cam:payment settings:edit payment method:timing:api-fetchPaymentMethods": 2163,
  "web:cam:payment settings:add payment method:timing:api-fetchPaymentMethods": 2212,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:cashu": 5225,
  "web:cam:payment settings:remove payment method:timing:overall": 2153,
  "web:cam:add funds:apm alipay:timing:overall": 5248,
  "web:cam:payment settings:add paypal method:timing:overall": 2173,
  "web:cam:voucher redeem:funds voucher confirmation:timing:overall": 2214,
  "web:cam:voucher redeem:single product review:timing:api-fetchWallet-cached": 2200,
  "web:cam:payment settings:choose payment method:timing:api-fetchPaymentMethods": 2144,
  "web:cam:add funds:thank you:timing:api-topup": 2211,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:paysafecard": 5234,
  "web:cam:application:firstView:timing:overall": 2574,
  "web:cam:payment settings:remove payment method:timing:api-fetchPaymentInstrument": 2197,
  "web:cam:add funds:start:3DS:timing:api-fetchCreditCard-cached": 2245,
  "web:cam:payment settings:select payment method:timing:api-fetchWallet": 2199,
  "web:cam:supplemental api call:timing:api-topup-apm-post:ideal": 5229,
  "web:cam:age verification:start:timing:overall": 2237,
  "web:cam:add funds:start page:timing:api-fetchPaymentInstruments": 2257,
  "web:cam:age verification:pass:timing:overall": 2238,
  "web:cam:add funds:apm boku:timing:overall": 5258,
  "web:cam:payment settings:select payment method:timing:api-fetchPaymentMethods-cached": 2171,
  "web:cam:voucher redeem:enter code:timing:overall": 2140,
  "web:cam:payment settings:add payment method:timing:overall": 2155,
  "web:cam:payment settings:mobile phone payment method details:timing:overall": 5921,
  "web:cam:payment settings:choose payment method:timing:api-fetchWallet-cached": 2148,
  "web:cam:add funds:start:3DS:timing:overall": 2243,
  "web:cam:transaction history:transaction list:timing:overall": 5167,
  "web:cam:payment settings:choose payment method:timing:api-fetchPaymentInstruments-cached": 2146,
  "web:cam:payment settings:select payment method:timing:api-fetchPaymentInstruments": 2187,
  "web:cam:payment settings:paypal verify:timing:overall": 3015,
  "web:cam:add funds:thank you:timing:api-completeVerifyPayPalDI": 3017,
  "web:cam:payment settings:choose payment method:timing:overall": 2142,
  "web:cam:voucher redeem:single product review:timing:api-fetchWallet": 2202,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:chinaunionpay": 5223,
  "web:cam:supplemental api call:timing:api-fetchWallet-cached": 5266,
  "web:cam:supplemental api call:timing:api-fetchTransactions": 5183,
  "web:cam:add funds:thank you:timing:api-fetchWallet-cached": 3019,
  "web:cam:add funds:thank you:timing:api-fetchWallet": 3018,
  "web:cam:payment settings:cvv verify:timing:overall": 2181,
  "web:cam:add funds:apm loading:timing:overall": 2250,
  "web:cam:supplemental api call:timing:api-topup-apm-post:paysafecard": 5233,
  "web:cam:application:firstViewPanel:timing:overall": 5892,
  "web:cam:payment settings:paypal not default method:timing:overall": 2192,
  "web:cam:transaction history:transaction detail:timing:overall": 5168,
  "web:cam:payment settings:choose payment method:timing:api-fetchPaymentMethods-cached": 2147,
  "web:cam:add funds:timing:api-fetchPaymentInstruments": 2194,
  "web:cam:payment settings:verify mobile phone:timing:overall": 5922,
  "web:cam:payment settings:edit payment method:timing:api-fetchCreditCard": 2178,
  "web:cam:add funds:paypal:timing:overall": 2248,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:boku": 5242,
  "web:cam:application:flowView:timing:overall": 2575,
  "web:cam:add funds:timing:api-fetchWallet-cached": 2209,
  "web:cam:add funds:apm sofort:timing:overall": 5256,
  "web:cam:voucher redeem:update address:timing:overall": 2172,
  "web:cam:voucher redeem:subscription review:timing:overall": 2222,
  "web:cam:supplemental api call:timing:api-fetchWallet": 5265,
  "web:cam:application:route:timing:preflight-gatedAccessToken": 2707,
  "web:cam:application:route:timing:preflight-cultureCode": 2234,
  "web:cam:payment settings:select payment method:timing:overall": 2175,
  "web:cam:payment settings:add paypal method:timing:api-completeAddPayPalDI": 2152,
  "web:cam:add funds:start page:timing:api-fetchCreditCard": 2241,
  "web:cam:voucher redeem:funds voucher review:timing:api-fetchWallet": 2190,
  "web:cam:payment settings:add mobile phone:timing:api-completeAddBokuDI": 5919,
  "web:cam:payment settings:cvv verify:timing:api-fetchPaymentInstrument": 2179,
  "web:cam:voucher redeem:product voucher redeemed:timing:overall": 2165,
  "web:cam:voucher redeem:funds voucher review:timing:overall": 2203,
  "web:cam:voucher redeem:product voucher redeemed:timing:api-fetchPaymentInstruments-cached": 2189,
  "web:cam:add funds:start page:timing:api-fetchPaymentMethods": 2256,
  "web:cam:voucher redeem:single product review:timing:api-previewVoucher": 2207,
  "web:cam:supplemental api call:timing:api-topup-apm-post:sofort": 5237,
  "web:cam:payment settings:select payment method:timing:api-fetchWallet-cached": 2168,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:postepay": 5236,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:ideal": 5230,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:sofort": 5238,
  "web:cam:payment settings:add mobile phone:timing:api-beginAddBokuDI": 5920,
  "web:cam:voucher redeem:multiple product review:product detail:timing:overall": 2141,
  "web:cam:payment settings:add mobile phone:timing:overall": 5918,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:giropay": 5228,
  "web:cam:payment settings:set default method:timing:overall": 2149,
  "web:cam:application:route:timing:preflight-bootstrapCultureCode": 2235,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:yandexmoney": 5240,
  "web:cam:voucher redeem:subscription review:timing:api-fetchPaymentInstruments-cached": 2216,
  "web:cam:add funds:apm mistercash:timing:overall": 5253,
  "web:cam:add funds:start page:timing:api-fetchCreditCard-cached": 2242,
  "web:cam:add funds:start:3DS:timing:api-fetchCreditCard": 2244,
  "web:cam:supplemental api call:timing:api-topup-apm-patch:alipay": 5222,
  "web:cam:voucher redeem:update address:timing:api-fetchSubdivisions": 2154,
  "web:cam:payment settings:add paypal method:timing:api-beginAddPayPalDI": 2215,
  "web:cam:payment settings:add payment method:timing:api-fetchWallet-cached": 2206,
  "web:cam:add funds:apm giropay:timing:overall": 5251,
  "web:cam:payment settings:paypal not default method:api-fetchPaymentInstrument": 2161,
  "web:cam:application:route:timing:preflight-accessToken": 2230,
  "web:cam:payment settings:set default method:timing:api-fetchPaymentInstruments-cached": 2151,
  "web:cam:voucher redeem:product voucher redeemed:timing:api-fetchPaymentInstruments": 2185,
  "web:cam:supplemental api call:timing:api-topup-apm-post:postepay": 5235,
  "web:cam:voucher redeem:subscription review:timing:api-previewVoucher": 2208,
  "web:cam:supplemental api call": 5182,
  "web:cam:payment settings:add funds:timing:api-fetchPaymentInstruments-cached": 2218,
  "web:cam:supplemental api call:timing:api-topup-apm-post:alipay": 5221,
  "web:cam:payment settings:cvv verify:timing:api-fetchSubdivision": 2169,
  "web:cam:voucher redeem:funds voucher review:timing:api-fetchWallet-cached": 2164,
  "web:cam:application:route:timing:overall": 2226,
  "web:cam:application:flowViewInLine:timing:overall": 5891,
  "web:cam:add funds:thank you:3DS:timing:overall": 2156,
  "web:cam:voucher redeem:update address:timing:api-previewVoucher": 2193,
  "web:cam:add funds:paypal:timing:api-fetchPayPalDI": 2249,
  "web:cam:add funds:apm paysafecard:timing:overall": 5254,
  "web:cam:supplemental api call:timing:api-topup-apm-post:giropay": 5227,
  "web:cam:payment settings:select payment method:timing:api-fetchPaymentMethods": 2166,
  "web:cam:payment settings:add payment information:timing:overall": 2196,
  "web:cam:voucher redeem:funds voucher review:timing:api-previewVoucher": 2183,
  "web:cam:payment settings:add payment method:timing:api-fetchWallet": 2220,
  "web:cam:add funds:thank you:timing:overall": 2158,
  "web:cam:add funds:apm postepay:timing:overall": 5255,
  "web:cam:supplemental api call:timing:api-topup-apm-post:boku": 5241,
  "web:cam:add funds:apm yandexmoney:timing:overall": 5257,
  "web:cam:payment settings:choose payment method:timing:api-fetchWallet": 2145,
  "web:cam:application:route:timing:preflight-config": 2232,
  "web:cam:payment settings:verify mobile phone:timing:api-beginAddBokuDI": 5924,
  "web:cam:payment settings:add paypal method:timing:api-fetchPaymentInstruments": 2205,
  "web:cam:add funds:apm start:timing:overall": 2246,
  "web:cam:add funds:apm cashu:timing:overall": 5249,
  "web:cam:3ds:start:timing:overall": 5774,
  "web:cam:payment settings:add funds:timing:api-fetchWallet": 2221,
  "web:cam:application:route:timing:preflight-i18n": 2233,
  "web:cam:age verification:no pass:timing:overall": 2239,
  "web:cam:add funds:timing:overall": 2219,
  "web:cam:voucher redeem:funds voucher confirmation:timing:api-topup": 2177,
  "web:cam:supplemental api call:timing:api-topup-apm-post:cashu": 5226,
  "web:cam:application:route:timing:preflight-gcTelemetry": 2228,
  "web:cam:application:route:timing:preflight-currencyDetails": 2231,
  "web:cam:add funds:start page:timing:api-fetchWallet": 2255,
  "web:cam:payment settings:add funds:timing:api-fetchPaymentMethods": 2182,
  "web:cam:voucher redeem:subscription review:timing:api-fetchWallet-cached": 2195,
  "web:cam:transaction history:results loaded:timing:api-fetchTransactions": 5181,
  "web:cam:payment settings:add payment method:timing:api-fetchPaymentInstruments": 2225,
  "web:cam:voucher redeem:multiple product review:timing:api-fetchWallet-cached": 2180,
  "web:cam:supplemental api call:timing:api-topup-apm-post:chinaunionpay": 5224,
  "web:cam:payment settings:payment method detail:timing:api-fetchPaymentInstrument": 2204,
  "web:cam:payment settings:edit payment method:timing:api-fetchPaymentMethods-cached": 2223,
  "web:cam:payment settings:add payment method:timing:api-fetchPaymentInstruments-cached": 2159,
  "web:cam:voucher redeem:update address:timing:api-fetchWallet": 2184,
  "web:cam:application:flowViewPanel:timing:overall": 5893,
  "web:cam:payment settings:paypal default method:timing:overall": 2186,
  "web:cam:add funds:thank you:3DS:timing:api-popup": 2198,
  "web:cam:payment settings:add funds:timing:api-fetchPaymentMethods-cached": 2170,
  "web:cam:application:firstViewInline:timing:overall": 5890
};

</script>

    <script>
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.GrandCentralCore = {})));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  /** @module Logger */
  var LEVEL = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    OFF: 4
  };
  /**
   * Wraps a console method, adding a logging level condition and a messaging prefix.
   *
   * @private
   * @param {Object} context    - a Logger instance
   * @param {string} methodName - the name of a console method to wrap
   * @param {number} level      - a LEVEL enum value to use as a guard
   * @param {string} prefix     - a prefix to attach to each log message
   * @returns {function}
   */

  function wrapConsoleMethod(context, methodName, level, prefix) {
    return function () {
      var _console;

      if (context._level > level) {
        return;
      } // eslint-disable-next-line no-console


      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console)[methodName].apply(_console, [prefix].concat(args));
    };
  }
  /**
   * Logging singleton for Grand Central.
   *
   * @example
   * // Clients may adjust GC's logging level, if desired.
   * Logger.setLevel(Logger.WARN);
   *
   * @prop {number} DEBUG - enum value to output all logs
   * @prop {number} INFO  - enum value to output all non-debug logs
   * @prop {number} WARN  - enum value to only output warning and error logs (default)
   * @prop {number} ERROR - enum value to only output error logs
   * @prop {number} OFF   - enum value to silence all logs
   */


  var Logger =
  /*#__PURE__*/
  function () {
    function Logger() {
      _classCallCheck(this, Logger);

      _extends(this, LEVEL); // default logging level


      this._level = LEVEL.WARN;
    }
    /**
     * Sets the logging level.
     * @param {number} level - DEBUG, INFO, WARN, ERROR, or OFF
     */


    _createClass(Logger, [{
      key: "setLevel",
      value: function setLevel(level) {
        this._level = level;
      }
      /**
       * Gets a named logger.
       * @param {string} [name] - a name to use as a prefix for logged messages
       */

    }, {
      key: "get",
      value: function get(name) {
        var prefix = name ? "[GC] [".concat(name, "]") : '[GC]';
        return {
          debug: wrapConsoleMethod(this, 'log', LEVEL.DEBUG, prefix),
          info: wrapConsoleMethod(this, 'info', LEVEL.INFO, prefix),
          warn: wrapConsoleMethod(this, 'warn', LEVEL.WARN, prefix),
          error: wrapConsoleMethod(this, 'error', LEVEL.ERROR, prefix)
        };
      }
    }]);

    return Logger;
  }();

  var Logger$1 = new Logger();

  var logger = Logger$1.get('ABSTRACT AUTH');
  /**
   * @typedef {Object} AccessTokenResult
   * @prop {string} token      - an OAuth access token
   * @prop {number} expiration - the token's expiration timestamp, pre-adjusted to be comparable with Date.now()
   */

  /**
   * @typedef {Object} AuthCodeResult
   * @prop {string} code        - an OAuth auth code
   * @prop {string} redirectUrl - a redirect URL from OAuth (used as the referrer URL for Kamaji Session calls)
   */

  /**
   * Abstract base class for OAuth access token and auth code management.
   * May be extended by clients who require a custom auth implementation.
   * @memberof module:Auth
   *
   * @example
   * class MyAuth extends AbstractAuth {
   *     _fetchAccessTokenHandler() { ... }
   *     _fetchAuthCodeHandler() { ... }
   * }
   *
   * const auth = new MyAuth(...);
   * // `auth` may then be used as a constructor parameter for certain GC services,
   * // which will use it to request a token or code as needed.
   */

  var AbstractAuth =
  /*#__PURE__*/
  function () {
    /**
     * @param {Object} options - implementation-specific options, accessible from each fetch handler
     */
    function AbstractAuth() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, AbstractAuth);

      _extends(this, {
        _options: options,
        // access token string
        _token: null,
        // access token expiration timestamp
        _tokenExpiration: 0,
        // null except while fetching an access token
        _tokenPromise: null
      });
    }
    /**
     * Specifies how an access token should be fetched.
     *
     * @abstract
     * @protected
     * @returns {Promise.<module:Auth~AccessTokenResult>} promise for access token & expiration timestamp
     */


    _createClass(AbstractAuth, [{
      key: "_fetchAccessTokenHandler",
      value: function _fetchAccessTokenHandler() {
        logger.warn('_fetchAccessTokenHandler is not implemented!');
        return Promise.reject();
      }
      /**
       * Specifies how an auth code should be fetched.
       *
       * @abstract
       * @protected
       * @returns {Promise.<module:Auth~AuthCodeResult>} promise for auth code & redirect URL
       */

    }, {
      key: "_fetchAuthCodeHandler",
      value: function _fetchAuthCodeHandler() {
        logger.warn('_fetchAuthCodeHandler is not implemented!');
        return Promise.reject();
      }
      /**
       * Clears any cached access token.
       */

    }, {
      key: "clearAccessToken",
      value: function clearAccessToken() {
        this._token = null;
        this._tokenExpiration = 0;
      }
      /**
       * Returns a cached, unexpired OAuth access token if available,
       * otherwise retrieves a new one and caches it along with its expiration timestamp.
       *
       * @returns {Promise.<string>} promise for access token
       */

    }, {
      key: "fetchAccessToken",
      value: function fetchAccessToken() {
        var _this = this;

        if (this._token) {
          var tokenIsUnexpired = this._tokenExpiration > Date.now();

          if (tokenIsUnexpired) {
            return Promise.resolve(this._token);
          }

          this.clearAccessToken();
        }

        if (this._tokenPromise) {
          return this._tokenPromise;
        }

        this._tokenPromise = this._fetchAccessTokenHandler().then(function (result) {
          _this._token = result.token;
          _this._tokenExpiration = result.expiration;
          _this._tokenPromise = null;
          return _this._token;
        }).catch(function (result) {
          _this._tokenPromise = null;
          throw result;
        });
        return this._tokenPromise;
      }
      /**
       * Retrieves a Versa auth code and redirection URL.
       * @returns {Promise.<module:Auth~AuthCodeResult>} promise for auth code & redirection URL
       */

    }, {
      key: "fetchAuthCode",
      value: function fetchAuthCode() {
        return this._fetchAuthCodeHandler();
      }
    }]);

    return AbstractAuth;
  }();

  /** @module Config */

  /**
   * Cross-service configuration singleton for Grand Central.
   *
   * @example
   * // Clients may need to specify configuration options before constructing certain service classes.
   * Config.extend(myConfigOptions);
   */
  var Config =
  /*#__PURE__*/
  function () {
    function Config() {
      _classCallCheck(this, Config);
    }

    _createClass(Config, [{
      key: "extend",

      /**
       * Extends the current configuration options (overwriting existing).
       * Ensures *Url keys have a trailing slash.
       * @param {Object} options - key-value pairs of config options
       */
      value: function extend() {
        var _this = this;

        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.keys(options).forEach(function (key) {
          _this[key] = key.slice(-3) === 'Url' ? options[key].replace(/\/?$/, '/') : options[key];
        });
      }
      /**
       * Clears all configuration options.
       */

    }, {
      key: "clear",
      value: function clear() {
        var _this2 = this;

        Object.keys(this).forEach(function (key) {
          delete _this2[key];
        });
      }
    }]);

    return Config;
  }();

  var Config$1 = new Config();

  /**
   * Internal module for (XHR-related) utilities.
   * @module Utilities
   */

  /**
   * Generates a query string from an object.
   *
   * As a matter of convenience, undefined/null/empty values are ignored.
   * By default, array values are transformed into repeated parameters and a leading question mark is inserted.
   *
   * @static
   * @param {Object}  obj                         - object of key-value pairs to stringify
   * @param {Object}  [options]
   * @param {boolean} [options.stringifyArrays]   - whether to stringify array values (instead of transforming them)
   * @param {boolean} [options.omitQuestionMark]  - whether to omit the leading question mark
   * @returns {string} the generated query string
   */
  function createQueryString() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$stringifyArrays = _ref.stringifyArrays,
        stringifyArrays = _ref$stringifyArrays === void 0 ? false : _ref$stringifyArrays,
        _ref$omitQuestionMark = _ref.omitQuestionMark,
        omitQuestionMark = _ref$omitQuestionMark === void 0 ? false : _ref$omitQuestionMark;

    var keys = Object.keys(obj).filter(function (key) {
      return obj[key] != null && obj[key] !== '';
    });

    if (!keys.length) {
      return '';
    }

    var queryString = keys.map(function (key) {
      var value = obj[key];
      var encodedKey = encodeURIComponent(key);
      var encodedValue = Array.isArray(value) && !stringifyArrays ? value.map(encodeURIComponent).join("&".concat(encodedKey, "=")) : encodeURIComponent(value);
      return "".concat(encodedKey, "=").concat(encodedValue);
    }).join('&');
    return (omitQuestionMark ? '' : '?') + queryString;
  }
  /**
   * Convenience method to generate a POST request body string
   * of content type 'application/x-www-form-urlencoded' from an object.
   *
   * @static
   * @param {Object}  obj                         - object of key-value pairs to stringify
   * @param {Object}  [options]
   * @param {boolean} [options.stringifyArrays]   - whether to stringify array values (instead of transforming them)
   * @returns {string} the generated POST request body string
   */


  function createPostBody(obj, options) {
    return createQueryString(obj, _objectSpread({}, options, {
      omitQuestionMark: true
    }));
  }
  /**
   * Produces an object of key-value pairs from a query string.
   *
   * Valueless keys are treated as boolean shorthand and
   * repeated parameters are transformed into array values.
   *
   * @static
   * @param {string} queryString - a query string to parse
   * @returns {Object} an object of key-value pairs
   */


  function parseQueryString() {
    var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var pairStrings = queryString.match(/^\??(.*)/)[1].split('&');
    var obj = {};
    pairStrings.forEach(function (pairString) {
      if (!pairString.length) {
        return;
      }

      var pair = pairString.split('=');
      var key = decodeURIComponent(pair[0]);
      var value = pair[1] !== undefined ? decodeURIComponent(pair[1]) : 'true';
      obj[key] = obj[key] === undefined ? value : Array.isArray(obj[key]) ? obj[key].concat(value) : [obj[key], value];
    });
    return obj;
  }
  /**
   * Generates a v4 (pseudo-random) UUID,
   * i.e., a 128-bit value stringified as `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx`,
   * where `x` is any hex digit and `y` is in the range `8`-`b`.
   *
   * @static
   * @returns {string} a newly-generated UUID
   */


  function generateUUID() {
    /* eslint-disable no-bitwise */
    var randomValues; // Avoid not-to-spec crypto which is missing getRandomValues.
    // (IE 11: Object doesn't support property or method 'getRandomValues')

    if (typeof crypto !== 'undefined' && crypto.getRandomValues && Uint16Array.prototype.reduce) {
      randomValues = crypto.getRandomValues(new Uint16Array(8));
    } // Avoid not-to-spec crypto.getRandomValues which returns undefined.
    // (Android Browser 4: Cannot call method 'reduce' of undefined)


    if (!randomValues) {
      randomValues = [0, 0, 0, 0, 0, 0, 0, 0].map(function () {
        return Math.random() * 0x10000;
      });
    }

    return randomValues.reduce(function (uuid, randomValue, index) {
      var hextet = index === 3 ? randomValue & 0x0fff | 0x4000 : index === 4 ? randomValue & 0x3fff | 0x8000 : randomValue;
      var appendHyphen = index >= 1 && index <= 4;
      return uuid + ('000' + hextet.toString(16)).slice(-4) + (appendHyphen ? '-' : '');
    }, '');
    /* eslint-enable no-bitwise */
  }
  /**
   * Convenience method which retrieves an access token, sets the Authorization header,
   * and then calls window.fetch.
   *
   * @static
   * @param {Object} auth    - an instance of an [AbstractAuth]{@link module:Auth.AbstractAuth} implementation
   * @param {string} url     - [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch}'s first argument
   * @param {Object} options - [fetch]{@link https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch}'s second argument
   * @returns {Promise.<Response>} promise for fetch [Response]{@link https://developer.mozilla.org/en-US/docs/Web/API/Response}
   */


  function fetchWithAccessToken(auth, url) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return auth.fetchAccessToken().then(function (token) {
      var headers = _objectSpread({}, options.headers, {
        Authorization: "Bearer ".concat(token)
      });

      return fetch(url, _objectSpread({}, options, {
        headers: headers
      }));
    });
  }

  var logger$1 = Logger$1.get('DEV AUTH');
  /**
   * Data for [oauth/token]{@link https://github.sie.sony.com/pages/SIE/korra-docs/#e1/api/authservice/2.0/oauth/token@grant_type=password/post} POST body.
   * @typedef {Object} DevAuthOptions
   * @memberof module:Auth
   * @prop {string} clientId     - OAuth client ID
   * @prop {string} clientSecret - OAuth client secret
   * @prop {string[]} scopes     - list of scopes for the access token
   */

  /**
   * Auth implementation for development use (e.g., "console-in-browser").
   * Supports access tokens only.
   * @memberof module:Auth
   * @extends module:Auth.AbstractAuth
   *
   * @example
   * Config.extend({
   *     npEnvironment: 'e1-np',
   *     psnUsername,
   *     psnPassword
   * });
   *
   * const auth = new DevAuth({
   *     clientId: 'my-client-id',
   *     clientSecret: 'my-client-secret',
   *     scopes: ['my-scope1', 'my-scope2']
   * });
   */

  var DevAuth =
  /*#__PURE__*/
  function (_AbstractAuth) {
    _inherits(DevAuth, _AbstractAuth);

    /**
     * @param {module:Auth.DevAuthOptions} options
     */
    function DevAuth() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, DevAuth);

      if (!options.clientId || !options.clientSecret || !options.scopes) {
        throw new Error('DevAuth must be constructed with clientId, clientSecret, and scopes!');
      }

      return _possibleConstructorReturn(this, _getPrototypeOf(DevAuth).call(this, options));
    }
    /**
     * Calls OAuth token API for an access token.
     * @private
     * @returns {Promise.<module:Auth~AccessTokenResult>} promise for access token & expiration timestamp
     */


    _createClass(DevAuth, [{
      key: "_fetchAccessTokenHandler",
      value: function _fetchAccessTokenHandler() {
        if (!Config$1.npEnvironment || !Config$1.psnUsername || !Config$1.psnPassword) {
          logger$1.warn('Token fetcher expected config fields "npEnvironment", "psnUsername", and "psnPassword"!');
        }

        var url = "https://auth.api.".concat(Config$1.npEnvironment, ".ac.playstation.net/2.0/oauth/token");
        var headers = {
          'Content-Type': 'application/x-www-form-urlencoded'
        };
        var body = createPostBody({
          grant_type: 'password',
          client_id: this._options.clientId,
          client_secret: this._options.clientSecret,
          scope: this._options.scopes,
          username: Config$1.psnUsername,
          password: Config$1.psnPassword
        }, {
          stringifyArrays: true
        });
        return fetch(url, {
          method: 'POST',
          headers: headers,
          body: body
        }).then(function (response) {
          return response.json();
        }).then(function (token) {
          if (!token || typeof token.access_token !== 'string' || token.access_token === '') {
            throw new Error('Access Token request failed.');
          }

          return {
            token: token.access_token,
            expiration: Date.now() + token.expires_in * 1000
          };
        });
      }
      /**
       * @method module:Auth.DevAuth#_fetchAuthCodeHandler
       * @ignore
       */

      /**
       * @method module:Auth.DevAuth#fetchAuthCode
       * @ignore
       */

    }]);

    return DevAuth;
  }(AbstractAuth);

  /**
   * PS4 auth implementation.
   * Supports access tokens only.
   * @memberof module:Auth
   * @extends module:Auth.AbstractAuth
   *
   * @example
   * const auth = new PS4Auth();
   */

  var PS4Auth =
  /*#__PURE__*/
  function (_AbstractAuth) {
    _inherits(PS4Auth, _AbstractAuth);

    function PS4Auth() {
      _classCallCheck(this, PS4Auth);

      return _possibleConstructorReturn(this, _getPrototypeOf(PS4Auth).apply(this, arguments));
    }

    _createClass(PS4Auth, [{
      key: "_fetchAccessTokenHandler",

      /**
       * Calls through VSH for an access token.
       * @private
       * @returns {Promise.<module:Auth~AccessTokenResult>} promise for access token & expiration timestamp
       */
      value: function _fetchAccessTokenHandler() {
        return new Promise(function (resolve, reject) {
          sce.getAccessToken(resolve);
        }).then(function (token) {
          if (!token || typeof token.access_token !== 'string' || token.access_token === '') {
            throw new Error('Access Token request failed.');
          }

          return {
            token: token.access_token,
            expiration: token.expiration_time
          };
        });
      }
      /**
       * @method module:Auth.PS4Auth#_fetchAuthCodeHandler
       * @ignore
       */

      /**
       * @method module:Auth.PS4Auth#fetchAuthCode
       * @ignore
       */

    }]);

    return PS4Auth;
  }(AbstractAuth);

  var DEFAULT_TIMEOUT = 20000;
  /**
   * @typedef {Object} WebIframeAuthFetchOptions
   * @memberof module:Auth
   * @prop {string} clientId - Application's OAuth client ID
   * @prop {string[]} scopes - Array of scopes for the application
   */

  /**
   * @typedef {Object} WebIframeAuthOptions
   * @memberof module:Auth
   * @prop {string} authorizationUri - OAuth endpoint URL
   * @prop {string} redirectUri - URL for webIFrameRedirect.html
   * @prop {module:Auth.WebIframeAuthFetchOptions} [accessToken] - Options for fetching an access token
   * @prop {module:Auth.WebIframeAuthFetchOptions} [authCode] - Options for fetching an auth code
   * @prop {string} [serviceEntity] - Either `urn:service-entity:psn` for full accounts or `urn:service-entity:np` for lightweight accounts
   * @prop {string} [duid] - Provide if your client needs to pass its duid along for authorization
   * @prop {string} [requestId] - Provide if your client needs strict control over the requestId appended to the loginRedirectUri
   * @prop {string} [loginRedirectUri] - Return URL after successful authentication. Used when building the login form URL
   * @prop {Object} [loginFormParamers] - Any additional parameters to include when generating the login form URL
   */

  function addQueryParams(url, params) {
    var baseUrl = url.split('#');
    baseUrl[0] += (baseUrl[0].indexOf('?') === -1 ? '?' : '&') + createQueryString(params, {
      omitQuestionMark: true
    });
    return baseUrl.join('#');
  }

  function buildOAuthParameters(uri, requestType, options) {
    var RESPONSE_TYPE = {
      accessToken: 'token',
      authCode: 'code'
    };
    return {
      response_type: RESPONSE_TYPE[requestType],
      prompt: 'none',
      client_id: options[requestType].clientId,
      scope: options[requestType].scopes.join(','),
      service_entity: options.serviceEntity,
      duid: options.duid,
      redirect_uri: uri,
      ui: options[requestType].ui
    };
  }

  function buildLoginUri(requestType, options) {
    var oauthParameters = buildOAuthParameters(options.loginRedirectUri, requestType, options);

    var loginParameters = _objectSpread({}, oauthParameters, {
      prompt: 'login'
    }, options.loginFormParameters);

    return addQueryParams(options.authorizationUri, loginParameters);
  }

  function fetchOAuthViaIframe(requestType, options) {
    // append our hidden iframe for communication
    var iframeElement = document.createElement('iframe');
    iframeElement.setAttribute('style', 'display: none'); // This is required to bust the iframe cache in the case where
    // the user navigates to a different site and then hits the 'back' button
    // @see http://stackoverflow.com/questions/2648053/preventing-iframe-caching-in-browser

    iframeElement.setAttribute('name', Date.now());
    document.body.appendChild(iframeElement);
    return new Promise(function (resolve, reject) {
      var requestId = options.requestId || generateUUID();
      var redirectUriWithParams = addQueryParams(options.redirectUri, {
        requestId: requestId
      });
      var timeoutHandle = null;
      var origin = (window.location.href.match(/https?:\/\/[\w.:-]+/) || [])[0];

      var callback = function callback(evt) {
        // check that the message is coming from the iframe
        if (evt.origin !== origin) {
          return;
        }

        var payload = evt && evt.data; // make sure we're answering to the correct callback.

        if (_typeof(payload) !== 'object' || payload.requestId !== requestId) {
          return;
        } // clean up our event handlers and timeout


        window.removeEventListener('message', callback);
        clearTimeout(timeoutHandle);
        timeoutHandle = null; // remove the hidden iframe now that we're done with it

        iframeElement.parentNode.removeChild(iframeElement);
        iframeElement = null;
        payload.redirect_uri = redirectUriWithParams;

        if (payload.error) {
          reject(payload);
        } else {
          resolve(payload);
        }
      }; // if we don't get a response in time, we'll return a timeout error


      timeoutHandle = setTimeout(function () {
        // we'll use our same callback hook to emulate a response so all of our standard cleanup logic is triggered
        callback({
          origin: origin,
          data: {
            error: 'timeout',
            requestId: requestId
          }
        });
      }, options.timeout || DEFAULT_TIMEOUT);
      window.addEventListener('message', callback);
      var oauthParameters = buildOAuthParameters(redirectUriWithParams, requestType, options);
      iframeElement.setAttribute('src', addQueryParams(options.authorizationUri, oauthParameters));
    });
  }
  /**
   * Web OAuth via iFrames auth implementation.
   * @memberof module:Auth
   * @extends module:Auth.AbstractAuth
   *
   * @description
   * Generates a hidden iFrame that requests an auth code or access token via the provided OAuth URL.
   * Returns with the code/token or rejects with any errors and the appropriate login URL
   * so the client application can determine if/how to redirect the user to log in.
   *
   * IMPORTANT: You will need to deploy webIframeRedirect.html somewhere with your application;
   * it is included in Grand Central's build. It must be hosted on the same domain as the client
   * to facilitate cross-frame communication.
   *
   * @example
   * const auth = new WebIframeAuth({
   *   authCode: {
   *     clientId: 'my-app-auth-code-client-id',
   *     scopes: ['my.app.auth.code.scope1', 'my.app.auth.code.scope2']
   *   },
   *   accessToken: {
   *     clientId: 'my-app-access-token-client-id',
   *     scopes: ['my.app.access.token.scope1', 'my.app.access.token.scope2']
   *   },
   *   authorizationUri: 'https://path.to/oauth/endpoint',
   *   redirectUri: 'https://path.to/my-app/webIframeRedirect.html',
   *   loginRedirectUri: window.location.href, // or whatever path in your application users should return to after logging in
   *   loginFormParameters: { // any parameters for the login URL that gets built for you
   *     ui: 'pr',
   *     hidePageElements: 'SENLogo'
   *   }
   * });
   *
   * auth.fetchAuthCode()
   *   .then(response => {
   *     // do something with response.authCode
   *   })
   *   .catch(ex => {
   *     // determine if ex requires sign in for your client app
   *     window.location.href = ex.loginUri;
   *   });
   *
   * auth.fetchAccessToken()
   *   .then(response => {
   *     // do something with response.token
   *   })
   *   .catch(ex => {
   *     // determine if ex requires sign in for your client app
   *     window.location.href = ex.loginUri;
   *   });
   *
   * @param {module:Auth.WebIframeAuthOptions} options - OAuth options to be passed to each fetch handler
   */


  var WebIframeAuth =
  /*#__PURE__*/
  function (_AbstractAuth) {
    _inherits(WebIframeAuth, _AbstractAuth);

    /**
     * @param {module:Auth.WebIframeAuthOptions} options - OAuth options
     */
    function WebIframeAuth() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, WebIframeAuth);

      if (!options.authCode || !options.authCode.clientId || !options.authCode.scopes) {
        throw new Error('WebIframeAuth must be constructed with clientId and scopes for auth code!');
      }

      if (!options.accessToken || !options.accessToken.clientId || !options.accessToken.scopes) {
        throw new Error('WebIframeAuth must be constructed with clientId and scopes for access token!');
      }

      if (!options.authorizationUri || !options.redirectUri) {
        throw new Error('WebIframeAuth must be constructed with authorizationUri and redirectUri!');
      }

      return _possibleConstructorReturn(this, _getPrototypeOf(WebIframeAuth).call(this, options));
    }
    /**
     * Retrieves an auth code from OAuth via a hidden iFrame.
     * @private
     * @returns {Promise.<module:Auth~AuthCodeResult>} promise for auth code & redirect URL
     */


    _createClass(WebIframeAuth, [{
      key: "_fetchAuthCodeHandler",
      value: function _fetchAuthCodeHandler() {
        var _this = this;

        return fetchOAuthViaIframe('authCode', this._options).then(function (response) {
          return {
            code: response.code,
            redirectUrl: response.redirect_uri
          };
        }).catch(function (ex) {
          if (_this._options.loginRedirectUri) {
            ex.loginUri = buildLoginUri('authCode', _this._options);
          }

          throw ex;
        });
      }
      /**
       * Retrieves an access token from OAuth via a hidden iFrame.
       * @private
       * @returns {Promise.<module:Auth~AccessTokenResult>} promise for access token & expiration timestamp
       */

    }, {
      key: "_fetchAccessTokenHandler",
      value: function _fetchAccessTokenHandler() {
        var _this2 = this;

        return fetchOAuthViaIframe('accessToken', this._options).then(function (response) {
          return {
            token: response.access_token,
            expiration: Date.now() + response.expires_in * 1000
          };
        }).catch(function (ex) {
          if (_this2._options.loginRedirectUri) {
            ex.loginUri = buildLoginUri('accessToken', _this2._options);
          }

          throw ex;
        });
      }
    }]);

    return WebIframeAuth;
  }(AbstractAuth);

  /**
   * Internal module for type-checking.
   * @module TypeCheck
   */

  /**
   * Checks whether a value is valid, according to some predicate.
   * Returns silently if valid, otherwise throws a TypeError.
   *
   * @static
   * @param {*}        subject   - a value to validate
   * @param {function} predicate - a boolean-valued validator function
   * @param {string}   name      - a display name for the value being validated
   * @throws {TypeError}
   */
  function assert(subject, predicate, name) {
    if (!predicate(subject)) {
      throw new TypeError("".concat(name, " has invalid value: ").concat(JSON.stringify(subject)));
    }
  }
  /**
   * Validates an optional value.
   * Returns silently if value is undefined, otherwise delegates to `assert`.
   *
   * @static
   * @param {*}        subject   - a value to validate
   * @param {function} predicate - a boolean-valued validator function
   * @param {string}   name      - a display name for the value being validated
   * @throws {TypeError}
   */


  function assertOptional(subject, predicate, name) {
    if (typeof subject !== 'undefined') {
      assert(subject, predicate, name);
    }
  }
  /**
   * Checks whether a value belongs to an enum.
   * (Performance-oriented implementation inspired by _.values.)
   *
   * Intended for creating assertion predicates, thus parameters are right-curried.
   *
   * @static
   * @param {Object} obj - an enum
   * @returns {function} a membership-checking predicate
   */


  function isMemberOf() {
    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var keys = Object.keys(obj);
    return function (value) {
      for (var i = 0; i < keys.length; i++) {
        if (value === obj[keys[i]]) return true;
      }

      return false;
    };
  }
  /**
   * Checks whether the input is an instance of a given class.
   * (A flexible variant of `instanceof` that works across contexts.)
   *
   * Intended for creating assertion predicates, thus parameters are right-curried.
   *
   * @static
   * @param {Object} constructor - a class constructor
   * @returns {function} an instance-checking predicate
   */


  function isInstanceOf(constructor) {
    return function (obj) {
      return obj != null && obj.constructor.name === constructor.name;
    };
  }
  /**
   * Checks whether the input is an array of instances of a given class.
   * (The array version of [isInstanceOf]{@link module:TypeCheck~isInstanceOf}.)
   *
   * Intended for creating assertion predicates, thus parameters are right-curried.
   *
   * @static
   * @param {Object} constructor - a class constructor
   * @returns {function} an "array of instances"-checking predicate
   */


  function isArrayOf(constructor) {
    return function (objs) {
      return Array.isArray(objs) && objs.every(isInstanceOf(constructor));
    };
  }

  /**
   * Main module for Grand Central Core.
   * @module Core
   *
   * @prop {function} AbstractAuth            - [AbstractAuth]{@link module:Auth.AbstractAuth} class
   * @prop {function} DevAuth                 - [DevAuth]{@link module:Auth.DevAuth} constructor
   * @prop {function} PS4Auth                 - [PS4Auth]{@link module:Auth.PS4Auth} constructor
   * @prop {function} WebIframeAuth           - [WebIframeAuth]{@link module:Auth.WebIframeAuth} constructor
   * @prop {Object}   Config                  - [Config]{@link module:Config~Config} singleton instance (to allow clients to set cross-service configuration options)
   * @prop {Object}   Logger                  - [Logger]{@link module:Logger~Logger} singleton instance (to allow clients to adjust GC's logging level)
   * @prop {function} assert                  - [TypeCheck.assert]{@link module:TypeCheck.assert}
   * @prop {function} assertOptional          - [TypeCheck.assertOptional]{@link module:TypeCheck.assertOptional}
   * @prop {function} isArrayOf               - [TypeCheck.isArrayOf]{@link module:TypeCheck.isArrayOf}
   * @prop {function} isInstanceOf            - [TypeCheck.isInstanceOf]{@link module:TypeCheck.isInstanceOf}
   * @prop {function} isMemberOf              - [TypeCheck.isMemberOf]{@link module:TypeCheck.isMemberOf}
   * @prop {function} createPostBody          - [Utilities.createPostBody]{@link module:Utilities.createPostBody}
   * @prop {function} createQueryString       - [Utilities.createQueryString]{@link module:Utilities.createQueryString}
   * @prop {function} fetchWithAccessToken    - [Utilities.fetchWithAccessToken]{@link module:Utilities.fetchWithAccessToken}
   * @prop {function} generateUUID            - [Utilities.generateUUID]{@link module:Utilities.generateUUID}
   * @prop {function} parseQueryString        - [Utilities.parseQueryString]{@link module:Utilities.parseQueryString}
   */

  exports.AbstractAuth = AbstractAuth;
  exports.DevAuth = DevAuth;
  exports.PS4Auth = PS4Auth;
  exports.WebIframeAuth = WebIframeAuth;
  exports.Config = Config$1;
  exports.Logger = Logger$1;
  exports.assert = assert;
  exports.assertOptional = assertOptional;
  exports.isArrayOf = isArrayOf;
  exports.isInstanceOf = isInstanceOf;
  exports.isMemberOf = isMemberOf;
  exports.createPostBody = createPostBody;
  exports.createQueryString = createQueryString;
  exports.fetchWithAccessToken = fetchWithAccessToken;
  exports.generateUUID = generateUUID;
  exports.parseQueryString = parseQueryString;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

</script>
    <script>
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@sie/grand-central-core')) :
	typeof define === 'function' && define.amd ? define(['@sie/grand-central-core'], factory) :
	(global.ClientConfigService = factory(global.GrandCentralCore));
}(this, (function (_sie_grandCentralCore) { 'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

/** @module ClientConfig */
var logger = _sie_grandCentralCore.Logger.get('CLIENT CONFIG');

// JSDoc definitions

/**
 * Criteria which must all be true if the parent config object is to be applied.
 * @typedef {Object} ConfigCriteria
 * @prop {*} ConfigCriteria.myCriteriaType - The value of this field will be passed to the criteria verifier
 *                                           as "myCriteriaType". Add as many criteria in this way as you'd like.
 *                                           Values should be safe for JSON--i.e., no functions, Dates or RegExps.
 */

/**
 * @typedef {Object} ConfigObject
 * @prop {*}                    ConfigObject.mySetting   - An client-specific setting. Add as many as you'd like; name
 *                                                         them anything but "criteria" or "overrides". Values should
 *                                                         be safe for JSON--i.e., no functions, Dates, or RegExps.
 * @prop {ConfigCriteria}       [ConfigObject.criteria]
 * @prop {Array.<ConfigObject>} [ConfigObject.overrides]
 */

/**
 * @callback criteriaVerifier
 * @param {*} criterion - The value specified in the criteria object.
 * @returns {boolean}
 */

// Helper functions

function _isObject(value) {
    return !!value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';
}

function _isPureObject(value) {
    return _isObject(value) && Object.prototype.toString.call(value) === '[object Object]';
}

/**
 * Merges keys of source into target, following a few special rules:
 * - Distinguished keys "criteria" and "overrides" are never copied.
 * - Non-array objects are recursively merged. All other types are overwritten.
 * @private
 */
function _deepMerge(target, source) {
    Object.keys(source).forEach(function (key) {
        // Distinguished keys are ignored.
        if (key === 'criteria' || key === 'overrides') {
            return;
        }

        // Arrays and other special objects are wholly replaced.
        if (!_isPureObject(source[key])) {
            target[key] = source[key];
            return;
        }

        // Only simple objects are recursively merged.
        if (!_isPureObject(target[key])) {
            if (target[key] != null) {
                logger.warn('Attempted to override non-Object target with Object source.', 'Destination will be replaced by source.');
            }
            target[key] = {};
        }
        _deepMerge(target[key], source[key]);
    });
}

/**
 * Service for computing configuration settings based on run-time criteria.
 *
 * @example
 * import ClientConfigService from '@sie/grand-central-client-config';
 *
 * const clientConfig = new ClientConfigService();
 *
 * // Teach the service how to recognize locale criteria.
 * clientConfig.addCriteriaVerifier('locale', pattern => clientConfig.matchesRegExp(pattern, currentLocale));
 *
 * // Give the service the settings we've pulled down from our server.
 * // Keeping these settings separate allows a client to change them without redeploying.
 * clientConfig.addSettings(settingsFromServer);
 *
 * // Feel free to add override mechanisms to help with development and QA.
 * if (notRunningInProduction) {
 *     clientConfig.addSettings(overridesFromQueryParam);
 * }
 *
 * // ...
 *
 * // Use the settings.
 * function makeRequest(id) {
 *     const settings = clientConfig.computeSettings();
 *
 *     // An example of data-based configuration.
 *     const url = settings.someServiceBaseURL + 'thing/' + id;
 *
 *     // An example of guard-based configuration.
 *     if (settings.features.trackRequests) {
 *         trackerService.track(url);
 *     }
 *
 *     return new XHRPromise('GET', url);
 * }
 */

var ClientConfig = function () {
    function ClientConfig() {
        classCallCheck(this, ClientConfig);

        // Registry of functions used to see if overrides qualify based on some criteria.
        // Key: The type of criterion this guy can verify, e.g. 'locale'.
        // Value: criterionValue => isQualified(criterionValue)
        this._criteriaVerifiers = {};

        // Source object for settings. Includes overrides.
        this._rawSettings = {};
    }

    /**
     * Process a raw settings object (which may or may not include an "overrides" key).
     * @private
     * @returns {Object} the settings which remain after applying all overrides
     */


    ClientConfig.prototype._applyOverride = function _applyOverride(raw) {
        // Step 1: If any of this override's criteria do not match, immediately return an empty object.
        //         (Of course, an override with no criteria will always be applied.)
        if (raw.criteria) {
            var keys = Object.keys(raw.criteria);
            for (var i = 0; i < keys.length; i++) {
                var verifier = this._criteriaVerifiers[keys[i]];
                var criterion = raw.criteria[keys[i]];

                var qualified = typeof verifier === 'function' && verifier(criterion);
                if (!qualified) {
                    return {};
                }
            }
        }

        var settings = {};

        // Step 2: Apply override settings (ignoring "criteria" and "overrides" keys).
        _deepMerge(settings, raw);

        // Step 3: Recursively apply child overrides.
        //         This ordering means that a sub-tree overrides its parent and its previous siblings.
        if (raw.overrides) {
            for (var _i = 0; _i < raw.overrides.length; _i++) {
                _deepMerge(settings, this._applyOverride(raw.overrides[_i]));
            }
        }

        return settings;
    };

    /**
     * @returns {Object} the settings that the app should use
     */


    ClientConfig.prototype.computeSettings = function computeSettings() {
        return this._applyOverride(this._rawSettings);
    };

    /**
     * Adds another batch of settings and overrides for consideration.
     * New settings are appended, so as to have priority over existing settings.
     * Settings are computed lazily, so call this as often as you'd like.
     *
     * @param {(ConfigObject|Array.<ConfigObject>)} obj - the raw settings to add
     *                                                    (if array, converted to { overrides: obj })
     *
     * @example
     * clientConfig.addSettings({
     *     // App settings to apply.
     *     someSetting1: true,
     *     someSetting2: 17,
     *     someSetting3: {
     *         childSetting: 'Values can be whatever JSON type you would like'
     *     },
     *
     *     // Optional block of qualifications in order for the above settings to be applied.
     *     // Each criteria type must first be registered using addCriteriaVerifier.
     *     criteria: {
     *         line: 'e1-np',
     *         locale: '^en-.*',
     *         someOtherCriteriaType: {
     *             thing: 'something',
     *             greaterThan: 99
     *         }
     *     },
     *
     *     // Optional list of ConfigObjects to be applied recursively if the criteria were met.
     *     // In this tree, children override parents and siblings override previous siblings.
     *     overrides: [{
     *         someSetting2: false,
     *         criteria: { locale: 'en-CA' }
     *     }]
     * });
     */


    ClientConfig.prototype.addSettings = function addSettings(obj) {
        if (!_isObject(obj) || Array.isArray(obj) && !obj.every(_isObject)) {
            logger.warn('addSettings expected an object or array of objects but received:', obj);
            return;
        }

        this._rawSettings.overrides = (this._rawSettings.overrides || []).concat(obj);
    };

    /**
     * Wipes out all data from previous calls to addSettings.
     */


    ClientConfig.prototype.clearSettings = function clearSettings() {
        this._rawSettings = {};
    };

    /**
     * Teaches the config service to recognize a new type of criteria.
     * You must register a criteria verifier before that criteria type can be used in a criteria object.
     *
     * You should document the criteria verifiers available and each verifier's criteriaValue schema,
     * so that authors of settings files know what they have to work with.
     *
     * @param {string}           criteriaType
     * @param {criteriaVerifier} verifier
     */


    ClientConfig.prototype.addCriteriaVerifier = function addCriteriaVerifier(criteriaType, verifier) {
        this._criteriaVerifiers[criteriaType] = verifier;
    };

    /**
     * Wipes out all data from previous calls to addCriteriaVerifier.
     */


    ClientConfig.prototype.clearCriteriaVerifiers = function clearCriteriaVerifiers() {
        this._criteriaVerifiers = {};
    };

    /**
     * Helper function for use in criteria verifiers,
     * to ensure case insensitivity and avoid partial matches (recommended).
     *
     * @param {string} pattern - RegExp string loaded from the config setting (e.g., 'en-.*')
     * @param {string} value   - actual value to match against config setting (e.g., localeService.currentLocale)
     * @returns {boolean}
     */


    ClientConfig.prototype.matchesRegExp = function matchesRegExp(pattern, value) {
        return new RegExp('^' + pattern + '$', 'i').test(value);
    };

    return ClientConfig;
}();

return ClientConfig;

})));

</script>

    <script>
/*
 Start ActivityMap Module

 The following module enables ActivityMap tracking in Adobe Analytics. ActivityMap
 allows you to view data overlays on your links and content to understand how
 users engage with your web site. If you do not intend to use ActivityMap, you
 can remove the following block of code from your AppMeasurement.js file.
 Additional documentation on how to configure ActivityMap is available at:
 https://marketing.adobe.com/resources/help/en_US/analytics/activitymap/getting-started-admins.html
*/
function AppMeasurement_Module_ActivityMap(f){function g(a,d){var b,c,n;if(a&&d&&(b=e.c[d]||(e.c[d]=d.split(","))))for(n=0;n<b.length&&(c=b[n++]);)if(-1<a.indexOf(c))return null;p=1;return a}function q(a,d,b,c,e){var g,h;if(a.dataset&&(h=a.dataset[d]))g=h;else if(a.getAttribute)if(h=a.getAttribute("data-"+b))g=h;else if(h=a.getAttribute(b))g=h;if(!g&&f.useForcedLinkTracking&&e&&(g="",d=a.onclick?""+a.onclick:"")){b=d.indexOf(c);var l,k;if(0<=b){for(b+=10;b<d.length&&0<="= \t\r\n".indexOf(d.charAt(b));)b++;
if(b<d.length){h=b;for(l=k=0;h<d.length&&(";"!=d.charAt(h)||l);)l?d.charAt(h)!=l||k?k="\\"==d.charAt(h)?!k:0:l=0:(l=d.charAt(h),'"'!=l&&"'"!=l&&(l=0)),h++;if(d=d.substring(b,h))a.e=new Function("s","var e;try{s.w."+c+"="+d+"}catch(e){}"),a.e(f)}}}return g||e&&f.w[c]}function r(a,d,b){var c;return(c=e[d](a,b))&&(p?(p=0,c):g(k(c),e[d+"Exclusions"]))}function s(a,d,b){var c;if(a&&!(1===(c=a.nodeType)&&(c=a.nodeName)&&(c=c.toUpperCase())&&t[c])&&(1===a.nodeType&&(c=a.nodeValue)&&(d[d.length]=c),b.a||
b.t||b.s||!a.getAttribute||((c=a.getAttribute("alt"))?b.a=c:(c=a.getAttribute("title"))?b.t=c:"IMG"==(""+a.nodeName).toUpperCase()&&(c=a.getAttribute("src")||a.src)&&(b.s=c)),(c=a.childNodes)&&c.length))for(a=0;a<c.length;a++)s(c[a],d,b)}function k(a){if(null==a||void 0==a)return a;try{return a.replace(RegExp("^[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]+","mg"),"").replace(RegExp("[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]+$",
"mg"),"").replace(RegExp("[\\s\\n\\f\\r\\t\t-\r \u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u205f\u3000\ufeff]{1,}","mg")," ").substring(0,254)}catch(d){}}var e=this;e.s=f;var m=window;m.s_c_in||(m.s_c_il=[],m.s_c_in=0);e._il=m.s_c_il;e._in=m.s_c_in;e._il[e._in]=e;m.s_c_in++;e._c="s_m";e.c={};var p=0,t={SCRIPT:1,STYLE:1,LINK:1,CANVAS:1};e._g=function(){var a,d,b,c=f.contextData,e=f.linkObject;(a=f.pageName||f.pageURL)&&(d=r(e,"link",f.linkName))&&(b=r(e,"region"))&&(c["a.activitymap.page"]=a.substring(0,
255),c["a.activitymap.link"]=128<d.length?d.substring(0,128):d,c["a.activitymap.region"]=127<b.length?b.substring(0,127):b,c["a.activitymap.pageIDType"]=f.pageName?1:0)};e.link=function(a,d){var b;if(d)b=g(k(d),e.linkExclusions);else if((b=a)&&!(b=q(a,"sObjectId","s-object-id","s_objectID",1))){var c,f;(f=g(k(a.innerText||a.textContent),e.linkExclusions))||(s(a,c=[],b={a:void 0,t:void 0,s:void 0}),(f=g(k(c.join(""))))||(f=g(k(b.a?b.a:b.t?b.t:b.s?b.s:void 0)))||!(c=(c=a.tagName)&&c.toUpperCase?c.toUpperCase():
"")||("INPUT"==c||"SUBMIT"==c&&a.value?f=g(k(a.value)):"IMAGE"==c&&a.src&&(f=g(k(a.src)))));b=f}return b};e.region=function(a){for(var d,b=e.regionIDAttribute||"id";a&&(a=a.parentNode);){if(d=q(a,b,b,b))return d;if("BODY"==a.nodeName)return"BODY"}}}
/* End ActivityMap Module */
/*
 ============== DO NOT ALTER ANYTHING BELOW THIS LINE ! ===============

AppMeasurement for JavaScript version: 1.8.0
Copyright 1996-2016 Adobe, Inc. All Rights Reserved
More info available at http://www.adobe.com/marketing-cloud.html
*/
function AppMeasurement(){var a=this;a.version="1.8.0";var h=window;h.s_c_in||(h.s_c_il=[],h.s_c_in=0);a._il=h.s_c_il;a._in=h.s_c_in;a._il[a._in]=a;h.s_c_in++;a._c="s_c";var n=h.AppMeasurement.Ob;n||(n=null);var p=h,l,r;try{for(l=p.parent,r=p.location;l&&l.location&&r&&""+l.location!=""+r&&p.location&&""+l.location!=""+p.location&&l.location.host==r.host;)p=l,l=p.parent}catch(s){}a.P=function(a){try{console.log(a)}catch(b){}};a.La=function(a){return""+parseInt(a)==""+a};a.replace=function(a,b,d){return!a||
0>a.indexOf(b)?a:a.split(b).join(d)};a.escape=function(c){var b,d;if(!c)return c;c=encodeURIComponent(c);for(b=0;7>b;b++)d="+~!*()'".substring(b,b+1),0<=c.indexOf(d)&&(c=a.replace(c,d,"%"+d.charCodeAt(0).toString(16).toUpperCase()));return c};a.unescape=function(c){if(!c)return c;c=0<=c.indexOf("+")?a.replace(c,"+"," "):c;try{return decodeURIComponent(c)}catch(b){}return unescape(c)};a.vb=function(){var c=h.location.hostname,b=a.fpCookieDomainPeriods,d;b||(b=a.cookieDomainPeriods);if(c&&!a.cookieDomain&&
!/^[0-9.]+$/.test(c)&&(b=b?parseInt(b):2,b=2<b?b:2,d=c.lastIndexOf("."),0<=d)){for(;0<=d&&1<b;)d=c.lastIndexOf(".",d-1),b--;a.cookieDomain=0<d?c.substring(d):c}return a.cookieDomain};a.c_r=a.cookieRead=function(c){c=a.escape(c);var b=" "+a.d.cookie,d=b.indexOf(" "+c+"="),f=0>d?d:b.indexOf(";",d);c=0>d?"":a.unescape(b.substring(d+2+c.length,0>f?b.length:f));return"[[B]]"!=c?c:""};a.c_w=a.cookieWrite=function(c,b,d){var f=a.vb(),e=a.cookieLifetime,g;b=""+b;e=e?(""+e).toUpperCase():"";d&&"SESSION"!=
e&&"NONE"!=e&&((g=""!=b?parseInt(e?e:0):-60)?(d=new Date,d.setTime(d.getTime()+1E3*g)):1==d&&(d=new Date,g=d.getYear(),d.setYear(g+5+(1900>g?1900:0))));return c&&"NONE"!=e?(a.d.cookie=a.escape(c)+"="+a.escape(""!=b?b:"[[B]]")+"; path=/;"+(d&&"SESSION"!=e?" expires="+d.toGMTString()+";":"")+(f?" domain="+f+";":""),a.cookieRead(c)==b):0};a.K=[];a.ia=function(c,b,d){if(a.Ea)return 0;a.maxDelay||(a.maxDelay=250);var f=0,e=(new Date).getTime()+a.maxDelay,g=a.d.visibilityState,k=["webkitvisibilitychange",
"visibilitychange"];g||(g=a.d.webkitVisibilityState);if(g&&"prerender"==g){if(!a.ja)for(a.ja=1,d=0;d<k.length;d++)a.d.addEventListener(k[d],function(){var c=a.d.visibilityState;c||(c=a.d.webkitVisibilityState);"visible"==c&&(a.ja=0,a.delayReady())});f=1;e=0}else d||a.p("_d")&&(f=1);f&&(a.K.push({m:c,a:b,t:e}),a.ja||setTimeout(a.delayReady,a.maxDelay));return f};a.delayReady=function(){var c=(new Date).getTime(),b=0,d;for(a.p("_d")?b=1:a.xa();0<a.K.length;){d=a.K.shift();if(b&&!d.t&&d.t>c){a.K.unshift(d);
setTimeout(a.delayReady,parseInt(a.maxDelay/2));break}a.Ea=1;a[d.m].apply(a,d.a);a.Ea=0}};a.setAccount=a.sa=function(c){var b,d;if(!a.ia("setAccount",arguments))if(a.account=c,a.allAccounts)for(b=a.allAccounts.concat(c.split(",")),a.allAccounts=[],b.sort(),d=0;d<b.length;d++)0!=d&&b[d-1]==b[d]||a.allAccounts.push(b[d]);else a.allAccounts=c.split(",")};a.foreachVar=function(c,b){var d,f,e,g,k="";e=f="";if(a.lightProfileID)d=a.O,(k=a.lightTrackVars)&&(k=","+k+","+a.na.join(",")+",");else{d=a.g;if(a.pe||
a.linkType)k=a.linkTrackVars,f=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,1).toUpperCase()+a.pe.substring(1),a[e]&&(k=a[e].Mb,f=a[e].Lb));k&&(k=","+k+","+a.G.join(",")+",");f&&k&&(k+=",events,")}b&&(b=","+b+",");for(f=0;f<d.length;f++)e=d[f],(g=a[e])&&(!k||0<=k.indexOf(","+e+","))&&(!b||0<=b.indexOf(","+e+","))&&c(e,g)};a.r=function(c,b,d,f,e){var g="",k,m,h,t,l=0;"contextData"==c&&(c="c");if(b){for(k in b)if(!(Object.prototype[k]||e&&k.substring(0,e.length)!=e)&&b[k]&&(!d||0<=d.indexOf(","+(f?f+
".":"")+k+","))){h=!1;if(l)for(m=0;m<l.length;m++)k.substring(0,l[m].length)==l[m]&&(h=!0);if(!h&&(""==g&&(g+="&"+c+"."),m=b[k],e&&(k=k.substring(e.length)),0<k.length))if(h=k.indexOf("."),0<h)m=k.substring(0,h),h=(e?e:"")+m+".",l||(l=[]),l.push(h),g+=a.r(m,b,d,f,h);else if("boolean"==typeof m&&(m=m?"true":"false"),m){if("retrieveLightData"==f&&0>e.indexOf(".contextData."))switch(h=k.substring(0,4),t=k.substring(4),k){case "transactionID":k="xact";break;case "channel":k="ch";break;case "campaign":k=
"v0";break;default:a.La(t)&&("prop"==h?k="c"+t:"eVar"==h?k="v"+t:"list"==h?k="l"+t:"hier"==h&&(k="h"+t,m=m.substring(0,255)))}g+="&"+a.escape(k)+"="+a.escape(m)}}""!=g&&(g+="&."+c)}return g};a.usePostbacks=0;a.yb=function(){var c="",b,d,f,e,g,k,m,h,l="",p="",q=e="";if(a.lightProfileID)b=a.O,(l=a.lightTrackVars)&&(l=","+l+","+a.na.join(",")+",");else{b=a.g;if(a.pe||a.linkType)l=a.linkTrackVars,p=a.linkTrackEvents,a.pe&&(e=a.pe.substring(0,1).toUpperCase()+a.pe.substring(1),a[e]&&(l=a[e].Mb,p=a[e].Lb));
l&&(l=","+l+","+a.G.join(",")+",");p&&(p=","+p+",",l&&(l+=",events,"));a.events2&&(q+=(""!=q?",":"")+a.events2)}if(a.visitor&&a.visitor.getCustomerIDs){e=n;if(g=a.visitor.getCustomerIDs())for(d in g)Object.prototype[d]||(f=g[d],"object"==typeof f&&(e||(e={}),f.id&&(e[d+".id"]=f.id),f.authState&&(e[d+".as"]=f.authState)));e&&(c+=a.r("cid",e))}a.AudienceManagement&&a.AudienceManagement.isReady()&&(c+=a.r("d",a.AudienceManagement.getEventCallConfigParams()));for(d=0;d<b.length;d++){e=b[d];g=a[e];f=e.substring(0,
4);k=e.substring(4);!g&&"events"==e&&q&&(g=q,q="");if(g&&(!l||0<=l.indexOf(","+e+","))){switch(e){case "supplementalDataID":e="sdid";break;case "timestamp":e="ts";break;case "dynamicVariablePrefix":e="D";break;case "visitorID":e="vid";break;case "marketingCloudVisitorID":e="mid";break;case "analyticsVisitorID":e="aid";break;case "audienceManagerLocationHint":e="aamlh";break;case "audienceManagerBlob":e="aamb";break;case "authState":e="as";break;case "pageURL":e="g";255<g.length&&(a.pageURLRest=g.substring(255),
g=g.substring(0,255));break;case "pageURLRest":e="-g";break;case "referrer":e="r";break;case "vmk":case "visitorMigrationKey":e="vmt";break;case "visitorMigrationServer":e="vmf";a.ssl&&a.visitorMigrationServerSecure&&(g="");break;case "visitorMigrationServerSecure":e="vmf";!a.ssl&&a.visitorMigrationServer&&(g="");break;case "charSet":e="ce";break;case "visitorNamespace":e="ns";break;case "cookieDomainPeriods":e="cdp";break;case "cookieLifetime":e="cl";break;case "variableProvider":e="vvp";break;case "currencyCode":e=
"cc";break;case "channel":e="ch";break;case "transactionID":e="xact";break;case "campaign":e="v0";break;case "latitude":e="lat";break;case "longitude":e="lon";break;case "resolution":e="s";break;case "colorDepth":e="c";break;case "javascriptVersion":e="j";break;case "javaEnabled":e="v";break;case "cookiesEnabled":e="k";break;case "browserWidth":e="bw";break;case "browserHeight":e="bh";break;case "connectionType":e="ct";break;case "homepage":e="hp";break;case "events":q&&(g+=(""!=g?",":"")+q);if(p)for(k=
g.split(","),g="",f=0;f<k.length;f++)m=k[f],h=m.indexOf("="),0<=h&&(m=m.substring(0,h)),h=m.indexOf(":"),0<=h&&(m=m.substring(0,h)),0<=p.indexOf(","+m+",")&&(g+=(g?",":"")+k[f]);break;case "events2":g="";break;case "contextData":c+=a.r("c",a[e],l,e);g="";break;case "lightProfileID":e="mtp";break;case "lightStoreForSeconds":e="mtss";a.lightProfileID||(g="");break;case "lightIncrementBy":e="mti";a.lightProfileID||(g="");break;case "retrieveLightProfiles":e="mtsr";break;case "deleteLightProfiles":e=
"mtsd";break;case "retrieveLightData":a.retrieveLightProfiles&&(c+=a.r("mts",a[e],l,e));g="";break;default:a.La(k)&&("prop"==f?e="c"+k:"eVar"==f?e="v"+k:"list"==f?e="l"+k:"hier"==f&&(e="h"+k,g=g.substring(0,255)))}g&&(c+="&"+e+"="+("pev"!=e.substring(0,3)?a.escape(g):g))}"pev3"==e&&a.e&&(c+=a.e)}return c};a.D=function(a){var b=a.tagName;if("undefined"!=""+a.Rb||"undefined"!=""+a.Hb&&"HTML"!=(""+a.Hb).toUpperCase())return"";b=b&&b.toUpperCase?b.toUpperCase():"";"SHAPE"==b&&(b="");b&&(("INPUT"==b||
"BUTTON"==b)&&a.type&&a.type.toUpperCase?b=a.type.toUpperCase():!b&&a.href&&(b="A"));return b};a.Ha=function(a){var b=h.location,d=a.href?a.href:"",f,e,g;f=d.indexOf(":");e=d.indexOf("?");g=d.indexOf("/");d&&(0>f||0<=e&&f>e||0<=g&&f>g)&&(e=a.protocol&&1<a.protocol.length?a.protocol:b.protocol?b.protocol:"",f=b.pathname.lastIndexOf("/"),d=(e?e+"//":"")+(a.host?a.host:b.host?b.host:"")+("/"!=d.substring(0,1)?b.pathname.substring(0,0>f?0:f)+"/":"")+d);return d};a.L=function(c){var b=a.D(c),d,f,e="",
g=0;return b&&(d=c.protocol,f=c.onclick,!c.href||"A"!=b&&"AREA"!=b||f&&d&&!(0>d.toLowerCase().indexOf("javascript"))?f?(e=a.replace(a.replace(a.replace(a.replace(""+f,"\r",""),"\n",""),"\t","")," ",""),g=2):"INPUT"==b||"SUBMIT"==b?(c.value?e=c.value:c.innerText?e=c.innerText:c.textContent&&(e=c.textContent),g=3):"IMAGE"==b&&c.src&&(e=c.src):e=a.Ha(c),e)?{id:e.substring(0,100),type:g}:0};a.Pb=function(c){for(var b=a.D(c),d=a.L(c);c&&!d&&"BODY"!=b;)if(c=c.parentElement?c.parentElement:c.parentNode)b=
a.D(c),d=a.L(c);d&&"BODY"!=b||(c=0);c&&(b=c.onclick?""+c.onclick:"",0<=b.indexOf(".tl(")||0<=b.indexOf(".trackLink("))&&(c=0);return c};a.Gb=function(){var c,b,d=a.linkObject,f=a.linkType,e=a.linkURL,g,k;a.oa=1;d||(a.oa=0,d=a.clickObject);if(d){c=a.D(d);for(b=a.L(d);d&&!b&&"BODY"!=c;)if(d=d.parentElement?d.parentElement:d.parentNode)c=a.D(d),b=a.L(d);b&&"BODY"!=c||(d=0);if(d&&!a.linkObject){var m=d.onclick?""+d.onclick:"";if(0<=m.indexOf(".tl(")||0<=m.indexOf(".trackLink("))d=0}}else a.oa=1;!e&&d&&
(e=a.Ha(d));e&&!a.linkLeaveQueryString&&(g=e.indexOf("?"),0<=g&&(e=e.substring(0,g)));if(!f&&e){var l=0,p=0,n;if(a.trackDownloadLinks&&a.linkDownloadFileTypes)for(m=e.toLowerCase(),g=m.indexOf("?"),k=m.indexOf("#"),0<=g?0<=k&&k<g&&(g=k):g=k,0<=g&&(m=m.substring(0,g)),g=a.linkDownloadFileTypes.toLowerCase().split(","),k=0;k<g.length;k++)(n=g[k])&&m.substring(m.length-(n.length+1))=="."+n&&(f="d");if(a.trackExternalLinks&&!f&&(m=e.toLowerCase(),a.Ka(m)&&(a.linkInternalFilters||(a.linkInternalFilters=
h.location.hostname),g=0,a.linkExternalFilters?(g=a.linkExternalFilters.toLowerCase().split(","),l=1):a.linkInternalFilters&&(g=a.linkInternalFilters.toLowerCase().split(",")),g))){for(k=0;k<g.length;k++)n=g[k],0<=m.indexOf(n)&&(p=1);p?l&&(f="e"):l||(f="e")}}a.linkObject=d;a.linkURL=e;a.linkType=f;if(a.trackClickMap||a.trackInlineStats)a.e="",d&&(f=a.pageName,e=1,d=d.sourceIndex,f||(f=a.pageURL,e=0),h.s_objectID&&(b.id=h.s_objectID,d=b.type=1),f&&b&&b.id&&c&&(a.e="&pid="+a.escape(f.substring(0,255))+
(e?"&pidt="+e:"")+"&oid="+a.escape(b.id.substring(0,100))+(b.type?"&oidt="+b.type:"")+"&ot="+c+(d?"&oi="+d:"")))};a.zb=function(){var c=a.oa,b=a.linkType,d=a.linkURL,f=a.linkName;b&&(d||f)&&(b=b.toLowerCase(),"d"!=b&&"e"!=b&&(b="o"),a.pe="lnk_"+b,a.pev1=d?a.escape(d):"",a.pev2=f?a.escape(f):"",c=1);a.abort&&(c=0);if(a.trackClickMap||a.trackInlineStats||a.ActivityMap){var b={},d=0,e=a.cookieRead("s_sq"),g=e?e.split("&"):0,k,m,h,e=0;if(g)for(k=0;k<g.length;k++)m=g[k].split("="),f=a.unescape(m[0]).split(","),
m=a.unescape(m[1]),b[m]=f;f=a.account.split(",");k={};for(h in a.contextData)h&&!Object.prototype[h]&&"a.activitymap."==h.substring(0,14)&&(k[h]=a.contextData[h],a.contextData[h]="");a.e=a.r("c",k)+(a.e?a.e:"");if(c||a.e){c&&!a.e&&(e=1);for(m in b)if(!Object.prototype[m])for(h=0;h<f.length;h++)for(e&&(g=b[m].join(","),g==a.account&&(a.e+=("&"!=m.charAt(0)?"&":"")+m,b[m]=[],d=1)),k=0;k<b[m].length;k++)g=b[m][k],g==f[h]&&(e&&(a.e+="&u="+a.escape(g)+("&"!=m.charAt(0)?"&":"")+m+"&u=0"),b[m].splice(k,
1),d=1);c||(d=1);if(d){e="";k=2;!c&&a.e&&(e=a.escape(f.join(","))+"="+a.escape(a.e),k=1);for(m in b)!Object.prototype[m]&&0<k&&0<b[m].length&&(e+=(e?"&":"")+a.escape(b[m].join(","))+"="+a.escape(m),k--);a.cookieWrite("s_sq",e)}}}return c};a.Ab=function(){if(!a.Kb){var c=new Date,b=p.location,d,f,e=f=d="",g="",k="",h="1.2",l=a.cookieWrite("s_cc","true",0)?"Y":"N",n="",q="";if(c.setUTCDate&&(h="1.3",(0).toPrecision&&(h="1.5",c=[],c.forEach))){h="1.6";f=0;d={};try{f=new Iterator(d),f.next&&(h="1.7",
c.reduce&&(h="1.8",h.trim&&(h="1.8.1",Date.parse&&(h="1.8.2",Object.create&&(h="1.8.5")))))}catch(r){}}d=screen.width+"x"+screen.height;e=navigator.javaEnabled()?"Y":"N";f=screen.pixelDepth?screen.pixelDepth:screen.colorDepth;g=a.w.innerWidth?a.w.innerWidth:a.d.documentElement.offsetWidth;k=a.w.innerHeight?a.w.innerHeight:a.d.documentElement.offsetHeight;try{a.b.addBehavior("#default#homePage"),n=a.b.Qb(b)?"Y":"N"}catch(s){}try{a.b.addBehavior("#default#clientCaps"),q=a.b.connectionType}catch(u){}a.resolution=
d;a.colorDepth=f;a.javascriptVersion=h;a.javaEnabled=e;a.cookiesEnabled=l;a.browserWidth=g;a.browserHeight=k;a.connectionType=q;a.homepage=n;a.Kb=1}};a.Q={};a.loadModule=function(c,b){var d=a.Q[c];if(!d){d=h["AppMeasurement_Module_"+c]?new h["AppMeasurement_Module_"+c](a):{};a.Q[c]=a[c]=d;d.cb=function(){return d.hb};d.ib=function(b){if(d.hb=b)a[c+"_onLoad"]=b,a.ia(c+"_onLoad",[a,d],1)||b(a,d)};try{Object.defineProperty?Object.defineProperty(d,"onLoad",{get:d.cb,set:d.ib}):d._olc=1}catch(f){d._olc=
1}}b&&(a[c+"_onLoad"]=b,a.ia(c+"_onLoad",[a,d],1)||b(a,d))};a.p=function(c){var b,d;for(b in a.Q)if(!Object.prototype[b]&&(d=a.Q[b])&&(d._olc&&d.onLoad&&(d._olc=0,d.onLoad(a,d)),d[c]&&d[c]()))return 1;return 0};a.Cb=function(){var c=Math.floor(1E13*Math.random()),b=a.visitorSampling,d=a.visitorSamplingGroup,d="s_vsn_"+(a.visitorNamespace?a.visitorNamespace:a.account)+(d?"_"+d:""),f=a.cookieRead(d);if(b){b*=100;f&&(f=parseInt(f));if(!f){if(!a.cookieWrite(d,c))return 0;f=c}if(f%1E4>b)return 0}return 1};
a.R=function(c,b){var d,f,e,g,k,h;for(d=0;2>d;d++)for(f=0<d?a.Aa:a.g,e=0;e<f.length;e++)if(g=f[e],(k=c[g])||c["!"+g]){if(!b&&("contextData"==g||"retrieveLightData"==g)&&a[g])for(h in a[g])k[h]||(k[h]=a[g][h]);a[g]=k}};a.Ua=function(c,b){var d,f,e,g;for(d=0;2>d;d++)for(f=0<d?a.Aa:a.g,e=0;e<f.length;e++)g=f[e],c[g]=a[g],b||c[g]||(c["!"+g]=1)};a.ub=function(a){var b,d,f,e,g,k=0,h,l="",n="";if(a&&255<a.length&&(b=""+a,d=b.indexOf("?"),0<d&&(h=b.substring(d+1),b=b.substring(0,d),e=b.toLowerCase(),f=0,
"http://"==e.substring(0,7)?f+=7:"https://"==e.substring(0,8)&&(f+=8),d=e.indexOf("/",f),0<d&&(e=e.substring(f,d),g=b.substring(d),b=b.substring(0,d),0<=e.indexOf("google")?k=",q,ie,start,search_key,word,kw,cd,":0<=e.indexOf("yahoo.co")&&(k=",p,ei,"),k&&h)))){if((a=h.split("&"))&&1<a.length){for(f=0;f<a.length;f++)e=a[f],d=e.indexOf("="),0<d&&0<=k.indexOf(","+e.substring(0,d)+",")?l+=(l?"&":"")+e:n+=(n?"&":"")+e;l&&n?h=l+"&"+n:n=""}d=253-(h.length-n.length)-b.length;a=b+(0<d?g.substring(0,d):"")+
"?"+h}return a};a.$a=function(c){var b=a.d.visibilityState,d=["webkitvisibilitychange","visibilitychange"];b||(b=a.d.webkitVisibilityState);if(b&&"prerender"==b){if(c)for(b=0;b<d.length;b++)a.d.addEventListener(d[b],function(){var b=a.d.visibilityState;b||(b=a.d.webkitVisibilityState);"visible"==b&&c()});return!1}return!0};a.ea=!1;a.I=!1;a.kb=function(){a.I=!0;a.j()};a.ca=!1;a.V=!1;a.gb=function(c){a.marketingCloudVisitorID=c;a.V=!0;a.j()};a.fa=!1;a.W=!1;a.lb=function(c){a.visitorOptedOut=c;a.W=!0;
a.j()};a.Z=!1;a.S=!1;a.Wa=function(c){a.analyticsVisitorID=c;a.S=!0;a.j()};a.ba=!1;a.U=!1;a.Ya=function(c){a.audienceManagerLocationHint=c;a.U=!0;a.j()};a.aa=!1;a.T=!1;a.Xa=function(c){a.audienceManagerBlob=c;a.T=!0;a.j()};a.Za=function(c){a.maxDelay||(a.maxDelay=250);return a.p("_d")?(c&&setTimeout(function(){c()},a.maxDelay),!1):!0};a.da=!1;a.H=!1;a.xa=function(){a.H=!0;a.j()};a.isReadyToTrack=function(){var c=!0,b=a.visitor,d,f,e;a.ea||a.I||(a.$a(a.kb)?a.I=!0:a.ea=!0);if(a.ea&&!a.I)return!1;b&&
b.isAllowed()&&(a.ca||a.marketingCloudVisitorID||!b.getMarketingCloudVisitorID||(a.ca=!0,a.marketingCloudVisitorID=b.getMarketingCloudVisitorID([a,a.gb]),a.marketingCloudVisitorID&&(a.V=!0)),a.fa||a.visitorOptedOut||!b.isOptedOut||(a.fa=!0,a.visitorOptedOut=b.isOptedOut([a,a.lb]),a.visitorOptedOut!=n&&(a.W=!0)),a.Z||a.analyticsVisitorID||!b.getAnalyticsVisitorID||(a.Z=!0,a.analyticsVisitorID=b.getAnalyticsVisitorID([a,a.Wa]),a.analyticsVisitorID&&(a.S=!0)),a.ba||a.audienceManagerLocationHint||!b.getAudienceManagerLocationHint||
(a.ba=!0,a.audienceManagerLocationHint=b.getAudienceManagerLocationHint([a,a.Ya]),a.audienceManagerLocationHint&&(a.U=!0)),a.aa||a.audienceManagerBlob||!b.getAudienceManagerBlob||(a.aa=!0,a.audienceManagerBlob=b.getAudienceManagerBlob([a,a.Xa]),a.audienceManagerBlob&&(a.T=!0)),c=a.ca&&!a.V&&!a.marketingCloudVisitorID,b=a.Z&&!a.S&&!a.analyticsVisitorID,d=a.ba&&!a.U&&!a.audienceManagerLocationHint,f=a.aa&&!a.T&&!a.audienceManagerBlob,e=a.fa&&!a.W,c=c||b||d||f||e?!1:!0);a.da||a.H||(a.Za(a.xa)?a.H=!0:
a.da=!0);a.da&&!a.H&&(c=!1);return c};a.o=n;a.u=0;a.callbackWhenReadyToTrack=function(c,b,d){var f;f={};f.pb=c;f.ob=b;f.mb=d;a.o==n&&(a.o=[]);a.o.push(f);0==a.u&&(a.u=setInterval(a.j,100))};a.j=function(){var c;if(a.isReadyToTrack()&&(a.jb(),a.o!=n))for(;0<a.o.length;)c=a.o.shift(),c.ob.apply(c.pb,c.mb)};a.jb=function(){a.u&&(clearInterval(a.u),a.u=0)};a.eb=function(c){var b,d,f=n,e=n;if(!a.isReadyToTrack()){b=[];if(c!=n)for(d in f={},c)f[d]=c[d];e={};a.Ua(e,!0);b.push(f);b.push(e);a.callbackWhenReadyToTrack(a,
a.track,b);return!0}return!1};a.wb=function(){var c=a.cookieRead("s_fid"),b="",d="",f;f=8;var e=4;if(!c||0>c.indexOf("-")){for(c=0;16>c;c++)f=Math.floor(Math.random()*f),b+="0123456789ABCDEF".substring(f,f+1),f=Math.floor(Math.random()*e),d+="0123456789ABCDEF".substring(f,f+1),f=e=16;c=b+"-"+d}a.cookieWrite("s_fid",c,1)||(c=0);return c};a.t=a.track=function(c,b){var d,f=new Date,e="s"+Math.floor(f.getTime()/108E5)%10+Math.floor(1E13*Math.random()),g=f.getYear(),g="t="+a.escape(f.getDate()+"/"+f.getMonth()+
"/"+(1900>g?g+1900:g)+" "+f.getHours()+":"+f.getMinutes()+":"+f.getSeconds()+" "+f.getDay()+" "+f.getTimezoneOffset());a.visitor&&a.visitor.getAuthState&&(a.authState=a.visitor.getAuthState());a.p("_s");a.eb(c)||(b&&a.R(b),c&&(d={},a.Ua(d,0),a.R(c)),a.Cb()&&!a.visitorOptedOut&&(a.analyticsVisitorID||a.marketingCloudVisitorID||(a.fid=a.wb()),a.Gb(),a.usePlugins&&a.doPlugins&&a.doPlugins(a),a.account&&(a.abort||(a.visitor&&!a.supplementalDataID&&a.visitor.getSupplementalDataID&&(a.supplementalDataID=
a.visitor.getSupplementalDataID("AppMeasurement:"+a._in,a.expectSupplementalData?!1:!0)),a.trackOffline&&!a.timestamp&&(a.timestamp=Math.floor(f.getTime()/1E3)),f=h.location,a.pageURL||(a.pageURL=f.href?f.href:f),a.referrer||a.Va||(a.referrer=p.document.referrer),a.Va=1,a.referrer=a.ub(a.referrer),a.p("_g")),a.zb()&&!a.abort&&(a.Ab(),g+=a.yb(),a.Fb(e,g),a.p("_t"),a.referrer=""))),c&&a.R(d,1));a.abort=a.supplementalDataID=a.timestamp=a.pageURLRest=a.linkObject=a.clickObject=a.linkURL=a.linkName=a.linkType=
h.s_objectID=a.pe=a.pev1=a.pev2=a.pev3=a.e=a.lightProfileID=0};a.za=[];a.registerPreTrackCallback=function(c){for(var b=[],d=1;d<arguments.length;d++)b.push(arguments[d]);"function"==typeof c?a.za.push([c,b]):a.debugTracking&&a.P("DEBUG: Non function type passed to registerPreTrackCallback")};a.bb=function(c){a.wa(a.za,c)};a.ya=[];a.registerPostTrackCallback=function(c){for(var b=[],d=1;d<arguments.length;d++)b.push(arguments[d]);"function"==typeof c?a.ya.push([c,b]):a.debugTracking&&a.P("DEBUG: Non function type passed to registerPostTrackCallback")};
a.ab=function(c){a.wa(a.ya,c)};a.wa=function(c,b){if("object"==typeof c)for(var d=0;d<c.length;d++){var f=c[d][0],e=c[d][1];e.unshift(b);if("function"==typeof f)try{f.apply(null,e)}catch(g){a.debugTracking&&a.P(g.message)}}};a.tl=a.trackLink=function(c,b,d,f,e){a.linkObject=c;a.linkType=b;a.linkName=d;e&&(a.l=c,a.A=e);return a.track(f)};a.trackLight=function(c,b,d,f){a.lightProfileID=c;a.lightStoreForSeconds=b;a.lightIncrementBy=d;return a.track(f)};a.clearVars=function(){var c,b;for(c=0;c<a.g.length;c++)if(b=
a.g[c],"prop"==b.substring(0,4)||"eVar"==b.substring(0,4)||"hier"==b.substring(0,4)||"list"==b.substring(0,4)||"channel"==b||"events"==b||"eventList"==b||"products"==b||"productList"==b||"purchaseID"==b||"transactionID"==b||"state"==b||"zip"==b||"campaign"==b)a[b]=void 0};a.tagContainerMarker="";a.Fb=function(c,b){var d,f=a.trackingServer;d="";var e=a.dc,g="sc.",h=a.visitorNamespace;f?a.trackingServerSecure&&a.ssl&&(f=a.trackingServerSecure):(h||(h=a.account,f=h.indexOf(","),0<=f&&(h=h.substring(0,
f)),h=h.replace(/[^A-Za-z0-9]/g,"")),d||(d="2o7.net"),e=e?(""+e).toLowerCase():"d1","2o7.net"==d&&("d1"==e?e="112":"d2"==e&&(e="122"),g=""),f=h+"."+e+"."+g+d);d=a.ssl?"https://":"http://";e=a.AudienceManagement&&a.AudienceManagement.isReady()||0!=a.usePostbacks;d+=f+"/b/ss/"+a.account+"/"+(a.mobile?"5.":"")+(e?"10":"1")+"/JS-"+a.version+(a.Jb?"T":"")+(a.tagContainerMarker?"-"+a.tagContainerMarker:"")+"/"+c+"?AQB=1&ndh=1&pf=1&"+(e?"callback=s_c_il["+a._in+"].doPostbacks&et=1&":"")+b+"&AQE=1";a.bb(d);
a.sb(d);a.ka()};a.Ta=/{(%?)(.*?)(%?)}/;a.Nb=RegExp(a.Ta.source,"g");a.tb=function(c){if("object"==typeof c.dests)for(var b=0;b<c.dests.length;++b){var d=c.dests[b];if("string"==typeof d.c&&"aa."==d.id.substr(0,3))for(var f=d.c.match(a.Nb),e=0;e<f.length;++e){var g=f[e],h=g.match(a.Ta),l="";"%"==h[1]&&"timezone_offset"==h[2]?l=(new Date).getTimezoneOffset():"%"==h[1]&&"timestampz"==h[2]&&(l=a.xb());d.c=d.c.replace(g,a.escape(l))}}};a.xb=function(){var c=new Date,b=new Date(6E4*Math.abs(c.getTimezoneOffset()));
return a.k(4,c.getFullYear())+"-"+a.k(2,c.getMonth()+1)+"-"+a.k(2,c.getDate())+"T"+a.k(2,c.getHours())+":"+a.k(2,c.getMinutes())+":"+a.k(2,c.getSeconds())+(0<c.getTimezoneOffset()?"-":"+")+a.k(2,b.getUTCHours())+":"+a.k(2,b.getUTCMinutes())};a.k=function(a,b){return(Array(a+1).join(0)+b).slice(-a)};a.ta={};a.doPostbacks=function(c){if("object"==typeof c)if(a.tb(c),"object"==typeof a.AudienceManagement&&"function"==typeof a.AudienceManagement.isReady&&a.AudienceManagement.isReady()&&"function"==typeof a.AudienceManagement.passData)a.AudienceManagement.passData(c);
else if("object"==typeof c&&"object"==typeof c.dests)for(var b=0;b<c.dests.length;++b){var d=c.dests[b];"object"==typeof d&&"string"==typeof d.c&&"string"==typeof d.id&&"aa."==d.id.substr(0,3)&&(a.ta[d.id]=new Image,a.ta[d.id].alt="",a.ta[d.id].src=d.c)}};a.sb=function(c){a.i||a.Bb();a.i.push(c);a.ma=a.C();a.Ra()};a.Bb=function(){a.i=a.Db();a.i||(a.i=[])};a.Db=function(){var c,b;if(a.ra()){try{(b=h.localStorage.getItem(a.pa()))&&(c=h.JSON.parse(b))}catch(d){}return c}};a.ra=function(){var c=!0;a.trackOffline&&
a.offlineFilename&&h.localStorage&&h.JSON||(c=!1);return c};a.Ia=function(){var c=0;a.i&&(c=a.i.length);a.q&&c++;return c};a.ka=function(){if(a.q&&(a.B&&a.B.complete&&a.B.F&&a.B.va(),a.q))return;a.Ja=n;if(a.qa)a.ma>a.N&&a.Pa(a.i),a.ua(500);else{var c=a.nb();if(0<c)a.ua(c);else if(c=a.Fa())a.q=1,a.Eb(c),a.Ib(c)}};a.ua=function(c){a.Ja||(c||(c=0),a.Ja=setTimeout(a.ka,c))};a.nb=function(){var c;if(!a.trackOffline||0>=a.offlineThrottleDelay)return 0;c=a.C()-a.Oa;return a.offlineThrottleDelay<c?0:a.offlineThrottleDelay-
c};a.Fa=function(){if(0<a.i.length)return a.i.shift()};a.Eb=function(c){if(a.debugTracking){var b="AppMeasurement Debug: "+c;c=c.split("&");var d;for(d=0;d<c.length;d++)b+="\n\t"+a.unescape(c[d]);a.P(b)}};a.fb=function(){return a.marketingCloudVisitorID||a.analyticsVisitorID};a.Y=!1;var q;try{q=JSON.parse('{"x":"y"}')}catch(u){q=null}q&&"y"==q.x?(a.Y=!0,a.X=function(a){return JSON.parse(a)}):h.$&&h.$.parseJSON?(a.X=function(a){return h.$.parseJSON(a)},a.Y=!0):a.X=function(){return null};a.Ib=function(c){var b,
d,f;a.fb()&&2047<c.length&&("undefined"!=typeof XMLHttpRequest&&(b=new XMLHttpRequest,"withCredentials"in b?d=1:b=0),b||"undefined"==typeof XDomainRequest||(b=new XDomainRequest,d=2),b&&(a.AudienceManagement&&a.AudienceManagement.isReady()||0!=a.usePostbacks)&&(a.Y?b.Ba=!0:b=0));!b&&a.Sa&&(c=c.substring(0,2047));!b&&a.d.createElement&&(0!=a.usePostbacks||a.AudienceManagement&&a.AudienceManagement.isReady())&&(b=a.d.createElement("SCRIPT"))&&"async"in b&&((f=(f=a.d.getElementsByTagName("HEAD"))&&f[0]?
f[0]:a.d.body)?(b.type="text/javascript",b.setAttribute("async","async"),d=3):b=0);b||(b=new Image,b.alt="",b.abort||"undefined"===typeof h.InstallTrigger||(b.abort=function(){b.src=n}));b.Da=function(){try{b.F&&(clearTimeout(b.F),b.F=0)}catch(a){}};b.onload=b.va=function(){a.ab(c);b.Da();a.rb();a.ga();a.q=0;a.ka();if(b.Ba){b.Ba=!1;try{a.doPostbacks(a.X(b.responseText))}catch(d){}}};b.onabort=b.onerror=b.Ga=function(){b.Da();(a.trackOffline||a.qa)&&a.q&&a.i.unshift(a.qb);a.q=0;a.ma>a.N&&a.Pa(a.i);
a.ga();a.ua(500)};b.onreadystatechange=function(){4==b.readyState&&(200==b.status?b.va():b.Ga())};a.Oa=a.C();if(1==d||2==d){var e=c.indexOf("?");f=c.substring(0,e);e=c.substring(e+1);e=e.replace(/&callback=[a-zA-Z0-9_.\[\]]+/,"");1==d?(b.open("POST",f,!0),b.send(e)):2==d&&(b.open("POST",f),b.send(e))}else if(b.src=c,3==d){if(a.Ma)try{f.removeChild(a.Ma)}catch(g){}f.firstChild?f.insertBefore(b,f.firstChild):f.appendChild(b);a.Ma=a.B}b.F=setTimeout(function(){b.F&&(b.complete?b.va():(a.trackOffline&&
b.abort&&b.abort(),b.Ga()))},5E3);a.qb=c;a.B=h["s_i_"+a.replace(a.account,",","_")]=b;if(a.useForcedLinkTracking&&a.J||a.A)a.forcedLinkTrackingTimeout||(a.forcedLinkTrackingTimeout=250),a.ha=setTimeout(a.ga,a.forcedLinkTrackingTimeout)};a.rb=function(){if(a.ra()&&!(a.Na>a.N))try{h.localStorage.removeItem(a.pa()),a.Na=a.C()}catch(c){}};a.Pa=function(c){if(a.ra()){a.Ra();try{h.localStorage.setItem(a.pa(),h.JSON.stringify(c)),a.N=a.C()}catch(b){}}};a.Ra=function(){if(a.trackOffline){if(!a.offlineLimit||
0>=a.offlineLimit)a.offlineLimit=10;for(;a.i.length>a.offlineLimit;)a.Fa()}};a.forceOffline=function(){a.qa=!0};a.forceOnline=function(){a.qa=!1};a.pa=function(){return a.offlineFilename+"-"+a.visitorNamespace+a.account};a.C=function(){return(new Date).getTime()};a.Ka=function(a){a=a.toLowerCase();return 0!=a.indexOf("#")&&0!=a.indexOf("about:")&&0!=a.indexOf("opera:")&&0!=a.indexOf("javascript:")?!0:!1};a.setTagContainer=function(c){var b,d,f;a.Jb=c;for(b=0;b<a._il.length;b++)if((d=a._il[b])&&"s_l"==
d._c&&d.tagContainerName==c){a.R(d);if(d.lmq)for(b=0;b<d.lmq.length;b++)f=d.lmq[b],a.loadModule(f.n);if(d.ml)for(f in d.ml)if(a[f])for(b in c=a[f],f=d.ml[f],f)!Object.prototype[b]&&("function"!=typeof f[b]||0>(""+f[b]).indexOf("s_c_il"))&&(c[b]=f[b]);if(d.mmq)for(b=0;b<d.mmq.length;b++)f=d.mmq[b],a[f.m]&&(c=a[f.m],c[f.f]&&"function"==typeof c[f.f]&&(f.a?c[f.f].apply(c,f.a):c[f.f].apply(c)));if(d.tq)for(b=0;b<d.tq.length;b++)a.track(d.tq[b]);d.s=a;break}};a.Util={urlEncode:a.escape,urlDecode:a.unescape,
cookieRead:a.cookieRead,cookieWrite:a.cookieWrite,getQueryParam:function(c,b,d){var f;b||(b=a.pageURL?a.pageURL:h.location);d||(d="&");return c&&b&&(b=""+b,f=b.indexOf("?"),0<=f&&(b=d+b.substring(f+1)+d,f=b.indexOf(d+c+"="),0<=f&&(b=b.substring(f+d.length+c.length+1),f=b.indexOf(d),0<=f&&(b=b.substring(0,f)),0<b.length)))?a.unescape(b):""}};a.G="supplementalDataID timestamp dynamicVariablePrefix visitorID marketingCloudVisitorID analyticsVisitorID audienceManagerLocationHint authState fid vmk visitorMigrationKey visitorMigrationServer visitorMigrationServerSecure charSet visitorNamespace cookieDomainPeriods fpCookieDomainPeriods cookieLifetime pageName pageURL referrer contextData currencyCode lightProfileID lightStoreForSeconds lightIncrementBy retrieveLightProfiles deleteLightProfiles retrieveLightData".split(" ");
a.g=a.G.concat("purchaseID variableProvider channel server pageType transactionID campaign state zip events events2 products audienceManagerBlob tnt".split(" "));a.na="timestamp charSet visitorNamespace cookieDomainPeriods cookieLifetime contextData lightProfileID lightStoreForSeconds lightIncrementBy".split(" ");a.O=a.na.slice(0);a.Aa="account allAccounts debugTracking visitor visitorOptedOut trackOffline offlineLimit offlineThrottleDelay offlineFilename usePlugins doPlugins configURL visitorSampling visitorSamplingGroup linkObject clickObject linkURL linkName linkType trackDownloadLinks trackExternalLinks trackClickMap trackInlineStats linkLeaveQueryString linkTrackVars linkTrackEvents linkDownloadFileTypes linkExternalFilters linkInternalFilters useForcedLinkTracking forcedLinkTrackingTimeout trackingServer trackingServerSecure ssl abort mobile dc lightTrackVars maxDelay expectSupplementalData usePostbacks registerPreTrackCallback registerPostTrackCallback AudienceManagement".split(" ");
for(l=0;250>=l;l++)76>l&&(a.g.push("prop"+l),a.O.push("prop"+l)),a.g.push("eVar"+l),a.O.push("eVar"+l),6>l&&a.g.push("hier"+l),4>l&&a.g.push("list"+l);l="pe pev1 pev2 pev3 latitude longitude resolution colorDepth javascriptVersion javaEnabled cookiesEnabled browserWidth browserHeight connectionType homepage pageURLRest".split(" ");a.g=a.g.concat(l);a.G=a.G.concat(l);a.ssl=0<=h.location.protocol.toLowerCase().indexOf("https");a.charSet="UTF-8";a.contextData={};a.offlineThrottleDelay=0;a.offlineFilename=
"AppMeasurement.offline";a.Oa=0;a.ma=0;a.N=0;a.Na=0;a.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx";a.w=h;a.d=h.document;try{if(a.Sa=!1,navigator){var v=navigator.userAgent;if("Microsoft Internet Explorer"==navigator.appName||0<=v.indexOf("MSIE ")||0<=v.indexOf("Trident/")&&0<=v.indexOf("Windows NT 6"))a.Sa=!0}}catch(w){}a.ga=function(){a.ha&&(h.clearTimeout(a.ha),a.ha=n);a.l&&a.J&&a.l.dispatchEvent(a.J);a.A&&("function"==typeof a.A?a.A():a.l&&a.l.href&&(a.d.location=
a.l.href));a.l=a.J=a.A=0};a.Qa=function(){a.b=a.d.body;a.b?(a.v=function(c){var b,d,f,e,g;if(!(a.d&&a.d.getElementById("cppXYctnr")||c&&c["s_fe_"+a._in])){if(a.Ca)if(a.useForcedLinkTracking)a.b.removeEventListener("click",a.v,!1);else{a.b.removeEventListener("click",a.v,!0);a.Ca=a.useForcedLinkTracking=0;return}else a.useForcedLinkTracking=0;a.clickObject=c.srcElement?c.srcElement:c.target;try{if(!a.clickObject||a.M&&a.M==a.clickObject||!(a.clickObject.tagName||a.clickObject.parentElement||a.clickObject.parentNode))a.clickObject=
0;else{var k=a.M=a.clickObject;a.la&&(clearTimeout(a.la),a.la=0);a.la=setTimeout(function(){a.M==k&&(a.M=0)},1E4);f=a.Ia();a.track();if(f<a.Ia()&&a.useForcedLinkTracking&&c.target){for(e=c.target;e&&e!=a.b&&"A"!=e.tagName.toUpperCase()&&"AREA"!=e.tagName.toUpperCase();)e=e.parentNode;if(e&&(g=e.href,a.Ka(g)||(g=0),d=e.target,c.target.dispatchEvent&&g&&(!d||"_self"==d||"_top"==d||"_parent"==d||h.name&&d==h.name))){try{b=a.d.createEvent("MouseEvents")}catch(l){b=new h.MouseEvent}if(b){try{b.initMouseEvent("click",
c.bubbles,c.cancelable,c.view,c.detail,c.screenX,c.screenY,c.clientX,c.clientY,c.ctrlKey,c.altKey,c.shiftKey,c.metaKey,c.button,c.relatedTarget)}catch(n){b=0}b&&(b["s_fe_"+a._in]=b.s_fe=1,c.stopPropagation(),c.stopImmediatePropagation&&c.stopImmediatePropagation(),c.preventDefault(),a.l=c.target,a.J=b)}}}}}catch(p){a.clickObject=0}}},a.b&&a.b.attachEvent?a.b.attachEvent("onclick",a.v):a.b&&a.b.addEventListener&&(navigator&&(0<=navigator.userAgent.indexOf("WebKit")&&a.d.createEvent||0<=navigator.userAgent.indexOf("Firefox/2")&&
h.MouseEvent)&&(a.Ca=1,a.useForcedLinkTracking=1,a.b.addEventListener("click",a.v,!0)),a.b.addEventListener("click",a.v,!1))):setTimeout(a.Qa,30)};a.Qa();a.loadModule("ActivityMap")}
function s_gi(a){var h,n=window.s_c_il,p,l,r=a.split(","),s,q,u=0;if(n)for(p=0;!u&&p<n.length;){h=n[p];if("s_c"==h._c&&(h.account||h.oun))if(h.account&&h.account==a)u=1;else for(l=h.account?h.account:h.oun,l=h.allAccounts?h.allAccounts:l.split(","),s=0;s<r.length;s++)for(q=0;q<l.length;q++)r[s]==l[q]&&(u=1);p++}u||(h=new AppMeasurement);h.setAccount?h.setAccount(a):h.sa&&h.sa(a);return h}AppMeasurement.getInstance=s_gi;window.s_objectID||(window.s_objectID=0);
function s_pgicq(){var a=window,h=a.s_giq,n,p,l;if(h)for(n=0;n<h.length;n++)p=h[n],l=s_gi(p.oun),l.setAccount(p.un),l.setTagContainer(p.tagContainerName);a.s_giq=0}s_pgicq();

</script>
    <script>
/*! Grand Central Telemetry v4.15.0 (1/21/2020, 3:58:07 PM) */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.GrandCentralTelemetry = {}));
}(this, function (exports) { 'use strict';

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }

  var eq_1 = eq;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function assocIndexOf(array, key) {
    var length = array.length;

    while (length--) {
      if (eq_1(array[length][0], key)) {
        return length;
      }
    }

    return -1;
  }

  var _assocIndexOf = assocIndexOf;

  /** Used for built-in method references. */

  var arrayProto = Array.prototype;
  /** Built-in value references. */

  var splice = arrayProto.splice;
  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function listCacheDelete(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }

    var lastIndex = data.length - 1;

    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }

    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function listCacheGet(key) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function listCacheHas(key) {
    return _assocIndexOf(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */

  function listCacheSet(key, value) {
    var data = this.__data__,
        index = _assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }

    return this;
  }

  var _listCacheSet = listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `ListCache`.


  ListCache.prototype.clear = _listCacheClear;
  ListCache.prototype['delete'] = _listCacheDelete;
  ListCache.prototype.get = _listCacheGet;
  ListCache.prototype.has = _listCacheHas;
  ListCache.prototype.set = _listCacheSet;
  var _ListCache = ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */

  function stackClear() {
    this.__data__ = new _ListCache();
    this.size = 0;
  }

  var _stackClear = stackClear;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);
    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas;

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var commonjsHelpers = /*#__PURE__*/Object.freeze({
    commonjsGlobal: commonjsGlobal,
    commonjsRequire: commonjsRequire,
    unwrapExports: unwrapExports,
    createCommonjsModule: createCommonjsModule,
    getCjsExportFromNamespace: getCjsExportFromNamespace
  });

  function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
  /** Detect free variable `global` from Node.js. */

  var freeGlobal = _typeof(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal;

  function _typeof$1(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }
  /** Detect free variable `self`. */

  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) == 'object' && self && self.Object === Object && self;
  /** Used as a reference to the global object. */

  var root = _freeGlobal || freeSelf || Function('return this')();
  var _root = root;

  /** Built-in value references. */

  var _Symbol2 = _root.Symbol;
  var _Symbol = _Symbol2;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty = objectProto.hasOwnProperty;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString = objectProto.toString;
  /** Built-in value references. */

  var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */

  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag),
        tag = value[symToStringTag];

    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString.call(value);

    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }

    return result;
  }

  var _getRawTag = getRawTag;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;
  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */

  var nativeObjectToString$1 = objectProto$1.toString;
  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */

  function objectToString(value) {
    return nativeObjectToString$1.call(value);
  }

  var _objectToString = objectToString;

  /** `Object#toString` result references. */

  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';
  /** Built-in value references. */

  var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }

    return symToStringTag$1 && symToStringTag$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
  }

  var _baseGetTag = baseGetTag;

  function _typeof$2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = _typeof$2(value);

    return value != null && (type == 'object' || type == 'function');
  }

  var isObject_1 = isObject;

  /** `Object#toString` result references. */

  var asyncTag = '[object AsyncFunction]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';
  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */

  function isFunction(value) {
    if (!isObject_1(value)) {
      return false;
    } // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.


    var tag = _baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  var isFunction_1 = isFunction;

  /** Used to detect overreaching core-js shims. */

  var coreJsData = _root['__core-js_shared__'];
  var _coreJsData = coreJsData;

  /** Used to detect methods masquerading as native. */

  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();
  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */


  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked;

  /** Used for built-in method references. */
  var funcProto = Function.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString = funcProto.toString;
  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */

  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}

      try {
        return func + '';
      } catch (e) {}
    }

    return '';
  }

  var _toSource = toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */

  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  /** Used to detect host constructors (Safari). */

  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype,
      objectProto$2 = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$1 = funcProto$1.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
  /** Used to detect if a method is native. */

  var reIsNative = RegExp('^' + funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */

  function baseIsNative(value) {
    if (!isObject_1(value) || _isMasked(value)) {
      return false;
    }

    var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(_toSource(value));
  }

  var _baseIsNative = baseIsNative;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */

  function getNative(object, key) {
    var value = _getValue(object, key);
    return _baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative;

  /* Built-in method references that are verified to be native. */

  var Map$1 = _getNative(_root, 'Map');
  var _Map = Map$1;

  /* Built-in method references that are verified to be native. */

  var nativeCreate = _getNative(Object, 'create');
  var _nativeCreate = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */

  function hashClear() {
    this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete;

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = '__lodash_hash_undefined__';
  /** Used for built-in method references. */

  var objectProto$3 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function hashGet(key) {
    var data = this.__data__;

    if (_nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }

    return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet;

  /** Used for built-in method references. */

  var objectProto$4 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function hashHas(key) {
    var data = this.__data__;
    return _nativeCreate ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
  }

  var _hashHas = hashHas;

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */

  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = _nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `Hash`.


  Hash.prototype.clear = _hashClear;
  Hash.prototype['delete'] = _hashDelete;
  Hash.prototype.get = _hashGet;
  Hash.prototype.has = _hashHas;
  Hash.prototype.set = _hashSet;
  var _Hash = Hash;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */

  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new _Hash(),
      'map': new (_Map || _ListCache)(),
      'string': new _Hash()
    };
  }

  var _mapCacheClear = mapCacheClear;

  function _typeof$3(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = _typeof$3(value);

    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }

  var _isKeyable = isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */

  function getMapData(map, key) {
    var data = map.__data__;
    return _isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }

  var _getMapData = getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function mapCacheDelete(key) {
    var result = _getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function mapCacheGet(key) {
    return _getMapData(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function mapCacheHas(key) {
    return _getMapData(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */

  function mapCacheSet(key, value) {
    var data = _getMapData(this, key),
        size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;
    this.clear();

    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  } // Add methods to `MapCache`.


  MapCache.prototype.clear = _mapCacheClear;
  MapCache.prototype['delete'] = _mapCacheDelete;
  MapCache.prototype.get = _mapCacheGet;
  MapCache.prototype.has = _mapCacheHas;
  MapCache.prototype.set = _mapCacheSet;
  var _MapCache = MapCache;

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE = 200;
  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */

  function stackSet(key, value) {
    var data = this.__data__;

    if (data instanceof _ListCache) {
      var pairs = data.__data__;

      if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }

      data = this.__data__ = new _MapCache(pairs);
    }

    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */

  function Stack(entries) {
    var data = this.__data__ = new _ListCache(entries);
    this.size = data.size;
  } // Add methods to `Stack`.


  Stack.prototype.clear = _stackClear;
  Stack.prototype['delete'] = _stackDelete;
  Stack.prototype.get = _stackGet;
  Stack.prototype.has = _stackHas;
  Stack.prototype.set = _stackSet;
  var _Stack = Stack;

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }

    return array;
  }

  var _arrayEach = arrayEach;

  var defineProperty = function () {
    try {
      var func = _getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();

  var _defineProperty = defineProperty;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && _defineProperty) {
      _defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue;

  /** Used for built-in method references. */

  var objectProto$5 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */

  function assignValue(object, key, value) {
    var objValue = object[key];

    if (!(hasOwnProperty$4.call(object, key) && eq_1(objValue, value)) || value === undefined && !(key in object)) {
      _baseAssignValue(object, key, value);
    }
  }

  var _assignValue = assignValue;

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */

  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }

      if (isNew) {
        _baseAssignValue(object, key, newValue);
      } else {
        _assignValue(object, key, newValue);
      }
    }

    return object;
  }

  var _copyObject = copyObject;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }

    return result;
  }

  var _baseTimes = baseTimes;

  function _typeof$4(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && _typeof$4(value) == 'object';
  }

  var isObjectLike_1 = isObjectLike;

  /** `Object#toString` result references. */

  var argsTag = '[object Arguments]';
  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */

  function baseIsArguments(value) {
    return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
  }

  var _baseIsArguments = baseIsArguments;

  /** Used for built-in method references. */

  var objectProto$6 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
  /** Built-in value references. */

  var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */

  var isArguments = _baseIsArguments(function () {
    return arguments;
  }()) ? _baseIsArguments : function (value) {
    return isObjectLike_1(value) && hasOwnProperty$5.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;
  var isArray_1 = isArray;

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */

    var Buffer = moduleExports ? _root.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */

    var isBuffer = nativeIsBuffer || stubFalse_1;
    module.exports = isBuffer;
  });

  function _typeof$5(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;
  /** Used to detect unsigned integer values. */

  var reIsUint = /^(?:0|[1-9]\d*)$/;
  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */

  function isIndex(value, length) {
    var type = _typeof$5(value);

    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }

  var _isIndex = isIndex;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;
  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */

  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }

  var isLength_1 = isLength;

  /** `Object#toString` result references. */

  var argsTag$1 = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag$1 = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';
  /** Used to identify `toStringTag` values of typed arrays. */

  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */

  function baseIsTypedArray(value) {
    return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
  }

  var _baseIsTypedArray = baseIsTypedArray;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary;

  var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && _freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        } // Legacy `process.binding('util')` for Node.js < 10.


        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();

    module.exports = nodeUtil;
  });

  /* Node.js helper references. */

  var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */

  var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
  var isTypedArray_1 = isTypedArray;

  /** Used for built-in method references. */

  var objectProto$7 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */

  function arrayLikeKeys(value, inherited) {
    var isArr = isArray_1(value),
        isArg = !isArr && isArguments_1(value),
        isBuff = !isArr && !isArg && isBuffer_1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? _baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
      _isIndex(key, length)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;
  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */

  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$8;
    return value === proto;
  }

  var _isPrototype = isPrototype;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeKeys = _overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys;

  /** Used for built-in method references. */

  var objectProto$9 = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeys(object) {
    if (!_isPrototype(object)) {
      return _nativeKeys(object);
    }

    var result = [];

    for (var key in Object(object)) {
      if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeys = baseKeys;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */

  function isArrayLike(value) {
    return value != null && isLength_1(value.length) && !isFunction_1(value);
  }

  var isArrayLike_1 = isArrayLike;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */

  function keys(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
  }

  var keys_1 = keys;

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */

  function baseAssign(object, source) {
    return object && _copyObject(source, keys_1(source), object);
  }

  var _baseAssign = baseAssign;

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];

    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }

    return result;
  }

  var _nativeKeysIn = nativeKeysIn;

  /** Used for built-in method references. */

  var objectProto$a = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function baseKeysIn(object) {
    if (!isObject_1(object)) {
      return _nativeKeysIn(object);
    }

    var isProto = _isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$8.call(object, key)))) {
        result.push(key);
      }
    }

    return result;
  }

  var _baseKeysIn = baseKeysIn;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */

  function keysIn$1(object) {
    return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
  }

  var keysIn_1 = keysIn$1;

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */

  function baseAssignIn(object, source) {
    return object && _copyObject(source, keysIn_1(source), object);
  }

  var _baseAssignIn = baseAssignIn;

  var _cloneBuffer = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */

    var Buffer = moduleExports ? _root.Buffer : undefined,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */

    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }

      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
  });

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;
    array || (array = Array(length));

    while (++index < length) {
      array[index] = source[index];
    }

    return array;
  }

  var _copyArray = copyArray;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var _arrayFilter = arrayFilter;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  var stubArray_1 = stubArray;

  /** Used for built-in method references. */

  var objectProto$b = Object.prototype;
  /** Built-in value references. */

  var propertyIsEnumerable$1 = objectProto$b.propertyIsEnumerable;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbols = !nativeGetSymbols ? stubArray_1 : function (object) {
    if (object == null) {
      return [];
    }

    object = Object(object);
    return _arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols;

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */

  function copySymbols(source, object) {
    return _copyObject(source, _getSymbols(source), object);
  }

  var _copySymbols = copySymbols;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }

    return array;
  }

  var _arrayPush = arrayPush;

  /** Built-in value references. */

  var getPrototype = _overArg(Object.getPrototypeOf, Object);
  var _getPrototype = getPrototype;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */

  var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function (object) {
    var result = [];

    while (object) {
      _arrayPush(result, _getSymbols(object));
      object = _getPrototype(object);
    }

    return result;
  };
  var _getSymbolsIn = getSymbolsIn;

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */

  function copySymbolsIn(source, object) {
    return _copyObject(source, _getSymbolsIn(source), object);
  }

  var _copySymbolsIn = copySymbolsIn;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeys(object) {
    return _baseGetAllKeys(object, keys_1, _getSymbols);
  }

  var _getAllKeys = getAllKeys;

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */

  function getAllKeysIn(object) {
    return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
  }

  var _getAllKeysIn = getAllKeysIn;

  /* Built-in method references that are verified to be native. */

  var DataView$1 = _getNative(_root, 'DataView');
  var _DataView = DataView$1;

  /* Built-in method references that are verified to be native. */

  var Promise$1 = _getNative(_root, 'Promise');
  var _Promise = Promise$1;

  /* Built-in method references that are verified to be native. */

  var Set = _getNative(_root, 'Set');
  var _Set = Set;

  /* Built-in method references that are verified to be native. */

  var WeakMap = _getNative(_root, 'WeakMap');
  var _WeakMap = WeakMap;

  /** `Object#toString` result references. */

  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag$1 = '[object WeakMap]';
  var dataViewTag$1 = '[object DataView]';
  /** Used to detect maps, sets, and weakmaps. */

  var dataViewCtorString = _toSource(_DataView),
      mapCtorString = _toSource(_Map),
      promiseCtorString = _toSource(_Promise),
      setCtorString = _toSource(_Set),
      weakMapCtorString = _toSource(_WeakMap);
  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */

  var getTag = _baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

  if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1 || _Map && getTag(new _Map()) != mapTag$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1) {
    getTag = function getTag(value) {
      var result = _baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? _toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$1;

          case mapCtorString:
            return mapTag$1;

          case promiseCtorString:
            return promiseTag;

          case setCtorString:
            return setTag$1;

          case weakMapCtorString:
            return weakMapTag$1;
        }
      }

      return result;
    };
  }

  var _getTag = getTag;

  /** Used for built-in method references. */
  var objectProto$c = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */

  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

    if (length && typeof array[0] == 'string' && hasOwnProperty$9.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }

    return result;
  }

  var _initCloneArray = initCloneArray;

  /** Built-in value references. */

  var Uint8Array$1 = _root.Uint8Array;
  var _Uint8Array = Uint8Array$1;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */

  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer;

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */

  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  var _cloneDataView = cloneDataView;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;
  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */

  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  var _cloneRegExp = cloneRegExp;

  /** Used to convert symbols to primitives and strings. */

  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */

  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  var _cloneSymbol = cloneSymbol;

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */

  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  var _cloneTypedArray = cloneTypedArray;

  /** `Object#toString` result references. */

  var boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag$1 = '[object Float32Array]',
      float64Tag$1 = '[object Float64Array]',
      int8Tag$1 = '[object Int8Array]',
      int16Tag$1 = '[object Int16Array]',
      int32Tag$1 = '[object Int32Array]',
      uint8Tag$1 = '[object Uint8Array]',
      uint8ClampedTag$1 = '[object Uint8ClampedArray]',
      uint16Tag$1 = '[object Uint16Array]',
      uint32Tag$1 = '[object Uint32Array]';
  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */

  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;

    switch (tag) {
      case arrayBufferTag$1:
        return _cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$2:
        return _cloneDataView(object, isDeep);

      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return _cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor();

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return _cloneRegExp(object);

      case setTag$2:
        return new Ctor();

      case symbolTag:
        return _cloneSymbol(object);
    }
  }

  var _initCloneByTag = initCloneByTag;

  /** Built-in value references. */

  var objectCreate = Object.create;
  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */

  var baseCreate = function () {
    function object() {}

    return function (proto) {
      if (!isObject_1(proto)) {
        return {};
      }

      if (objectCreate) {
        return objectCreate(proto);
      }

      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  }();

  var _baseCreate = baseCreate;

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */

  function initCloneObject(object) {
    return typeof object.constructor == 'function' && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
  }

  var _initCloneObject = initCloneObject;

  /** `Object#toString` result references. */

  var mapTag$3 = '[object Map]';
  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */

  function baseIsMap(value) {
    return isObjectLike_1(value) && _getTag(value) == mapTag$3;
  }

  var _baseIsMap = baseIsMap;

  /* Node.js helper references. */

  var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */

  var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
  var isMap_1 = isMap;

  /** `Object#toString` result references. */

  var setTag$3 = '[object Set]';
  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */

  function baseIsSet(value) {
    return isObjectLike_1(value) && _getTag(value) == setTag$3;
  }

  var _baseIsSet = baseIsSet;

  /* Node.js helper references. */

  var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */

  var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
  var isSet_1 = isSet;

  /** Used to compose bitmasks for cloning. */

  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;
  /** `Object#toString` result references. */

  var argsTag$2 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$2 = '[object Boolean]',
      dateTag$2 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag$2 = '[object Function]',
      genTag$1 = '[object GeneratorFunction]',
      mapTag$4 = '[object Map]',
      numberTag$2 = '[object Number]',
      objectTag$2 = '[object Object]',
      regexpTag$2 = '[object RegExp]',
      setTag$4 = '[object Set]',
      stringTag$2 = '[object String]',
      symbolTag$1 = '[object Symbol]',
      weakMapTag$2 = '[object WeakMap]';
  var arrayBufferTag$2 = '[object ArrayBuffer]',
      dataViewTag$3 = '[object DataView]',
      float32Tag$2 = '[object Float32Array]',
      float64Tag$2 = '[object Float64Array]',
      int8Tag$2 = '[object Int8Array]',
      int16Tag$2 = '[object Int16Array]',
      int32Tag$2 = '[object Int32Array]',
      uint8Tag$2 = '[object Uint8Array]',
      uint8ClampedTag$2 = '[object Uint8ClampedArray]',
      uint16Tag$2 = '[object Uint16Array]',
      uint32Tag$2 = '[object Uint32Array]';
  /** Used to identify `toStringTag` values supported by `_.clone`. */

  var cloneableTags = {};
  cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] = cloneableTags[boolTag$2] = cloneableTags[dateTag$2] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$2] = cloneableTags[setTag$4] = cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
  cloneableTags[errorTag$1] = cloneableTags[funcTag$2] = cloneableTags[weakMapTag$2] = false;
  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */

  function baseClone(value, bitmask, customizer, key, object, stack) {
    var result,
        isDeep = bitmask & CLONE_DEEP_FLAG,
        isFlat = bitmask & CLONE_FLAT_FLAG,
        isFull = bitmask & CLONE_SYMBOLS_FLAG;

    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }

    if (result !== undefined) {
      return result;
    }

    if (!isObject_1(value)) {
      return value;
    }

    var isArr = isArray_1(value);

    if (isArr) {
      result = _initCloneArray(value);

      if (!isDeep) {
        return _copyArray(value, result);
      }
    } else {
      var tag = _getTag(value),
          isFunc = tag == funcTag$2 || tag == genTag$1;

      if (isBuffer_1(value)) {
        return _cloneBuffer(value, isDeep);
      }

      if (tag == objectTag$2 || tag == argsTag$2 || isFunc && !object) {
        result = isFlat || isFunc ? {} : _initCloneObject(value);

        if (!isDeep) {
          return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }

        result = _initCloneByTag(value, tag, isDeep);
      }
    } // Check for circular references and return its corresponding clone.


    stack || (stack = new _Stack());
    var stacked = stack.get(value);

    if (stacked) {
      return stacked;
    }

    stack.set(value, result);

    if (isSet_1(value)) {
      value.forEach(function (subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
      });
    } else if (isMap_1(value)) {
      value.forEach(function (subValue, key) {
        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
    }

    var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn : keys_1;
    var props = isArr ? undefined : keysFunc(value);
    _arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      } // Recursively populate clone (susceptible to call stack limits).


      _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
    return result;
  }

  var _baseClone = baseClone;

  /** Used to compose bitmasks for cloning. */

  var CLONE_DEEP_FLAG$1 = 1,
      CLONE_SYMBOLS_FLAG$1 = 4;
  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */

  function cloneDeep(value) {
    return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
  }

  var cloneDeep_1 = cloneDeep;

  /** `Object#toString` result references. */

  var stringTag$3 = '[object String]';
  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a string, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */

  function isString(value) {
    return typeof value == 'string' || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$3;
  }

  var isString_1 = isString;

  /**
   * Array.prototype.includes
   * Native Support in:
   *   Chrome 47+
   *   Edge 14+
   *   IE:  -not supported-
   *   Firefox 43+
   *   Opera 34+
   *   Safari 9+
   *
   *   Android Browser
   *   Chrome for Android
   *   Edge Mobile: 14+
   *   IE Mobile: --- not supported ---
   *   Firefox for Android: 43+
   *   Opera Android: 34+
   *   iOS Safari: 9+
   *
   * @param {Array} array
   * @param {*} value
   * @return {boolean}
   * @private
   */

  /**
   * Is the object of a given class
   * @param {*} value
   * @param {string} className
   */

  var isObjectClass = function isObjectClass(value, className) {
    return Object.prototype.toString.call(value) === "[object ".concat(className, "]");
  };
  /**
   * Is String
   * @param {*} value
   */

  var isString$1 = function isString(value) {
    return typeof value === 'string';
  };
  /**
   * Is the value a number: (NaN, -NaN, Infinity, -Infinity, or Finite(Float)
   * You probably don't want to use this function.
   */

  var isNumber = function isNumber(value) {
    return typeof value === 'number';
  };
  /**
   * Is the value a date
   * @param {*} value
   */

  var isDate = function isDate(value) {
    return isObjectClass(value, 'Date');
  };
  /**
   * Is the value null or undefined
   * @param value
   */

  var isNullOrUndefined = function isNullOrUndefined(value) {
    return value === null || value === undefined;
  };

  var CONSTANTS = {};
  /**
   * Kamaji event information object
   * @typedef {Object} kamajiEvent
   * @property {number} eventType Value for eventType field (required by all events).
   * @property {String} endpoint Endpoint for each event type: <base URL>/event/*
   */

  /**
   * Constants for Kamaji Events
   * @enum {kamajiEvent}
   */

  CONSTANTS.EVENT = {
    LoggedIn: {
      eventType: 1,
      endpoint: 'login'
    },
    Click: {
      eventType: 2,
      endpoint: 'click'
    },
    Search: {
      eventType: 3,
      endpoint: 'search'
    },
    Cart: {
      eventType: 4,
      endpoint: 'cart'
    },
    Purchase: {
      eventType: 5,
      endpoint: 'purchase'
    },
    LoggedOut: {
      eventType: 6,
      endpoint: 'logout'
    },
    PromotionAd: {
      eventType: 7,
      endpoint: 'adPromotion'
    },
    VideoPreview: {
      eventType: 8,
      endpoint: 'video/preview'
    },
    Recommend: {
      eventType: 9,
      endpoint: 'recommendation'
    },
    Download: {
      eventType: 10,
      endpoint: 'download'
    },
    VideoStream: {
      eventType: 11,
      endpoint: 'video/stream'
    },
    PageView: {
      eventType: 12,
      endpoint: 'pageView'
    },
    Voucher: {
      eventType: 13,
      endpoint: 'voucher'
    },
    Navigation: {
      eventType: 14
    },
    Interact: {
      eventType: 15,
      endpoint: 'interact'
    },
    ActivityPost: {
      eventType: 16,
      endpoint: 'activity'
    },
    Reg: {
      eventType: 17,
      endpoint: 'reg'
    },
    Impression: {
      eventType: 18,
      endpoint: 'impression'
    },
    Cam: {
      eventType: 19,
      endpoint: 'cam'
    },
    Optimus: {
      eventType: 20,
      endpoint: 'optimus'
    },
    CommunityModify: {
      eventType: 21,
      endpoint: 'community/modify'
    },
    CommunityUser: {
      eventType: 22,
      endpoint: 'community/user'
    },
    CommunityPost: {
      eventType: 23,
      endpoint: 'community/post'
    },
    List: {
      eventType: 24,
      endpoint: 'list'
    },
    MessagePost: {
      eventType: 28,
      endpoint: 'messagepost'
    },
    Startup: {
      eventType: 30,
      endpoint: 'startup'
    },
    Error: {
      eventType: 99,
      endpoint: 'error'
    },
    UserFacingError: {
      eventType: 100,
      endpoint: 'errorUver'
    }
  };
  /**
   * Values for deviceType field (required by all events).
   * @enum {number}
   */

  CONSTANTS.DEVICE_TYPE = {
    WEB: 201,
    PS3: 202,
    VITA: 203,
    HE: 204,
    XPERIA: 205,
    PS4: 206,
    PS4K: 206,
    WEB_MOBILE: 207,
    MWEB: 207,
    COMP_APP: 208,
    PSNOW_BETA: 209,
    SEN_TV: 210,
    TV: 210,
    FRIEND_APP: 211,
    PSNOW_VITA: 212,
    PSNOW_VITA_TV: 213,
    AAVU: 214,
    IPHONE_VIDEO: 215,
    PSNOW_CE: 216,
    PSNOW_SUBSCRIPTION: 217,
    PSNOW_PC: 222,
    PS4_SOCIAL: 223,
    PS4_REGCAM: 224,
    SOCIAL_WEB_PC: 225,
    SOCIAL_WEB_MOBILE: 226,
    SOCIAL_TOOLBAR_PC: 227,
    SOCIAL_TOOLBAR_MOBILE: 228,
    WEB_STORE_PC: 229,
    WEB_STORE_MOBILE: 230,
    PODRACER: 233,
    PS4_VIDEO: 236,
    ANDROID_TV: 237,
    ANDROID: 238,
    IOS: 239,
    ROKU: 240,
    FIRE_TV: 241,
    APPLE_TV: 242,
    CHROMECAST: 243
  };
  /**
   * Values for impact field (required by user-visible error events).
   * @enum {number}
   */

  CONSTANTS.IMPACT = {
    CRITICAL: 0,
    MAJOR: 1,
    MINOR: 2,
    NORMAL: 3,
    INFO: 4
  };

  var severity_to_impact = function severity_to_impact(severity, pluginName) {
    var SEVERITY = typeof severity === 'string' ? severity.toUpperCase() : severity;

    if (typeof SEVERITY === 'undefined') {
      return;
    }

    if (SEVERITY in CONSTANTS.IMPACT) {
      return CONSTANTS.IMPACT[SEVERITY];
    } else {
      throw new Error("Severity '".concat(severity, "' not supported by ").concat(pluginName, " plugin"));
    }
  };

  CONSTANTS.URL = {
    EVENT: 'https://event.api.{{env}}.km.playstation.net/event/'
  };

  function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

  var _buildPayload = function _buildPayload(callbacks, context) {
    var reducer = function reducer(result, key) {
      var response = callbacks[key](context);

      if (response !== undefined) {
        // eslint-disable-next-line no-param-reassign
        result[key] = response;
      }

      return result;
    };

    return Object.keys(callbacks).reduce(reducer, {});
  };
  /**
   * Build the Kamaji Event Payload
   *
   * @param {kamaji~BuildPayloadContext}  context   IContext Information Object
   * @return {Object} payload
   */


  var buildPayload = function buildPayload(context) {
    if (context === undefined) {
      return false;
    }

    var event = context.event,
        _context$payload = context.payload,
        payload = _context$payload === void 0 ? {} : _context$payload,
        properties = context.properties,
        validations = context.validations;

    if (!properties) {
      context.logger.warning('[KamajiPlugin] Unsupported event type.', {
        eventType: event.type,
        pluginName: context.pluginName
      });
      return false;
    }

    if (!validations[String(event.type)](context)) {
      return false;
    }

    _extends(payload, _buildPayload(properties, context));

    return payload;
  };

  var accessToken = function accessToken() {
    return undefined;
  };

  var deviceId = function deviceId(_ref) {
    var environment = _ref.environment;
    return environment.deviceId;
  };

  var accountId = function accountId(_ref) {
    var environment = _ref.environment;
    return environment.visitorId || deviceId({
      environment: environment
    });
  };

  var INVALID_CHARS = ['&quot;', '&rsquo;', '"', '&', '\'', '#', '\\$', '%', '\\^', '\\*', '!', '<', '>', '~', ';', '\\?', 'â„¢', 'Â®', 'Â©', ':'];
  var INVALID_CHARS_REGEX = new RegExp("(".concat(INVALID_CHARS.join('|'), ")"), 'g');

  var Utils =
  /*#__PURE__*/
  function () {
    function Utils() {}

    /**
     * truncateJsonToString will go through a JSON literal and truncate each
     * values until the stringified JSON length is less or equal to maxLength.
     * Truncation logic will truncate as many string, Array and Object as
     * necessary, maintaining at least maxValueLength characters of each,
     * to meet the maxLength requirement.
     *
     * @param  {JSON}    [MODIFIED] json is a JSON literal
     * @param  {integer} maxLength is the maximum desired length
     *                    for the JSON string in output
     * @param  {integer} maxValueLength is the maximum desired length
     *                    for a value that needs to be truncated
     * @return {string} return JSON as string that is truncated
     */
    Utils.truncateJsonToString = function truncateJsonToString(json, maxLength, maxValueLength) {
      if (!json) {
        return '';
      }

      var tempString = JSON.stringify(json);

      if (tempString.length <= maxLength) {
        return tempString;
      } // If the caller wants to keep maxValueLength characters worth
      // of data, and on top of that see an ellipsis, then the minimum
      // length to which we can cut down the string is as follows.


      var ellipsis = '...';
      var minTruncatedLength = maxValueLength + ellipsis.length;
      var props = Object.keys(json).map(function (key) {
        var value = json[key];
        var output;

        if (isNumber(value) || typeof value === 'undefined') {
          // consider numbers to have zero length so we never convert them to strings.
          // same with undefined values, because json conversion drops properties
          // whose values are undefined.
          output = '';
        } else if (isString$1(value)) {
          output = value;
        } else {
          // cast everything else to string.
          output = JSON.stringify(value);
        }

        return {
          key: key,
          value: value,
          output: output
        };
      }); // Loop and truncate until we reach desired length.

      while (tempString.length > maxLength && props.length > 0) {
        props.sort(function (a, b) {
          return b.output.length - a.output.length;
        }); // the longest value will be at the beginning of the array.

        var longest = props[0];

        if (longest.output.length <= minTruncatedLength) {
          // wow, we must have a lot of little properties!
          // finding and truncating big offenders isn't going to work.
          break;
        } // just remember, if a property is not (yet) a string, do it now and
        // then recompute the output json because the requirement to escape
        // any '"' chars that are present will increase its overall length.


        if (!isString$1(longest.value)) {
          longest.value = longest.output; // eslint-disable-next-line no-param-reassign

          json[longest.key] = longest.value;
          tempString = JSON.stringify(json);
        } // compute a new, truncated length for the longest property value.
        // choose whichever is the biggest of
        //  - only what we need to lop off to make the entire output json <= maxLength
        //  - no less than half it's current length
        //  - no less than the minimum permitted output length


        var truncatedLength = Math.max(longest.value.length - (tempString.length - maxLength), Math.floor(longest.value.length / 2), minTruncatedLength);
        longest.value = longest.value.substring(0, truncatedLength - ellipsis.length) + ellipsis;
        longest.output = longest.value; // eslint-disable-next-line no-param-reassign

        json[longest.key] = longest.value;
        tempString = JSON.stringify(json);
      }

      return tempString;
    }
    /**
     * String sanitization function: removes characters from INVALID_CHARS_REGEX
     * as well as leading/trailing whitespaces. It will also lowercase the output.
     *
     * @param      {string}  input        The input string to sanitize
     * @param      {RegExp}   otherChars   Other characters to filter
     * @param      {boolean} toLowerCase  Should sanitized string be lowercased?
     * @return     {string}  Returns sanitized string
     */
    ;

    Utils.cleanUpString = function cleanUpString(input) {
      var otherChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var toLowerCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!input) {
        return '';
      }

      var inputString = String(input);
      inputString = inputString.replace(INVALID_CHARS_REGEX, '');

      if (otherChars) {
        inputString = inputString.replace(otherChars, '');
      }

      inputString = inputString.replace(/[ ]{2,}/, ' ').replace(/\s?:\s?/g, ':').replace(/(^\s+|\s+$)/g, '');
      return toLowerCase ? inputString.toLowerCase() : inputString;
    }
    /**
     * Location string sanitization function: takes a location string and
     * sanitize each segment.
     *
     * @param      {string}  input   The location input string to sanitize
     * @return     {string}  Returns sanitized location string
     */
    ;

    Utils.cleanUpLocationString = function cleanUpLocationString(input) {
      var locationSegments = [];
      var tmp = input.split(':');

      for (var i = 0; i < tmp.length; i += 1) {
        if (tmp[i]) {
          locationSegments.push(Utils.cleanUpString(tmp[i]));
        }
      }

      return locationSegments.join(':');
    };

    return Utils;
  }();

  var appName = function appName(_ref) {
    var event = _ref.event,
        environment = _ref.environment;
    return Utils.cleanUpString(event.overrideAppName || environment.appName);
  };

  var buildVersion = function buildVersion(_ref) {
    var event = _ref.event,
        environment = _ref.environment,
        gctVersion = _ref.gctVersion;
    var bv = Utils.cleanUpString(event.overrideBuildVersion || environment.buildVersion);
    return "BuildNum:".concat(appName({
      event: event,
      environment: environment
    }), "|").concat(bv, "|gct_v").concat(gctVersion);
  };

  var isValidLocale = function isValidLocale(target) {
    return /^[a-z]{2}_(?:[a-z]{2}){1,2}(?:_[a-z]{2})?$/i.test(target);
  };

  var country = function country(_ref) {
    var environment = _ref.environment;
    return isString$1(environment.locale) && isValidLocale(environment.locale) ? environment.locale.substr(3, 2) : 'US';
  };

  var deviceType = function deviceType(_ref) {
    var environment = _ref.environment,
        config = _ref.config,
        pluginName = _ref.pluginName,
        logger = _ref.logger;
    var deviceType;
    var deviceKey = environment.deviceType.toUpperCase();

    if (config.overrideDeviceType) {
      deviceType = config.overrideDeviceType;
    } else if (CONSTANTS.DEVICE_TYPE[deviceKey]) {
      deviceType = CONSTANTS.DEVICE_TYPE[deviceKey];
    } else {
      logger.warning('[Kamaji] Unknown deviceType provided', {
        pluginName: pluginName,
        deviceType: environment.deviceType
      });
      return false;
    }

    return deviceType;
  };

  var mapEvent = function mapEvent(type, EVENT_CONSTANTS) {
    var event = EVENT_CONSTANTS[type];

    if (event === undefined) {
      throw new TypeError("invalid type: ".concat(JSON.stringify(type)));
    }

    return event.eventType;
  };

  var eventType = function eventType(_ref) {
    var event = _ref.event,
        _ref$EVENT_CONSTANTS = _ref.EVENT_CONSTANTS,
        EVENT_CONSTANTS = _ref$EVENT_CONSTANTS === void 0 ? {} : _ref$EVENT_CONSTANTS;
    return mapEvent(event.type, EVENT_CONSTANTS);
  };

  var ipAddress = function ipAddress() {
    return '';
  };

  var shortTermId = function shortTermId(_ref) {
    var event = _ref.event;
    return event.shortTermId;
  };

  var time = function time(_ref) {
    var event = _ref.event;
    var time = isDate(event.time) && !isNaN(event.time.valueOf()) ? event.time : new Date();
    return time.toISOString();
  };

  /**
   * Default Property Set
   * These are set for all Event Types
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  var defaultProperties = {
    // cust01,
    // cust02,
    // cust03,
    // cust04,
    // cust05,
    // cust06,
    // cust07,
    // cust08,
    // cust09,
    // cust10,
    // etsId ,
    // hydrateAccountId,
    accessToken: accessToken,
    accountId: accountId,
    appName: appName,
    buildVersion: buildVersion,
    deviceId: deviceId,
    shortTermId: shortTermId,
    deviceType: deviceType,
    eventType: eventType,
    ipAddress: ipAddress,
    time: time,
    storeCountryCode: country
  };

  var currentPageUrl = function currentPageUrl(_ref) {
    var event = _ref.event;
    return event.url;
  };

  var deeplink = function deeplink(_ref) {
    var event = _ref.event;
    return event.deeplink;
  };

  var location = function location(_ref) {
    var event = _ref.event;
    return event.location;
  };

  var locationType = function locationType(_ref) {
    var event = _ref.event;
    return event.locationType;
  };

  var plusUser = function plusUser(_ref) {
    var environment = _ref.environment;
    return environment.isPlusUser;
  };

  var privacySettings = function privacySettings(_ref) {
    var environment = _ref.environment;
    return environment.platformPrivacyWs1;
  };

  var startupContext = function startupContext(_ref) {
    var event = _ref.event;
    return event.startupContext;
  };

  var startupType = function startupType(_ref) {
    var event = _ref.event;
    return event.startupType;
  };

  var userAgent = function userAgent() {
    return typeof navigator !== 'undefined' && navigator && navigator.userAgent || undefined;
  };

  var validate = function validate() {
    return true;
  };
  var startUp = {
    currentPageUrl: currentPageUrl,
    deeplink: deeplink,
    location: location,
    locationType: locationType,
    plusUser: plusUser,
    privacySettings: privacySettings,
    startupContext: startupContext,
    startupType: startupType,
    userAgent: userAgent
  };

  var MAX_UVER_DATA_LENGTH = 1536;
  var MAX_UVER_DATA_VALUE_LENGTH = 15;
  var data = function data(_ref) {
    var event = _ref.event;
    var result = {
      errorDesc: event.description,
      errorUrl: event.apiUrl,
      errorStack: event.stack
    }; // if error contains meta data, add that to result

    if (event.errorMetadata) {
      Object.keys(event.errorMetadata).filter(function (prop) {
        return !result[prop];
      }).forEach(function (prop) {
        result[prop] = event.errorMetadata[prop];
      });
    }

    return Utils.truncateJsonToString(result, MAX_UVER_DATA_LENGTH, MAX_UVER_DATA_VALUE_LENGTH);
  };

  var errorCode = function errorCode(_ref) {
    var event = _ref.event,
        logger = _ref.logger;
    var result;

    if (typeof event.error === 'undefined') {
      logger.warning('event.error is missing');
      return false;
    }

    if (typeof event.code === 'undefined') {
      logger.warning('event.code is missing');
      return false;
    }

    result = parseInt(event.code, 10); // isNaN([]) = isNaN(null) = false.  Number.isNaN may require polyfill.
    // eslint-disable-next-line no-restricted-globals

    if (isNaN(result)) {
      logger.warning("event.code is not a number: ".concat(event.code), {
        code: event.code
      });
      result = null;
    }

    return result;
  };

  var expId = function expId() {
    return '';
  };

  var MAX_UVER_FEATURE_LENGTH = 16;
  var feature = function feature(_ref) {
    var logger = _ref.logger,
        _ref$locationSegments = _ref.locationSegments,
        locationSegments = _ref$locationSegments === void 0 ? [] : _ref$locationSegments;
    var result = locationSegments.slice(0, 2).join(':');

    if (result.length > MAX_UVER_FEATURE_LENGTH) {
      logger.warning("Length of feature exceeds ".concat(MAX_UVER_FEATURE_LENGTH, " chars limit for: '").concat(result, "'"));
      result = result.substr(0, MAX_UVER_FEATURE_LENGTH);
    }

    return result;
  };

  var impact = function impact(_ref) {
    var event = _ref.event,
        pluginName = _ref.pluginName;
    return severity_to_impact(event.severity, pluginName);
  };

  var MAX_UVER_MAJOR_LENGTH = 16;
  var major = function major(_ref) {
    var logger = _ref.logger,
        _ref$locationSegments = _ref.locationSegments,
        locationSegments = _ref$locationSegments === void 0 ? [] : _ref$locationSegments;
    var result = locationSegments.slice(2, 3).join(':');

    if (result.length > MAX_UVER_MAJOR_LENGTH) {
      logger.warning("Length of major exceeds ".concat(MAX_UVER_MAJOR_LENGTH, " chars limit for: '").concat(result, "'"));
      result = result.substr(0, MAX_UVER_MAJOR_LENGTH);
    }

    return result;
  };

  var MAX_UVER_MINOR_LENGTH = 32;
  var minor = function minor(_ref) {
    var event = _ref.event,
        logger = _ref.logger;
    var result = Utils.cleanUpString(event.error);

    if (result.length > MAX_UVER_MINOR_LENGTH) {
      logger.warning('Event.minor exceeds maximum character limit.', {
        maxLength: MAX_UVER_MINOR_LENGTH,
        value: result
      });
      result = result.substr(0, MAX_UVER_MINOR_LENGTH);
    }

    return result;
  };

  var validate$1 = function validate(_ref) {
    var event = _ref.event,
        logger = _ref.logger;

    if (event.type === 'UserFacingError') {
      if (typeof event.error === 'undefined') {
        logger.warning('event.error is missing');
        return false;
      }

      if (typeof event.code === 'undefined') {
        logger.warning('event.code is missing');
        return false;
      }
    }

    return true;
  };
  var userFacingError = {
    data: data,
    errorCode: errorCode,
    expId: expId,
    feature: feature,
    impact: impact,
    major: major,
    minor: minor
  };

  function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
  var validations = {
    Startup: validate,
    UserFacingError: validate$1
  };
  var properties = {
    Startup: _extends$1({}, defaultProperties, startUp),
    UserFacingError: _extends$1({}, defaultProperties, userFacingError)
  };

  var locationSegments = function locationSegments(location) {
    if (!location) {
      return [];
    }

    return location.split(':').filter(function (str) {
      return str;
    }).map(function (str) {
      return Utils.cleanUpString(str);
    });
  };

  var generateXhrBody = function generateXhrBody(payload) {
    return payload ? "[".concat(JSON.stringify(payload), "]") : null;
  };

  var generateXhrHeaders = function generateXhrHeaders() {
    return {
      'Content-Type': 'application/json; charset=utf-8'
    };
  };

  /**
   * Appends a trailing slash if one is not present
   *
   * @private
   * @param  {string} url The url to append slash
   * @return {string}     The url with trailing slash
   */
  var appendTrailingSlash = (function (url) {
    if (!url) {
      return '/';
    }

    if (url.substr(-1) === '/') {
      return url;
    }

    return "".concat(url, "/");
  });

  var generateXhrUrl = function generateXhrUrl(config, endPoint) {
    var eventUrl = config.eventUrl || CONSTANTS.URL.EVENT;
    var baseUrl = eventUrl.replace('{{env}}', config.env || 'e1-np');
    return appendTrailingSlash(baseUrl) + endPoint;
  };

  var getConstantByEventType = function getConstantByEventType(eventType, EVENT_CONSTANTS) {
    var eventKey = Object.keys(EVENT_CONSTANTS).find(function (key) {
      return EVENT_CONSTANTS[key].eventType === eventType;
    });

    if (typeof eventKey === 'undefined') {
      return {};
    }

    return EVENT_CONSTANTS[eventKey];
  };

  var NullLogger =
  /*#__PURE__*/
  function () {
    function NullLogger() {}

    var _proto = NullLogger.prototype;

    _proto.emergency = function emergency() {};

    _proto.alert = function alert() {};

    _proto.critical = function critical() {};

    _proto.error = function error() {};

    _proto.warning = function warning() {};

    _proto.notice = function notice() {};

    _proto.info = function info() {};

    _proto.debug = function debug() {};

    _proto.log = function log() {};

    return NullLogger;
  }();

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var BasePlugin =
  /*#__PURE__*/
  function () {
    /**
     * Base plugin constructor
     *
     * @param      {json}    [environment]  The environment configuration (e.g. telemetry's config.env)
     * @param      {json}    [config]       The plugin configuration (e.g. telemetry's config.plugins)
     * @param      {string}  pluginName   Name of the plugin - this is used for logging (e.g. 'Foo SDK' or 'Bar API')
     */
    function BasePlugin(environment, config, pluginName, serviceLocator) {
      /*
       * Migration Plan:
       *   Any plugin using the legacy loader will have the default this.logger injected into the config
       *   through the internal use `this.__logger` key.
       *
       *   Long term plan is to simply ditch the BasePlugin class entirely.
       *   All plugins will be required to implement `dispatch(_, request)`.
       *   All plugins will be expected to be instantiated by factory.
       *
       * The || NullLogger() is required so that plugin tests don't break for third parties.
       */
      this.environment = environment || {};
      this.config = config || {};
      this.__logger = this.config.__logger || new NullLogger();
      this.__pluginName = pluginName;
      this.__serviceLocator = serviceLocator;
      this._useAsyncInterface = false;
    }

    var _proto = BasePlugin.prototype;

    /**
     * Async Disptach
     * This should be a fully self contained request as the application and state may change interim
     * @param request
     * @returns {Promise.<Object>}
     * @private
     */
    _proto._dispatchAsync = function _dispatchAsync(request) {
      var _this = this;

      // TODO: Update to track Dispatch Result
      // TODO: Update to track Generated Messages
      // TODO: Update to interface with EventInspector
      // TODO: Update signature to return a DispatchResult instance, and not the payload
      var payloadPromise = Promise.resolve(null).then(function () {
        var payload = _this.buildPayloadAsync(request);

        if (!payload) {
          return payload;
        } // TODO: Remove this as a configuration parameter (use Null Dispatcher)


        if (!_this.config.dryRun) {
          _this.sendPayloadAsync(payload, request);
        }

        return payload;
      });
      return payloadPromise;
    }
    /**
     * Original Sync Dispatch
     * TODO: Add Deprecation
     * TODO: Figure Out Deprecation Path
     * @deprecated
     * @param event
     * @returns {*}
     * @private
     */
    ;

    _proto._dispatchSync = function _dispatchSync(event, request) {
      var payload = this.buildPayload(event, request);

      if (!payload) {
        // buildPayload should return false if an error occured when assembling
        // the payload or null if plugin should not send the event
        // In case of error (false) let's log it
        if (payload === false) {
          this.logger.warning("Could not build payload for ".concat(event.type, " event to ").concat(this.pluginName, "!"));
        }
      } else {
        this._logEventPayload(event, payload);

        if (this.config.dryRun) {
          this.logger.warning("Not sending ".concat(event.type, " event to ").concat(this.pluginName, " (dry run)"));
        } else {
          this.sendPayload(payload, event, request);
        }
      }

      return this.config.dryRun ? null : payload;
    }
    /**
     * Interface PluginDispatcher
     *
     * dispatch(event, Request)
     *   v1: Return Payload
     *   v+: Return Promise.<DispatchResponse>
     *
     *
     * Main dispatch function of the plugin. It will call the buildPayload
     * and sendPayload methods which must be defined by the plugin implementor.
     * It will take care of logging the payload before sending it and will
     * also handle dry run functionality.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    ;

    _proto.dispatch = function dispatch(event, request) {
      if (this._useAsyncInterface) {
        return this._dispatchAsync(request);
      } // TODO: Warning!


      return this._dispatchSync(event, request);
    }
    /**
     * Logs a payload.
     * @private
     * @param      {object}  event   Event object from one of the supported event types
     * @param      {object}  payload  The payload
     */
    ;

    _proto._logEventPayload = function _logEventPayload(event, payload) {
      var eventType = event && event.type || 'Unknown';
      this.logger.debug("".concat(this.pluginName, " ").concat(eventType, " Sending payload."), {
        payload: payload
      });
    }
    /**
     * Builds a payload to be sent to the plugin backend API or SDK. The method
     * should be implemented by the plugin author and its return value will be
     * passed to sendPayload() method. Return null if plugin should not sent the
     * event and return false if there is an error building the payload.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     * @return     {object}  Payload to be sent to backend API or SDK via sendPayload()
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayload = function buildPayload(event, request) {
      this.logger.warning("".concat(this.constructor.name, ".buildPayload() is not implemented by plugin!"));
      return {};
    } // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayloadAsync = function buildPayloadAsync(request) {
      throw new Error('Method buildPayloadAsync is abstract.');
    }
    /**
     * Sends a payload to backend API or SDK. The payload object should be generated
     * by buildPayload() method. This method should be implemented by the plugin author.
     *
     * @param      {object}  payload Payload generated by buildPayload()
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayload = function sendPayload(payload, event, request) {
      this.logger.warning("".concat(this.constructor.name, ".sendPayload() is not implemented by plugin!"));
    }
    /**
     * @param {Object} payload
     * @param {Object} request
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayloadAsync = function sendPayloadAsync(payload, request) {
      throw new Error('Method sendPayloadAsync is abstract.');
    };

    _createClass(BasePlugin, [{
      key: "pluginName",
      get: function get() {
        return this.__pluginName;
      }
    }, {
      key: "serviceLocator",
      get: function get() {
        // TODO: Deprecate Use
        return this.__serviceLocator;
      }
    }, {
      key: "logger",
      get: function get() {
        return this.__logger;
      }
    }]);

    return BasePlugin;
  }();

  function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * This plugin implements user facing errors for Kamaji
   * It can be subclassed to support additional event types
   *
   * @class KamajiPlugin
   * @extends BasePlugin
   *
   * @param {Object} config
   * @param {String} config.env               - (optional) environment, needed to generate default eventUrl, defaults to 'e1-np'
   * @param {String} config.eventUrl          - (optional) events base url which overrides the default eventUrl
   * @param {Number} config.batchLimit        - (reserved), currently not used
   * @param {Number} config.transmitInterval  - (reserved), currently not used
   */

  var KamajiPlugin =
  /*#__PURE__*/
  function (_BasePlugin) {
    _inheritsLoose(KamajiPlugin, _BasePlugin);

    function KamajiPlugin(environment, config, pluginName, serviceLocator) {
      var _this;

      _this = _BasePlugin.call(this, environment, config, pluginName, serviceLocator) || this;
      _this.properties = _extends$2({}, properties);
      _this.validations = _extends$2({}, validations);
      _this.eventConstants = _extends$2({}, CONSTANTS.EVENT);
      _this._xhr = config.xhr;

      var extendProperties = function extendProperties(key, payload, validation) {
        var payloadProperties = _this.properties[key];

        if (payloadProperties === undefined) {
          _this.properties[key] = _extends$2({}, payload, defaultProperties);
          _this.validations[key] = validation;
        } else {
          _this.logger.warn("kamaji: Cannot extend properties, key ".concat(key, " already exists."));
        }
      };

      Object.keys(_this.config.customEventsDefinition || {}).forEach(function (key) {
        var _this$config$customEv = _this.config.customEventsDefinition[key],
            validate = _this$config$customEv.validate,
            eventType = _this$config$customEv.eventType,
            batchName = _this$config$customEv.batchName,
            endpoint = _this$config$customEv.endpoint,
            sendImmediately = _this$config$customEv.sendImmediately,
            payload = _this$config$customEv.payload;

        var validation = validate || function () {
          return true;
        };

        if (_this.eventConstants[key] === undefined) {
          if (isNullOrUndefined(eventType) || isNullOrUndefined(batchName) || isNullOrUndefined(endpoint)) {
            _this.logger.warn("kamaji: customEventsDefinition missing properties for ".concat(key, "."));

            return;
          }

          _this.eventConstants[key] = {
            eventType: eventType,
            batchName: batchName,
            endpoint: endpoint,
            sendImmediately: sendImmediately
          };
        } else if (!(isNullOrUndefined(eventType) && isNullOrUndefined(batchName) && isNullOrUndefined(endpoint) && isNullOrUndefined(sendImmediately))) {
          _this.logger.warn('kamaji: The following properties are read-only (eventType, batchName, endpoint, sendImmediately).');
        }

        if (isNullOrUndefined(payload)) {
          _this.logger.warn("kamaji: customEventsDefinition missing payload for ".concat(key, "."));

          return;
        }

        extendProperties(key, payload, validation);
      });
      return _this;
    }
    /**
     * Creates a dispatchable payload
     *
     * @param {UserFacingError} event
     *   Supported Properties:
     *   {string} location       Where in the UI did the error occur?
     *   {string} error          Error type is a short name describing the error
     *   {integer} code          Error code is typically an HTTP status error code or similar
     *   {enum} severity         Error severity is one of Constants.SEVERITIES
     *   {mixed} [description]   Error description is some additional description for the given error
     *   {string} [apiUrl]       API endpoint which caused the error if applicable -
     *   {mixed} [stack]         Optional, the stack trace for the error
     *   {mixed} [errorMetadata] Optional, a JSON of key/value pairs for additional context related to the error
     *
     */


    var _proto = KamajiPlugin.prototype;

    _proto.buildPayload = function buildPayload$1(_, request) {
      var event = request.event,
          gctVersion = request.gctVersion;
      var eventProperties = this.properties[String(event.type)];

      if (!eventProperties) {
        this.logger.warning('[KamajiPlugin] Unsupported event type.', {
          eventType: event.type,
          pluginName: this.pluginName
        });
        return false;
      }
      /**
       * @typedef {Object} kamaji~BuildPayloadContext
       * @property {Object}                 config            Plugin Configuration
       * @property {Object}                 event             Event Object
       * @property {string[]}               locationSegments  a split of location using colon
       * @property {string}                 gctVersion        GCT Version
       * @property {Logger}                 logger            Logger
       * @property {Object}                 payload           Current state of the payload
       * @property {string}                 pluginName        Plugin Name
       */

      /**
       * @type {kamaji~BuildPayloadContext}
       */


      var context = {
        event: event,
        config: this.config,
        environment: this.environment,
        gctVersion: gctVersion,
        locationSegments: locationSegments(event.location),
        logger: this.logger,
        payload: {},
        pluginName: this.pluginName,
        validations: this.validations,
        properties: eventProperties,
        EVENT_CONSTANTS: this.eventConstants
      };
      return buildPayload(context);
    };

    _proto.sendPayload = function sendPayload(payload, _, _ref) {
      var config = _ref.config;
      var eventType = payload.eventType;
      var eventInfo = getConstantByEventType(eventType, this.eventConstants);
      var url = generateXhrUrl(config, eventInfo.endpoint);
      var headers = generateXhrHeaders();
      var body = generateXhrBody(payload);

      this._xhr('POST', url, headers, body); // callback

    };

    return KamajiPlugin;
  }(BasePlugin);

  var resolveXHR = (function (container, config) {
    var xhrKey = config.xhr;
    var serviceKey = xhrKey && isString$1(config.xhr) ? "/network/".concat(config.xhr) : '/network/xhrInterface';
    return container.get(serviceKey);
  });

  function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
  var PLUGIN_ID = 'kamaji';
  /**
   * @param {ContainerInterface} container
   */

  var kamajiPluginFactory = (function (container) {
    var globalConfig = container.get('config');
    var kamajiConfig = (globalConfig.plugins || {})[PLUGIN_ID] || {};

    var pluginConfig = _extends$3({}, kamajiConfig); // Support global dryRun setting


    if (globalConfig.dryRun === true) {
      pluginConfig.dryRun = true;
    }

    pluginConfig.xhr = resolveXHR(container, kamajiConfig);
    pluginConfig.__logger = container.get('Logger'); // Filtered Environment

    /** @var {TelemetryService} telemetryService */

    var telemetryService = container.get('telemetryService'); // TODO: This needs to go, not going to be available much longer

    var globalEnv = telemetryService.filteredEnvironment;
    return new KamajiPlugin(globalEnv, pluginConfig, PLUGIN_ID, container);
  });

  function _typeof$6(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }
  var clairvoyance = createCommonjsModule(function (module, exports) {
    (function (f) {
      {
        module.exports = f();
      }
    })(function () {
      return function e(t, n, r) {
        function s(o, u) {
          if (!n[o]) {
            if (!t[o]) {
              var a = typeof commonjsRequire == "function" && commonjsRequire;
              if (!u && a) return a(o, !0);
              if (i) return i(o, !0);
              var f = new Error("Cannot find module '" + o + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }

            var l = n[o] = {
              exports: {}
            };
            t[o][0].call(l.exports, function (e) {
              var n = t[o][1][e];
              return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
          }

          return n[o].exports;
        }

        var i = typeof commonjsRequire == "function" && commonjsRequire;

        for (var o = 0; o < r.length; o++) {
          s(r[o]);
        }

        return s;
      }({
        1: [function (require, module, exports) {
          /**
           * Clairvoyance JS Client Library
           *
           * Clairvoyance is a timing and navigation telemetry reporting system used by EXDG clients such as Chihiro, Valkyrie, Big3 Apps, Communities, Phoenix and Swordfish.
           *
           * Each instrumented passage of code (e.g. a page turn, an external request, user dwell) is associated with a Clairvoyance "metric".
           * Clairvoyance maintains a central repository of registered metrics. The repository of metrics maps an opaque metric ID (sent on
           * the wire with each metric event) to a descriptive metric "namespace" (used by Clairvoyance reporting tools) and a Javascript
           * variable name (used by instrumented clients).
           */
          // ******* BEGIN PRIVATE UTILITY FUNCTIONS ******** //
          function _str2bytes(str) {
            var map = Array.prototype.map;
            var codes = map.call(str, function (x) {
              return x.charCodeAt(0);
            });
            var buffer = new ArrayBuffer(codes.length);
            var uint8 = new Uint8Array(buffer);

            if (codes.length) {
              uint8.set(codes);
            }

            return buffer;
          }

          function _encodeUtf8(s) {
            return unescape(encodeURIComponent(s || ''));
          }

          function _compareMetric(m1, m2) {
            if (m1.startTimestamp < m2.startTimestamp) {
              return -1;
            }

            if (m1.startTimestamp > m2.startTimestamp) {
              return 1;
            }

            if (m1.latency < m2.latency) {
              return -1;
            }

            if (m1.latency > m2.latency) {
              return 1;
            }

            return 0;
          }

          function _copyBytes(dest, destPos, src) {
            if (dest.byteLength < destPos + src.byteLength) {
              throw new Error('_copyBytes() insufficient space remaining in dest for elements in src');
            }

            var d = new Uint8Array(dest);
            var s = new Uint8Array(src);

            for (var i = 0; i < s.length; i++) {
              d[i + destPos] = s[i];
            }
          }
          /**
           * Default XHR transmission implementation
           * Used by Clairvoyance when one is not supplied to Clairvoyance.initialize
           * @param {object}   options
           * @param {string}   options.url           Request URL
           * @param {boolean}  [options.async=true]  Indicates if the request should be made asynchronously
           * @param {string}   [options.type='GET']  Request verb
           * @param {object}   [options.data]        Data included with the request
           * @param {function} [options.success]     Success callback
           * @param {function} [options.error]       Error callback
           * @param {number}   [options.timeout=0]   Number of milliseconds until the request's timeout is trigged
           * @param {object}   [options.headers]     Header collection key-value pair
           */


          function _defaultXhr(options) {
            var opts = {
              url: options.url
            };
            opts.async = options.async === undefined ? true : options.async;
            opts.type = options.type || 'GET';
            opts.headers = options.headers || {};
            opts.data = options.data || null;
            opts.timeout = ~~options.timeout;
            opts.success = typeof options.success === 'function' ? options.success : function () {};
            opts.error = typeof options.error === 'function' ? options.error : function () {};
            var xhr = new XMLHttpRequest();
            xhr.open(opts.type, opts.url, opts.async);
            xhr.timeout = opts.timeout;
            Object.keys(opts.headers).forEach(function (header) {
              xhr.setRequestHeader(header, opts.headers[header]);
            });

            xhr.onreadystatechange = function () {
              if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                  opts.success(xhr.responseText, xhr);
                } else {
                  opts.error(xhr.responseText, xhr);
                }
              }
            };

            xhr.send(opts.data);
          } // ******* END PRIVATE UTILITY FUNCTIONS ******** //


          function Clairvoyance() {}
          /**
           * @constant Number of bytes reserved to record an instrumentation
           * Value explained:
           * metric                (int, 4 bytes)
           * previous metric       (int, 4 bytes)
           * latency               (int, 4 bytes)
           * timeOffset            (int, 4 bytes)
           */


          Clairvoyance.prototype.BYTES_PER_METRIC = 16;
          /**
           * Clairvoyance protocol version (see also packetType field)
           */

          Clairvoyance.prototype.PROTOCOL_VERSION = 3;
          /**
           * @constant Session expiration represented in milliseconds
           */

          Clairvoyance.prototype.SESSION_EXPIRE_MS = 1000 * 60 * 30;
          /**
           * Initialize Clairvoyance
           *
           * @param {string}   deviceId      unique device id
           * @param {number}   buildVersion  integer representing build version
           * @param {object}   dataStore     this object need to support following methods:
           *                                  - saveSessionString(string)
           *                                  - getSessionString()
           * @param {string}   url           url of remote service to send data
           * @param {?}        accountId     @todo - documentation required from Rupinder
           * @param {function} [xhr]         xhr handler
           * @param {function} [afterInit]   Callback to be executed after initialization.
           */

          Clairvoyance.prototype.initialize = function (deviceIdOrOptionsObject, buildVersion, dataStore, url, accountId, xhr, afterInit) {
            if (deviceIdOrOptionsObject !== null && _typeof$6(deviceIdOrOptionsObject) === 'object') {
              this._initializeOptionsObject(deviceIdOrOptionsObject);
            } else {
              var options = {
                deviceId: deviceIdOrOptionsObject,
                buildVersion: buildVersion,
                dataStore: dataStore,
                accountId: accountId,
                url: url,
                xhr: xhr,
                afterInit: afterInit
              };

              this._initializeOptionsObject(options);
            }
          };

          Clairvoyance.prototype._initializeOptionsObject = function (options) {
            this.protocolVersion = this.PROTOCOL_VERSION;
            this.deviceId = options.deviceId;
            this.dataStore = options.dataStore;
            this.accountId = options.accountId;
            this.appName = options.appName;
            this.buildVersion = options.buildVersion;
            this.networkType = options.networkType;
            this.platformVersion = options.platformVersion;
            this.screenInfo = options.screenInfo;
            this.expId = options.expId;
            this.keyMap = {};
            this.url = options.url;
            this.expUrl = options.url.replace('/clairvoyance/', '/clairvoyance/exp/') + "?DeviceID=" + encodeURIComponent(options.deviceId || '');
            this.deviceIdBytes = _str2bytes(_encodeUtf8(options.deviceId));
            this.accountIdBytes = _str2bytes(_encodeUtf8(options.accountId));
            this.buildVersionBytes = _str2bytes(_encodeUtf8(options.buildVersion));
            this.expIdBytes = _str2bytes(_encodeUtf8(options.expId));
            this.appNameBytes = _str2bytes(_encodeUtf8(options.appName));
            this.networkTypeBytes = _str2bytes(_encodeUtf8(options.networkType));
            this.platformVersionBytes = _str2bytes(_encodeUtf8(options.platformVersion));
            this.screenInfoBytes = _str2bytes(_encodeUtf8(options.screenInfo));
            this.useExperimentalVersion31 = options.useExperimentalVersion31 || false;
            /**
             * version                (1 byte)    Int8Array.BYTES_PER_ELEMENT
             * packetType             (1 byte)    Int8Array.BYTES_PER_ELEMENT
             * sessionId              (8 bytes)   Float64Array.BYTES_PER_ELEMENT
             * sequence               (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * timestamp              (8 bytes)   Float64Array.BYTES_PER_ELEMENT
             * build version length   (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * build version          (variable)
             * deviceId length        (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * deviceId               (variable)
             * accountId length       (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * accountId              (variable)
             * expId Length           (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * expId                  (variable)
             * appName length         (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * appName                (variable)
             * networkTypelength      (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * networkType            (variable)
             * bootInfo Length        (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * bootInfo               (variable)
             * dataSizeGroup length   (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * dataSizeGroup          (variable)
             * platformVersion length (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * platformVersion        (variable)
             * screenInfo length      (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * screenInfo             (variable)
             */

            var bytesToSendHeader = Int8Array.BYTES_PER_ELEMENT + Int8Array.BYTES_PER_ELEMENT + Float64Array.BYTES_PER_ELEMENT + Int16Array.BYTES_PER_ELEMENT + Float64Array.BYTES_PER_ELEMENT + Int16Array.BYTES_PER_ELEMENT + this.buildVersionBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.deviceIdBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.accountIdBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.expIdBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.appNameBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.networkTypeBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.platformVersionBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + this.screenInfoBytes.byteLength;
            this.bytesToSendHeader = bytesToSendHeader;
            this.xhr = typeof options.xhr === 'function' ? options.xhr : _defaultXhr;

            function callback() {
              if (typeof options.afterInit === 'function') {
                options.afterInit();
              }
            }

            callback();
          };

          Clairvoyance.prototype._getSessionString = function () {
            var value = this.dataStore.getSessionString();

            if (!value) {
              var sessCreateTs = Date.now();
              var sessionId = Math.random();
              var sequence = -1; //sessionTimestamp,sessionId,sequence|previousMetric

              value = sessCreateTs + "," + sessionId + "," + sequence + "|-1";
              this.dataStore.saveSessionString(value);
            }

            return value;
          };
          /**
           * Start the clock for a given metric
           * @param {number} metric   the integer metric code
           */


          Clairvoyance.prototype.start = function (metric) {
            this.keyMap[metric] = Date.now();
          };
          /**
           * Stop the clock for a given metric
           * @param {number} metric   the integer metric code
           */


          Clairvoyance.prototype.stop = function (metric) {
            this.sendLatencyData(this, [{
              'metric': metric,
              'startTimestamp': this.keyMap[metric],
              'latency': Date.now() - this.keyMap[metric]
            }]);
            this.keyMap[metric] = null;
          };
          /**
           * Transmit latency data to the clairvoyance server
           * @param {object[]}  metrics     array of metrics information
           *                                each metric must adhere to:
           *                                { metric: <number>, startTimestamp: <number>, latency: <number> }
           * @param {function}  successFn   success callback function
           * @param {function}  failureFn   failure callback function
           */


          Clairvoyance.prototype.sendLatencyData = function (metrics, successFn, errorFn, bootInfo, dataSizeGroup) {
            var session = this._getSessionInfo();

            var packetType = this.useExperimentalVersion31 ? 1 : 0;

            var bootInfoBytesFromHeader = _str2bytes(_encodeUtf8(bootInfo));

            var dataSizeGroupBytes = _str2bytes(_encodeUtf8(dataSizeGroup));

            metrics = metrics.sort(_compareMetric).map(function (eachMetric) {
              // Metrics contain bootInfo and metricInfo only if apps implement Clairvoyance 3.1 protocol
              if (this.useExperimentalVersion31) {
                eachMetric.bootInfoBytes = eachMetric.bootInfo ? _str2bytes(_encodeUtf8(eachMetric.bootInfo)) : bootInfoBytesFromHeader;
                eachMetric.metricInfoBytes = _str2bytes(_encodeUtf8(eachMetric.metricInfo));
              }

              return eachMetric;
            }.bind(this));
            /**
             * dataSizeGroup length   (2 bytes)   Int16Array.BYTES_PER_ELEMENT
             * dataSizeGroup          (variable)
             */

            var bytesToSend = this.bytesToSendHeader + metrics.length * this.BYTES_PER_METRIC + dataSizeGroupBytes.byteLength + Int16Array.BYTES_PER_ELEMENT; // Append bootInfo and metricInfo byte lengths only if apps implement Clairvoyance 3.1 protocol

            if (this.useExperimentalVersion31) {
              metrics.forEach(function (metric) {
                bytesToSend += Int16Array.BYTES_PER_ELEMENT + metric.bootInfoBytes.byteLength + Int16Array.BYTES_PER_ELEMENT + metric.metricInfoBytes.byteLength;
              }.bind(this));
            } else {
              /**
               * bootInfo length        (2 bytes,   if using Clairovoyance 3.0) Int16Array.BYTES_PER_ELEMENT
               * bootInfo               (variable,  if using Clairovoyance 3.0)
               */
              bytesToSend += bootInfoBytesFromHeader.byteLength + Int16Array.BYTES_PER_ELEMENT;
            }

            var timestamp = metrics[0].startTimestamp;
            var buffer = new ArrayBuffer(bytesToSend);
            var view = new DataView(buffer);
            var i = 0;
            view.setInt8(i, this.protocolVersion, false);
            i += Int8Array.BYTES_PER_ELEMENT;
            view.setInt8(i, packetType, false);
            i += Int8Array.BYTES_PER_ELEMENT;
            view.setFloat64(i, session.sessionId, false);
            i += Float64Array.BYTES_PER_ELEMENT;
            view.setInt16(i, session.sequence, false);
            i += Int16Array.BYTES_PER_ELEMENT;
            view.setFloat64(i, timestamp, false);
            i += Float64Array.BYTES_PER_ELEMENT; //Build Version

            view.setInt16(i, this.buildVersionBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.buildVersionBytes);

            i += this.buildVersionBytes.byteLength; //Device ID

            view.setInt16(i, this.deviceIdBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.deviceIdBytes);

            i += this.deviceIdBytes.byteLength; //Account ID

            view.setInt16(i, this.accountIdBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.accountIdBytes);

            i += this.accountIdBytes.byteLength; //Exp id

            view.setInt16(i, this.expIdBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.expIdBytes);

            i += this.expIdBytes.byteLength; //App name

            view.setInt16(i, this.appNameBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.appNameBytes);

            i += this.appNameBytes.byteLength; //Connection type

            view.setInt16(i, this.networkTypeBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.networkTypeBytes);

            i += this.networkTypeBytes.byteLength; // Copy bootInfo from header only if apps DO NOT implement Clairvoyance 3.1 protocol

            if (!this.useExperimentalVersion31) {
              //bootInfo
              view.setInt16(i, bootInfoBytesFromHeader.byteLength, false);
              i += Int16Array.BYTES_PER_ELEMENT;

              _copyBytes(buffer, i, bootInfoBytesFromHeader);

              i += bootInfoBytesFromHeader.byteLength;
            } //dataSizeGroup


            view.setInt16(i, dataSizeGroupBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, dataSizeGroupBytes);

            i += dataSizeGroupBytes.byteLength; //platform version

            view.setInt16(i, this.platformVersionBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.platformVersionBytes);

            i += this.platformVersionBytes.byteLength; //screen info

            view.setInt16(i, this.screenInfoBytes.byteLength, false);
            i += Int16Array.BYTES_PER_ELEMENT;

            _copyBytes(buffer, i, this.screenInfoBytes);

            i += this.screenInfoBytes.byteLength;
            var previousMetric = session.previousMetric;
            metrics.forEach(function (metric) {
              view.setInt32(i, metric.metric, false);
              i += Int32Array.BYTES_PER_ELEMENT; // Copy metric info bytes only if apps implement Clairvoyance 3.1 protocol

              if (this.useExperimentalVersion31) {
                view.setInt16(i, metric.metricInfoBytes.byteLength, false);
                i += Int16Array.BYTES_PER_ELEMENT;

                _copyBytes(buffer, i, metric.metricInfoBytes);

                i += metric.metricInfoBytes.byteLength;
              }

              view.setInt32(i, previousMetric, false);
              i += Int32Array.BYTES_PER_ELEMENT;
              view.setInt32(i, metric.latency, false);
              i += Int32Array.BYTES_PER_ELEMENT;
              view.setInt32(i, metric.startTimestamp - timestamp, false);
              i += Int32Array.BYTES_PER_ELEMENT; // Copy bootinfo bytes only if apps implement Clairvoyance 3.1 protocol

              if (this.useExperimentalVersion31) {
                view.setInt16(i, metric.bootInfoBytes.byteLength, false);
                i += Int16Array.BYTES_PER_ELEMENT;

                _copyBytes(buffer, i, metric.bootInfoBytes);

                i += metric.bootInfoBytes.byteLength;
              }

              previousMetric = metric.metric;
            }.bind(this));
            this.xhr({
              'url': this.url,
              'type': 'POST',
              'data': buffer,
              'headers': {
                'Content-type': 'application/octet-stream'
              },
              'success': successFn,
              'error': errorFn
            });

            this._updateSessionInfo(previousMetric);
          };

          Clairvoyance.prototype._getSessionInfo = function () {
            var seqInfo; //sessionTimestamp,sessionId,sequence|previousMetric

            var value = this._getSessionString();

            var keyArray = value.split('|');
            var seqParts = keyArray[0].split(',');
            var sessTs = seqParts[0];
            var sessionId = seqParts[1];
            var sequence = parseInt(seqParts[2]);
            var currentTs = Date.now();
            var previousMetric = keyArray[1];
            var forcedNewSession = false;

            if (keyArray.length < 3) {
              forcedNewSession = true;
            }

            if (currentTs - sessTs > this.SESSION_EXPIRE_MS || forcedNewSession) {
              // new session
              sessionId = Math.random();
              sequence = -1;
              previousMetric = -1;
            }

            seqInfo = {
              sessionId: sessionId,
              sequence: sequence + 1,
              previousMetric: previousMetric
            };
            sessTs = currentTs;
            var newSeq = sessTs + "," + seqInfo.sessionId + "," + seqInfo.sequence;
            keyArray[0] = newSeq;
            value = keyArray.join("|");
            this.dataStore.saveSessionString(value);
            return seqInfo;
          };

          Clairvoyance.prototype._updateSessionInfo = function (previousMetric) {
            var value = this._getSessionString();

            var keyArray = value.split('|');
            keyArray[1] = previousMetric;
            value = keyArray.join('|');
            this.dataStore.saveSessionString(value);
          };

          module.exports = Clairvoyance;
        }, {}]
      }, {}, [1])(1);
    });
  });

  /**
   * Is Function
   * @param {*} value
   */
  /**
   * Is String
   * @param {*} value
   */

  var isString$2 = function isString(value) {
    return typeof value === 'string';
  };
  /**
   * Is the object of a given class
   * @param {*} value
   * @param {string} className
   */

  var isObjectClass$1 = function isObjectClass(value, className) {
    return Object.prototype.toString.call(value) === "[object ".concat(className, "]");
  };
  /**
   * Is the value an Object object.
   * @param {*} value
   */


  var isPlainObject = function isPlainObject(value) {
    return isObjectClass$1(value, 'Object');
  };

  var NullLogger$1 =
  /*#__PURE__*/
  function () {
    function NullLogger() {}

    var _proto = NullLogger.prototype;

    _proto.emergency = function emergency() {};

    _proto.alert = function alert() {};

    _proto.critical = function critical() {};

    _proto.error = function error() {};

    _proto.warn = function warn() {};

    _proto.warning = function warning() {};

    _proto.notice = function notice() {};

    _proto.info = function info() {};

    _proto.debug = function debug() {};

    _proto.log = function log() {};

    return NullLogger;
  }();

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

  var BasePlugin$1 =
  /*#__PURE__*/
  function () {
    /**
     * Base plugin constructor
     *
     * @param      {json}    [environment]  The environment configuration (e.g. telemetry's config.env)
     * @param      {json}    [config]       The plugin configuration (e.g. telemetry's config.plugins)
     * @param      {string}  pluginName   Name of the plugin - this is used for logging (e.g. 'Foo SDK' or 'Bar API')
     */
    function BasePlugin(environment, config, pluginName, serviceLocator) {
      /*
       * Migration Plan:
       *   Any plugin using the legacy loader will have the default this.logger injected into the config
       *   through the internal use `this.__logger` key.
       *
       *   Long term plan is to simply ditch the BasePlugin class entirely.
       *   All plugins will be required to implement `dispatch(_, request)`.
       *   All plugins will be expected to be instantiated by factory.
       *
       * The || NullLogger() is required so that plugin tests don't break for third parties.
       */
      this.environment = environment || {};
      this.config = config || {};
      this.__logger = this.config.__logger || new NullLogger$1();
      this.__pluginName = pluginName;
      this.__serviceLocator = serviceLocator;
      this._useAsyncInterface = false;
    }

    var _proto = BasePlugin.prototype;

    /**
     * Async Disptach
     * This should be a fully self contained request as the application and state may change interim
     * @param request
     * @returns {Promise.<Object>}
     * @private
     */
    _proto._dispatchAsync = function _dispatchAsync(request) {
      var _this = this;

      // TODO: Update to track Dispatch Result
      // TODO: Update to track Generated Messages
      // TODO: Update to interface with EventInspector
      // TODO: Update signature to return a DispatchResult instance, and not the payload
      var payloadPromise = Promise.resolve(null).then(function () {
        var payload = _this.buildPayloadAsync(request);

        if (!payload) {
          return payload;
        } // TODO: Remove this as a configuration parameter (use Null Dispatcher)


        if (!_this.config.dryRun) {
          _this.sendPayloadAsync(payload, request);
        }

        return payload;
      });
      return payloadPromise;
    }
    /**
     * Original Sync Dispatch
     * TODO: Add Deprecation
     * TODO: Figure Out Deprecation Path
     * @deprecated
     * @param event
     * @returns {*}
     * @private
     */
    ;

    _proto._dispatchSync = function _dispatchSync(event, request) {
      var payload = this.buildPayload(event, request);

      if (!payload) {
        // buildPayload should return false if an error occured when assembling
        // the payload or null if plugin should not send the event
        // In case of error (false) let's log it
        if (payload === false) {
          this.logger.warning("Could not build payload for ".concat(event.type, " event to ").concat(this.pluginName, "!"));
        }
      } else {
        this._logEventPayload(event, payload);

        if (this.config.dryRun) {
          this.logger.warning("Not sending ".concat(event.type, " event to ").concat(this.pluginName, " (dry run)"));
        } else {
          this.sendPayload(payload, event, request);
        }
      }

      return this.config.dryRun ? null : payload;
    }
    /**
     * Interface PluginDispatcher
     *
     * dispatch(event, Request)
     *   v1: Return Payload
     *   v+: Return Promise.<DispatchResponse>
     *
     *
     * Main dispatch function of the plugin. It will call the buildPayload
     * and sendPayload methods which must be defined by the plugin implementor.
     * It will take care of logging the payload before sending it and will
     * also handle dry run functionality.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    ;

    _proto.dispatch = function dispatch(event, request) {
      if (this._useAsyncInterface) {
        return this._dispatchAsync(request);
      } // TODO: Warning!


      return this._dispatchSync(event, request);
    }
    /**
     * Logs a payload.
     * @private
     * @param      {object}  event   Event object from one of the supported event types
     * @param      {object}  payload  The payload
     */
    ;

    _proto._logEventPayload = function _logEventPayload(event, payload) {
      var eventType = event && event.type || 'Unknown';
      this.logger.debug("".concat(this.pluginName, " ").concat(eventType, " Sending payload."), {
        payload: payload
      });
    }
    /**
     * Builds a payload to be sent to the plugin backend API or SDK. The method
     * should be implemented by the plugin author and its return value will be
     * passed to sendPayload() method. Return null if plugin should not sent the
     * event and return false if there is an error building the payload.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     * @return     {object}  Payload to be sent to backend API or SDK via sendPayload()
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayload = function buildPayload(event, request) {
      this.logger.warning("".concat(this.constructor.name, ".buildPayload() is not implemented by plugin!"));
      return {};
    } // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayloadAsync = function buildPayloadAsync(request) {
      throw new Error('Method buildPayloadAsync is abstract.');
    }
    /**
     * Sends a payload to backend API or SDK. The payload object should be generated
     * by buildPayload() method. This method should be implemented by the plugin author.
     *
     * @param      {object}  payload Payload generated by buildPayload()
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayload = function sendPayload(payload, event, request) {
      this.logger.warning("".concat(this.constructor.name, ".sendPayload() is not implemented by plugin!"));
    }
    /**
     * @param {Object} payload
     * @param {Object} request
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayloadAsync = function sendPayloadAsync(payload, request) {
      throw new Error('Method sendPayloadAsync is abstract.');
    };

    _createClass$1(BasePlugin, [{
      key: "pluginName",
      get: function get() {
        return this.__pluginName;
      }
    }, {
      key: "serviceLocator",
      get: function get() {
        // TODO: Deprecate Use
        return this.__serviceLocator;
      }
    }, {
      key: "logger",
      get: function get() {
        return this.__logger;
      }
    }]);

    return BasePlugin;
  }();

  var accountId$1 = function accountId(_ref) {
    var environment = _ref.environment;
    return String(environment.visitorId || environment.deviceId || '');
  };

  var appName$1 = function appName(_ref) {
    var environment = _ref.environment;
    return environment.appName;
  };

  var buildVersion$1 = function buildVersion(_ref) {
    var environment = _ref.environment;
    return environment.buildVersion;
  };

  var deviceId$1 = function deviceId(_ref) {
    var environment = _ref.environment;
    return environment.deviceId || '';
  };

  var KamajiConstants = {};
  KamajiConstants.DEVICE_TYPES = {
    PS3: 202,
    PS4: 206,
    PS4K: 206,
    TV: 210,
    WEB: 201,
    MWEB: 207,
    ANDROID_TV: 237,
    ANDROID: 238,
    IOS: 239,
    ROKU: 240,
    FIRE_TV: 241,
    APPLE_TV: 242,
    CHROMECAST: 243
  };
  Object.freeze(KamajiConstants.DEVICE_TYPES);

  var deviceType$1 = function deviceType(_ref) {
    var environment = _ref.environment,
        config = _ref.config;
    var overrideDeviceType = config.overrideDeviceType;
    var deviceKey = (environment.deviceType || '').toUpperCase();
    var deviceType = overrideDeviceType || KamajiConstants.DEVICE_TYPES[deviceKey];

    if (!deviceType) {
      throw new Error("Device Type '".concat(environment.deviceType, "' not supported."));
    }

    return deviceType;
  };

  var DEFAULT_EVENT_URL = 'https://event.api.{{env}}.km.playstation.net/event/clairvoyance/{{deviceType}}';
  var DEFAULT_LINE = 'e1-np';

  var url = function url(_ref) {
    var environment = _ref.environment,
        config = _ref.config;
    var deviceType = deviceType$1({
      environment: environment,
      config: config
    }); // P devkits are configured to use sp-int, but sp-int doesnt exist for clairvoyance. So, redirecting to default e1-np.

    var env = config.env && config.env !== 'sp-int' ? config.env : DEFAULT_LINE;
    var eventUrl = config.eventUrl || DEFAULT_EVENT_URL;
    eventUrl = eventUrl.replace('{{env}}', env);
    eventUrl = eventUrl.replace('{{deviceType}}', deviceType.toString());
    return eventUrl;
  };

  var networkType = function networkType(_ref) {
    var environment = _ref.environment;
    return environment.networkType || 'unknown';
  };

  var platformVersion = function platformVersion(_ref) {
    var environment = _ref.environment;
    return environment.platformVersion || 'unknown';
  };

  var screenInfo = function screenInfo(_ref) {
    var environment = _ref.environment;
    return environment.screenInfo || 'unknown';
  };

  var resolveXhr = function resolveXhr(_ref) {
    var serviceLocator = _ref.serviceLocator,
        config = _ref.config;
    var xhrKey = "/network/".concat(isString$2(config.xhr) ? config.xhr : 'xhrInterface');
    var xhrService = serviceLocator.get(xhrKey);
    return function (options) {
      // options.timeout
      // options.success
      // options.error
      xhrService(options.type, options.url, options.headers, options.data); // callback
    };
  };

  var expId$1 = function expId() {
    return null;
  };

  var callback = function callback() {
    return null;
  };

  // Clairvoyance requires a datastore on the client side to store
  // and keep track of a session string which is used to track
  // a user moving accross pages or screens.
  // The tracking feature is not in use and may be deprecated soon.
  // To make it simpler for client apps, we will implement here a dummy data store
  // that does nothing but satisfying Clairvoyance API.
  var MemoryDataStore =
  /*#__PURE__*/
  function () {
    function MemoryDataStore() {
      this._value = undefined;
    }

    var _proto = MemoryDataStore.prototype;

    _proto.saveSessionString = function saveSessionString(s) {
      this._value = s;
    };

    _proto.getSessionString = function getSessionString() {
      return this._value;
    };

    return MemoryDataStore;
  }();

  var dataStore = function dataStore() {
    return new MemoryDataStore();
  };

  var config = {
    accountId: accountId$1,
    expId: expId$1,
    appName: appName$1,
    buildVersion: buildVersion$1,
    deviceId: deviceId$1,
    url: url,
    networkType: networkType,
    platformVersion: platformVersion,
    screenInfo: screenInfo,
    xhr: resolveXhr,
    callback: callback,
    dataStore: dataStore
  };

  var generateClairvoyanceConfig = (function (environment, config$1, serviceLocator) {
    var configGeneratorOptions = {
      environment: environment,
      config: config$1,
      serviceLocator: serviceLocator
    };

    var reducer = function reducer(result, key) {
      result[key] = config[key](configGeneratorOptions);
      return result;
    };

    var clairvoyanceConfig = Object.keys(config).reduce(reducer, {});

    if (config$1.useExperimentalVersion31 !== undefined) {
      clairvoyanceConfig.useExperimentalVersion31 = Boolean(config$1.useExperimentalVersion31);
    }

    return clairvoyanceConfig;
  });

  var getTimingIdFromMetricsMap = function getTimingIdFromMetricsMap(metricsMap) {
    return function (keySuffix) {
      return function (location) {
        return function (keyName) {
          var longKeyName = "".concat(location, ":timing:").concat(keyName);
          var suffixedKeyName = "".concat(longKeyName, ":").concat(keySuffix);
          var timingId = false;

          if (metricsMap[longKeyName]) {
            timingId = parseInt(metricsMap[longKeyName], 10);
          } else if (metricsMap[keyName]) {
            timingId = parseInt(metricsMap[keyName], 10);
          } else if (metricsMap[suffixedKeyName]) {
            timingId = parseInt(metricsMap[suffixedKeyName], 10);
          }

          return timingId;
        };
      };
    };
  };

  // Arbitrary date: the date of PS4 launch. If the event
  // time for Clairvoyance is less than that, we should
  // show a warning as it's likely an issue (we have
  // had many apps setting the timestamp as zero)
  var NOV_15_2013 = 1384502400068;

  var warnOnPastTimestamp = function warnOnPastTimestamp(logger, event, pluginName) {
    var referenceStartTime = event.time.getTime();

    if (referenceStartTime < NOV_15_2013) {
      logger.warning("Warning: time of ".concat(event.type, " event for ").concat(pluginName, " is in the past"));
    }
  };

  var buildTimingObject = function buildTimingObject(referenceStartTime, timingId, userTiming) {
    // TIMING ID IS REQUIRED
    if (!timingId) {
      return false;
    }

    var timingObject = {
      metric: timingId,
      startTimestamp: referenceStartTime + userTiming.startTime,
      latency: userTiming.duration
    }; // Boot info & Metric info are not captured by every metric. Hence they are optional.

    if (userTiming.bootInfo) {
      timingObject.bootInfo = userTiming.bootInfo;
    }

    if (userTiming.metricInfo) {
      timingObject.metricInfo = userTiming.metricInfo;
    }

    return timingObject;
  };

  var buildPayload$1 = function buildPayload(logger, getTimingId, event, pluginName) {
    if (event.type !== 'LoadTime') {
      logger.warning("Not sending ".concat(event.type, " event for ").concat(pluginName, " (unsupported)"));
      return false;
    }

    var referenceStartTime = event.time.getTime();
    warnOnPastTimestamp(logger, event, pluginName);
    var timingsPayload = [];
    var eventTimings = event.timings || []; // First we insert the metric for current location based on event.location and event.loadTime. A metric with name
    // matching event.location needs to be registered with Clairvoyance. Note that this is optional.

    if (event.loadTime > 0) {
      var timing = {
        name: 'overall',
        startTime: 0,
        duration: event.loadTime
      };
      eventTimings.unshift(timing);
    } // Then we insert individual timings based on the timings hash
    // which we combine with location. For each timing, a metric
    // with name matching (event.location + ':timing:' + name of timing)
    // needs to be registered with Clairvoyance


    eventTimings.forEach(function (timing) {
      var timingId = getTimingId(timing.name);
      var timingObject = buildTimingObject(referenceStartTime, timingId, timing);

      if (!timingObject) {
        logger.warning("Skipping '".concat(timing.name, "' timing in ").concat(pluginName, " (timing not in metric map)"));
        return;
      }

      timingsPayload.push(timingObject);
    });

    if (timingsPayload.length < 1) {
      logger.warning("Not sending ".concat(event.type, " event to ").concat(pluginName, " (no timings found)"));
      return false;
    }

    return {
      timings: timingsPayload,
      bootInfo: event.bootInfo || 'unknown',
      dataSizeGroup: event.dataSizeGroup || 'unknown'
    };
  };

  function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var Clairvoyance = clairvoyance;
  /**
   * This plugin implements load time tracking with Clairvoyance
   *
   * @class ClairvoyancePlugin
   * @extends BasePlugin
   *
   * @param {Object} environment
   * @param {String} environment.deviceType - (required) one of Constants.DEVICES, used to generate default eventUrl
   * @param {String} environment.networkType - (optional) one of Constants.NETWORKS, used to track network connection type
   * @param {String} environment.screenInfo - (optional) string, used to track screen info/size
   * @param {String} environment.platformVersion - (optional) string used to track platform version/user agent
   *
   * @param {Object} config
   * @param {String} config.env        - (optional) environment, needed to generate default eventUrl, defaults to 'e1-np'
   * @param {String} config.eventUrl   - (optional) clairvoyance endpoint url which overrides the default eventUrl
   * @param {Object} config.metricsMap - (required) object whose keys, values are (metric_name, metric_id)
   * @param {String} config.suffix     - (optional) suffix to append to metric name when searching metricsMap
   * @param {String} config.xhr        - (optional) override the default XHR function to use something else
   */

  var ClairvoyancePlugin =
  /*#__PURE__*/
  function (_BasePlugin) {
    _inheritsLoose$1(ClairvoyancePlugin, _BasePlugin);

    function ClairvoyancePlugin() {
      return _BasePlugin.apply(this, arguments) || this;
    }

    var _proto = ClairvoyancePlugin.prototype;

    _proto._requireMetricsMap = function _requireMetricsMap(metricsMap) {
      if (!isPlainObject(metricsMap)) {
        throw new Error("Missing or invalid metric map for ".concat(this.pluginName, " plugin!"));
      }
    };

    _proto._requireValidConfig = function _requireValidConfig(config) {
      this._requireMetricsMap(config.metricsMap);
    };

    _proto._createClairvoyanceInstance = function _createClairvoyanceInstance() {
      return new Clairvoyance();
    };

    _proto._initializeClairvoyanceInstanceParams = function _initializeClairvoyanceInstanceParams(environment, config, serviceLocator) {
      var clairvoyanceConfig = generateClairvoyanceConfig(environment, config, serviceLocator);

      var instance = this._createClairvoyanceInstance();

      instance.initialize(clairvoyanceConfig);
      return instance;
    };

    _proto.buildPayload = function buildPayload(xEvent, request) {
      this._requireValidConfig(request.config);

      var _request$config = request.config,
          metricsMap = _request$config.metricsMap,
          metricsSuffix = _request$config.metricsSuffix;
      var location = request.event.location.split(':').slice(0, 4).join(':');
      var getTimingId = getTimingIdFromMetricsMap(metricsMap)(metricsSuffix)(location);
      var logger = this.logger;
      return buildPayload$1(logger, getTimingId, request.event, this.pluginName);
    };

    _proto.sendPayload = function sendPayload(payload, event, request) {
      var environment = request.environment,
          config = request.config;

      var instance = this._initializeClairvoyanceInstanceParams(environment, config, this.serviceLocator);

      instance.sendLatencyData(payload.timings, null, null, payload.bootInfo, payload.dataSizeGroup);
    };

    return ClairvoyancePlugin;
  }(BasePlugin$1);

  /**
   * Resolves all aliases.
   *
   * @param {Object} aliases - an object with list of aliases
   *
   * @returns {Object} An object with aliases resolved.
   */
  var resolveAliases = (function (aliases) {
    var resolvedAliases = {};
    Object.keys(aliases).forEach(function (alias) {
      var visited = {};
      var name = alias;

      while (aliases[name]) {
        if (visited[name]) {
          throw new Error("CyclicAlias: Circular Alias Reference encountered at ".concat(name));
        }

        visited[name] = true;
        Object.defineProperty(visited, name, {
          value: true
        });
        name = aliases[name];
      }

      resolvedAliases[alias] = name;
    });
    return resolvedAliases;
  });

  /**
   * Really dumb implementation just to get the pattern into the codebase.
   *
   * Restrictions:
   * All shared instances.
   * Aliases cannot be nested.
   *
   * PSR-11 compatible ContainerInterface
   */

  var _default =
  /*#__PURE__*/
  function () {
    function _default() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._instances = {};
      this._factories = options.factories || {};
      this._aliases = options.aliases || {};
      this._resolvedAliases = resolveAliases(this._aliases);
    }
    /**
     * Configure a service
     * @param {string} serviceId
     * @param {*} instance
     */


    var _proto = _default.prototype;

    _proto.setService = function setService(serviceId, instance) {
      if (this.has(serviceId)) {
        throw new Error("ServiceExists: the service already exists: ".concat(serviceId, "."));
      }

      this._instances[serviceId] = instance;
    }
    /**
     * Return the factory of the given id.
     * @param {string} resolvedId
     * @returns {IFactory}
     */
    ;

    _proto.getFactory = function getFactory(resolvedId) {
      var factory = this._factories[resolvedId] || undefined;

      if (typeof factory === 'function') {
        return factory;
      } // TODO: Abstract Factories


      throw new Error("ServiceNotFound: Unable to resolve ".concat(resolvedId, " to a factory."));
    }
    /**
     * Return the instance of the given id.
     * @param {string} requestedId
     * @returns {*}
     */
    ;

    _proto.get = function get(requestedId) {
      if (this._instances[requestedId]) {
        return this._instances[requestedId];
      } // Resolve Alias


      var id = this._resolvedAliases[requestedId] || requestedId; // Shared Alias

      if (requestedId !== id && this._instances[id]) {
        this._instances[requestedId] = this._instances[id];
        return this._instances[id];
      }

      var instance = this.doCreate(id); // Cache Requested service

      this._instances[id] = instance;

      if (requestedId !== id) {
        this._instances[requestedId] = instance;
      }

      return instance;
    }
    /**
     * Contain has the given item
     * @param {string} requestedId  Lookup Key
     * @returns {boolean}
     */
    ;

    _proto.has = function has(requestedId) {
      var id = this._resolvedAliases[requestedId] || requestedId;
      return typeof this._instances[id] !== 'undefined' || typeof this._factories[id] === 'function';
    }
    /**
     * @param {string} requestedId Lookup Key
     * @param {object} options Build Configuration
     */
    ;

    _proto.build = function build(requestedId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // Never cached
      var id = this._resolvedAliases[requestedId] || requestedId;
      return this.doCreate(id, options);
    }
    /**
     * Create Object from factory
     * @param {string} resolvedId  Lookup Key
     * @returns {*}
     */
    ;

    _proto.doCreate = function doCreate(resolvedId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // if no delegate
      var factory = this.getFactory(resolvedId); // Throws:

      var object = factory(this, resolvedId, options); // Cannot catch ContainerException
      // Cannot catch Exception

      return object;
    };

    return _default;
  }();

  /**
   * {@link ServiceLocator}
   */

  var hasOwnProperty$a = Object.prototype.hasOwnProperty;

  var has = function has(object, key) {
    return object != null && hasOwnProperty$a.call(object, key);
  };

  /**
   * These correspond to SysLog protocol definitions as defined in RFC-5424
   * @typedef {string} LogLevel
   *
   */
  var LogLevel;

  (function (LogLevel) {
    /**
     * Emergency (0)
     * Urgent Alert
     * @type {string}
     */
    LogLevel["EMERGENCY"] = "emergency";
    /**
     * ALert (1)
     * Action Must be taken immediately
     * E.g.
     *   Entire website down.
     *   Database Unavailable
     *   Should trigger SMS alerts for someone
     * @type {string}
     */

    LogLevel["ALERT"] = "alert";
    /**
     * Critical (2)
     * Critical Condition
     * E.g.
     *   Application component unavailable
     *   Unexpected exception
     * @type {string}
     */

    LogLevel["CRITICAL"] = "critical";
    /**
     * Error (3)
     * Runtime Errors
     * @type {string}
     */

    LogLevel["ERROR"] = "error";
    /**
     * Warning (4)
     * Exceptional occurances that are not errors
     * E.g.
     *   Use of deprecated APIs
     *   Poor use of an API
     *   Undesirable things that are not necessarily wrong
     * @type {string}
     */

    LogLevel["WARNING"] = "warning";
    /**
     * Notice (5)
     * Uncommon Events
     * @type {string}
     */

    LogLevel["NOTICE"] = "notice";
    /**
     * Informational (6)
     * Interesting Events
     * E.g.
     *    User logs in
     *    SQL Logs
     * @type {string}
     */

    LogLevel["INFO"] = "info";
    /**
     * Debug (7)
     * Detailed Debug information
     * @type {string}
     */

    LogLevel["DEBUG"] = "debug";
  })(LogLevel || (LogLevel = {}));

  var AbstractLogger =
  /*#__PURE__*/
  function () {
    function AbstractLogger() {}

    var _proto = AbstractLogger.prototype;

    _proto.emergency = function emergency(message, context) {
      this.log(LogLevel.EMERGENCY, message, context);
    };

    _proto.alert = function alert(message, context) {
      this.log(LogLevel.ALERT, message, context);
    };

    _proto.critical = function critical(message, context) {
      this.log(LogLevel.CRITICAL, message, context);
    };

    _proto.error = function error(message, context) {
      this.log(LogLevel.ERROR, message, context);
    };

    _proto.warning = function warning(message, context) {
      this.log(LogLevel.WARNING, message, context);
    };

    _proto.notice = function notice(message, context) {
      this.log(LogLevel.NOTICE, message, context);
    };

    _proto.info = function info(message, context) {
      this.log(LogLevel.INFO, message, context);
    };

    _proto.debug = function debug(message, context) {
      this.log(LogLevel.DEBUG, message, context);
    }
    /**
     * Arbitrary Log Level function
     * @param {string} level
     * @param {string} message
     * @param {LogContext} context
     */
    ;

    _proto.log = function log(_level, _message, _context) {
      throw new Error('NotImplemented');
    };

    return AbstractLogger;
  }();

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var LogDecorator =
  /*#__PURE__*/
  function (_AbstractLogger) {
    _inheritsLoose$2(LogDecorator, _AbstractLogger);

    /**
     *
     * @param {ILogger} logger
     */
    function LogDecorator(logger) {
      var _this;

      _this = _AbstractLogger.call(this) || this;
      _this._logger = logger;
      return _this;
    }
    /**
     * The delegate logger
     * @returns {LogInterface}
     */


    var _proto = LogDecorator.prototype;

    /**
     *
     * @param {string} level
     * @param {string} msg
     * @param {LogContext} context
     */
    _proto.log = function log(level, msg, context) {
      this.logger.log(level, msg, context);
    };

    _createClass$2(LogDecorator, [{
      key: "logger",
      get: function get() {
        return this._logger;
      }
    }]);

    return LogDecorator;
  }(AbstractLogger);

  function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var ContextValueDecorator =
  /*#__PURE__*/
  function (_LogDecorator) {
    _inheritsLoose$3(ContextValueDecorator, _LogDecorator);

    function ContextValueDecorator(callback, logger) {
      var _this;

      _this = _LogDecorator.call(this, logger) || this;

      if (typeof callback !== 'function') {
        throw new Error('InvalidArgument: Callback is expected to be of type "function".');
      }

      _this._callback = callback;
      return _this;
    }
    /**
     * Pre processes the context object
     * @param level
     * @param message
     * @param context
     */


    var _proto = ContextValueDecorator.prototype;

    _proto.log = function log(level, message, context) {
      var resolvedContext = typeof context === 'function' ? context() : context;
      this.logger.log(level, message, this._callback(resolvedContext));
    };

    return ContextValueDecorator;
  }(LogDecorator);

  function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var MessagePrefixDecorator =
  /*#__PURE__*/
  function (_LogDecorator) {
    _inheritsLoose$4(MessagePrefixDecorator, _LogDecorator);

    function MessagePrefixDecorator(prefix, logger) {
      var _this;

      _this = _LogDecorator.call(this, logger) || this;
      _this._prefix = prefix;
      return _this;
    }
    /**
     * Filters out any calls that are at a higher reporting level than configured.
     * @param level
     * @param message
     * @param context
     */


    var _proto = MessagePrefixDecorator.prototype;

    _proto.log = function log(level, message, context) {
      this.logger.log(level, "".concat(this._prefix).concat(message), context);
    };

    return MessagePrefixDecorator;
  }(LogDecorator);

  var _logLevelMap;

  function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var UNKNOWN_LEVEL = 8;
  var logLevelMap = (_logLevelMap = {}, _defineProperty$1(_logLevelMap, LogLevel.EMERGENCY, 0), _defineProperty$1(_logLevelMap, LogLevel.CRITICAL, 1), _defineProperty$1(_logLevelMap, LogLevel.ALERT, 2), _defineProperty$1(_logLevelMap, LogLevel.ERROR, 3), _defineProperty$1(_logLevelMap, LogLevel.WARNING, 4), _defineProperty$1(_logLevelMap, LogLevel.NOTICE, 5), _defineProperty$1(_logLevelMap, LogLevel.INFO, 6), _defineProperty$1(_logLevelMap, LogLevel.DEBUG, 7), _logLevelMap);
  var RestrictByLogLevelDecorator =
  /*#__PURE__*/
  function (_LogDecorator) {
    _inheritsLoose$5(RestrictByLogLevelDecorator, _LogDecorator);

    function RestrictByLogLevelDecorator(logLevel, logger) {
      var _this;

      _this = _LogDecorator.call(this, logger) || this;
      _this._logLevel = logLevelMap[logLevel];

      if (_this._logLevel === undefined) {
        throw new Error("InvalidArgument: Unknown log level provided. ".concat(JSON.stringify(logLevel)));
      }

      return _this;
    }

    var _proto = RestrictByLogLevelDecorator.prototype;

    _proto.resolveLogLevel = function resolveLogLevel(logLevel) {
      if (undefined === logLevelMap[logLevel]) {
        return UNKNOWN_LEVEL;
      }

      return logLevelMap[logLevel];
    }
    /**
     * Filters out any calls that are at a higher reporting level than configured.
     * @param level
     * @param message
     * @param context
     */
    ;

    _proto.log = function log(level, message, context) {
      if (this.resolveLogLevel(level) > this._logLevel) {
        return;
      }

      this.logger.log(level, message, context);
    };

    return RestrictByLogLevelDecorator;
  }(LogDecorator);

  var isLazyLogContext = function isLazyLogContext(value) {
    // noinspection RedundantIfStatementJS
    if (typeof value === 'function') {
      return true;
    }

    return false;
  };

  function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var ConsoleLogger =
  /*#__PURE__*/
  function (_AbstractLogger) {
    _inheritsLoose$6(ConsoleLogger, _AbstractLogger);

    function ConsoleLogger(console) {
      var _this$_logLevelFuncti;

      var _this;

      _this = _AbstractLogger.call(this) || this;

      var wrapConsoleMethod = function wrapConsoleMethod(key) {
        if (console[key] === undefined) {
          return undefined;
        }

        return console[key].bind(console) || undefined;
      };

      if (typeof console.log !== 'function') {
        throw new Error('PrerequisiteError: No console.log method found.');
      }

      var defaultLog = console.log.bind(console);
      var errorLog = wrapConsoleMethod('error') || defaultLog;
      var infoLog = wrapConsoleMethod('info') || defaultLog;
      var warnLog = wrapConsoleMethod('warn') || defaultLog;
      var debugLog = wrapConsoleMethod('debug') || defaultLog;
      _this._defaultLog = debugLog;
      _this._logLevelFunctionMap = (_this$_logLevelFuncti = {}, _defineProperty$2(_this$_logLevelFuncti, LogLevel.EMERGENCY, errorLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.ALERT, errorLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.CRITICAL, errorLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.ERROR, errorLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.WARNING, warnLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.NOTICE, infoLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.INFO, infoLog), _defineProperty$2(_this$_logLevelFuncti, LogLevel.DEBUG, debugLog), _this$_logLevelFuncti);
      return _this;
    }

    var _proto = ConsoleLogger.prototype;

    _proto.log = function log(level, message, context) {
      if (!context) {
        (this._logLevelFunctionMap[level] || this._defaultLog)(message);

        return;
      } // Context is ExplicitLogContext or LazyLogContext


      var resolvedContext = isLazyLogContext(context) ? context() : context;

      (this._logLevelFunctionMap[level] || this._defaultLog)(message, resolvedContext);
    };

    return ConsoleLogger;
  }(AbstractLogger);

  var NullLogger$2 =
  /*#__PURE__*/
  function () {
    function NullLogger() {}

    var _proto = NullLogger.prototype;

    _proto.alert = function alert(_message, _context) {};

    _proto.critical = function critical(_message, _context) {};

    _proto.debug = function debug(_message, _context) {};

    _proto.emergency = function emergency(_message, _context) {};

    _proto.error = function error(_message, _context) {};

    _proto.info = function info(_message, _context) {};

    _proto.log = function log(_level, _message, _context) {};

    _proto.notice = function notice(_message, _context) {};

    _proto.warning = function warning(_message, _context) {};

    return NullLogger;
  }();

  var normalizeKeyRegExp = /[^a-zA-Z0-9\-_.]/g;

  var DomStorageCache =
  /*#__PURE__*/
  function () {
    /**
     * @param {Storage} storageInterface  DOM Storage Interface to use (localStorage, sessionStorage, mockStorage)
     * @param {object} config             Configuration
     * @param {ILogger?} logger            Logger
     */
    function DomStorageCache(storageInterface) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var logger = arguments.length > 2 ? arguments[2] : undefined;
      this._namespace = config.namespace || 'default';
      this._storage = storageInterface;
      this._clockSkew = 60000; // Allow 60 seconds of slush

      this._logger = logger || new NullLogger$2();
    }
    /**
     * @param {string} key
     * @returns {string}
     */


    var _proto = DomStorageCache.prototype;

    _proto.normalizeKey = function normalizeKey(key) {
      var normalizedKey = key.replace(normalizeKeyRegExp, '');
      return "!".concat(this._namespace, "!").concat(normalizedKey);
    }
    /**
     * Fetches a value from the cache.
     *
     * @param {string} key       The unique key of this item in the cache.
     * @param {*}  defaultValue  Default value to return if the key does not exist.
     *
     * @return {*} The value of the item from the cache, or $default in case of cache miss.
     */
    ;

    _proto.get = function get(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var normalizedKey = this.normalizeKey(key);

      var result = this._storage.getItem(normalizedKey); // Value not stored


      if (result === null) {
        return defaultValue;
      } // Not JSON, not a value we stored, cannot parse.


      if (result[0] !== '{') {
        return defaultValue;
      } // Corrupted data


      var data;

      try {
        data = JSON.parse(result);
      } catch (e) {
        return defaultValue;
      } // Not something we stored, or corrupt value


      if (!has(data, 'value') || !data.metaData) {
        return defaultValue;
      } // Value is expired


      if (!this.isActive(data.metaData.notBefore, data.metaData.notAfter)) {
        // Can this throw?
        this._storage.removeItem(normalizedKey);

        return defaultValue;
      }

      return data.value;
    }
    /**
     * Validate that the clock is within the current valid time-limits.
     * @param {int?} notBefore  Timestamp
     * @param {int?} notAfter   Timestamp
     * @returns {boolean}
     */
    ;

    _proto.isActive = function isActive(notBefore, notAfter) {
      if (notBefore && Date.now() + this._clockSkew < notBefore) {
        return false;
      }

      if (notAfter && Date.now() - this._clockSkew > notAfter) {
        return false;
      }

      return true;
    };

    _proto.resolveTtl = function resolveTtl(ttl) {
      // No TTL
      if (!ttl) {
        return false;
      } // TTL in MS
      // eslint-disable-next-line no-restricted-globals


      if (typeof ttl === 'number' && isFinite(ttl)) {
        return Date.now() + ttl;
      } // TTL as Date


      if (ttl instanceof Date) {
        return ttl.getTime();
      } // Unknown Value = no ttl


      this._logger.error("resolveTtl() expects number or Date", {
        ttl: ttl
      });

      return false;
    }
    /**
     * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.
     *
     * @param {string}  key   The key of the item to store.
     *
     * @param {*}       value The value of the item to store, must be serializable.
     * @param {int|Date}     ttl   TTL in MS, or a Date representing expiration time
     * @return {boolean} True on success and false on failure.
     */
    ;

    _proto.set = function set(key, value, ttl) {
      // Can throw an exception
      var normalizedKey = this.normalizeKey(key);
      var notBefore = Date.now();
      var notAfter = this.resolveTtl(ttl);
      var data = {
        value: value,
        metaData: {
          notBefore: notBefore,
          notAfter: notAfter
        }
      };

      try {
        var serializedData = JSON.stringify(data);

        this._storage.setItem(normalizedKey, serializedData);
      } catch (e) {
        return false;
      }

      return true;
    }
    /**
     * Delete an item from the cache by its unique key.
     *
     * @param {string} key The unique cache key of the item to delete.
     *
     * @return {boolean} True if the item was successfully removed. False if there was an error.
     */
    ;

    _proto["delete"] = function _delete(key) {
      var normalizedKey = this.normalizeKey(key);

      this._storage.removeItem(normalizedKey);

      return true;
    }
    /**
     * Return the local keys stored in the local storage
     *
     * @returns {Array}
     */
    ;

    _proto.namespacedKeys = function namespacedKeys() {
      var result = [];
      var prefix = this.normalizeKey('');

      for (var i = 0; i < this._storage.length; i += 1) {
        /** @var {string} */
        var namespacedKey = this._storage.key(i);

        if (namespacedKey.indexOf(prefix) === 0) {
          result.push(namespacedKey);
        }
      }

      return result;
    }
    /**
     * Wipes clean the entire cache's keys.
     * Only cleans keys within the namespace we are using.
     * @return {boolean} True on success and false on failure.
     */
    ;

    _proto.clear = function clear() {
      var storage = this._storage;
      this.namespacedKeys().forEach(function (key) {
        storage.removeItem(key);
      });
      return true;
    }
    /**
     * Determines whether an item is present in the cache.
     *
     * NOTE: It is recommended that has() is only to be used for cache warming type purposes
     * and not to be used within your live applications operations for get/set, as this method
     * is subject to a race condition where your has() will return true and immediately after,
     * another script can remove it making the state of your app out of date.
     *
     * @param {string} key     The cache item key.
     *
     * @return {boolean}
     *
     */
    ;

    _proto.has = function has(key) {
      var normalizedKey = this.normalizeKey(key); // Null if not set, string otherwise

      return this._storage.getItem(normalizedKey) !== null;
    };

    return DomStorageCache;
  }();

  var MemoryCache =
  /*#__PURE__*/
  function () {
    function MemoryCache() {
      this._storage = new Map();
    }
    /**
     * Fetches a value from the cache.
     *
     * @param {string} key       The unique key of this item in the cache.
     * @param {*}  defaultValue  Default value to return if the key does not exist.
     *
     * @return {*} The value of the item from the cache, or $default in case of cache miss.
     */


    var _proto = MemoryCache.prototype;

    _proto.get = function get(key) {
      var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (this._storage.has(key)) {
        return this._storage.get(key);
      }

      return defaultValue;
    }
    /**
     * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time.
     *
     * @param {string}  key   The key of the item to store.
     *
     *  @param {*}       value The value of the item to store, must be serializable.
     *
     * @return {boolean} True on success and false on failure.
     */
    ;

    _proto.set = function set(key, value) {
      this._storage.set(key, value);

      return true;
    }
    /**
     * Delete an item from the cache by its unique key.
     *
     * @param {string} key The unique cache key of the item to delete.
     *
     * @return {boolean} True if the item was successfully removed. False if there was an error.
     */
    ;

    _proto["delete"] = function _delete(key) {
      return this._storage["delete"](key);
    }
    /**
     * Wipes clean the entire cache's keys.
     *
     * @return {boolean} True on success and false on failure.
     */
    ;

    _proto.clear = function clear() {
      this._storage.clear();

      return true;
    }
    /**
     * Determines whether an item is present in the cache.
     *
     * NOTE: It is recommended that has() is only to be used for cache warming type purposes
     * and not to be used within your live applications operations for get/set, as this method
     * is subject to a race condition where your has() will return true and immediately after,
     * another script can remove it making the state of your app out of date.
     *
     * @param {string} key     The cache item key.
     *
     * @return {boolean}
     *
     */
    ;

    _proto.has = function has(key) {
      return this._storage.has(key);
    };

    return MemoryCache;
  }();

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

  var Event =
  /*#__PURE__*/
  function () {
    function Event(name, target, params) {
      if (name) {
        this._name = name;
      }

      if (target) {
        this._target = target;
      }

      this._params = params || {};
    }
    /**
     * Event Name
     * @returns {string}
     */


    var _proto = Event.prototype;

    /**
     * Get a parameter by name
     * @param {string} name
     * @param {*} defaultValue
     * @returns {*}
     */
    _proto.getParam = function getParam(name, defaultValue) {
      return this._params[name] === undefined ? defaultValue : this._params[name];
    }
    /**
     * Set a parameter by name
     * @param {string} name
     * @param {*} value
     */
    ;

    _proto.setParam = function setParam(name, value) {
      this._params[name] = value;
    }
    /**
     * Has event propagation been stopped
     * @returns {boolean | *}
     */
    ;

    /**
     * Change the stop propagation flag
     * @param flag
     */
    _proto.stopPropagation = function stopPropagation() {
      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this._stopPropagation = Boolean(flag);
    };

    _createClass$3(Event, [{
      key: "name",
      get: function get() {
        return this._name;
      }
      /**
       * Event Name
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._name = value;
      }
      /**
       * Event Target
       * @returns {string|Object}
       */

    }, {
      key: "target",
      get: function get() {
        return this._target;
      }
      /**
       * Event Target
       * @param {string|Object} target
       */
      ,
      set: function set(target) {
        this._target = target;
      }
      /**
       * Parameters
       * @returns {Object}
       */

    }, {
      key: "params",
      get: function get() {
        return this._params;
      }
      /**
       * Parameters
       * @param {Object} params
       */
      ,
      set: function set(params) {
        this._params = params;
      }
    }, {
      key: "isPropagationStopped",
      get: function get() {
        return this._stopPropagation;
      }
    }]);

    return Event;
  }();

  /**
   * Array.prototype.includes
   * Native Support in:
   *   Chrome 47+
   *   Edge 14+
   *   IE:  -not supported-
   *   Firefox 43+
   *   Opera 34+
   *   Safari 9+
   *
   *   Android Browser
   *   Chrome for Android
   *   Edge Mobile: 14+
   *   IE Mobile: --- not supported ---
   *   Firefox for Android: 43+
   *   Opera Android: 34+
   *   iOS Safari: 9+
   *
   * @param {Array} array
   * @param {*} value
   * @return {boolean}
   * @private
   */

  /**
   * Is String
   * @param {*} value
   */

  var isString$3 = function isString(value) {
    return typeof value === 'string';
  };
  /**
   * Is the value undefined
   * @param value
   */

  var isUndefined = function isUndefined(value) {
    return value === undefined;
  };

  function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

  var ResponseCollection =
  /*#__PURE__*/
  function () {
    function ResponseCollection() {
      this._responses = [];
      this._stopped = false;
    }

    var _proto = ResponseCollection.prototype;

    _proto.push = function push(response) {
      this._responses.push(response);
    };

    _proto.contains = function contains(value) {
      return this._responses.indexOf(value) !== -1;
    };

    _createClass$4(ResponseCollection, [{
      key: "asArray",
      get: function get() {
        return this._responses;
      }
    }, {
      key: "length",
      get: function get() {
        return this._responses.length;
      }
    }, {
      key: "stopped",
      get: function get() {
        return this._stopped;
      },
      set: function set(stopped) {
        this._stopped = Boolean(stopped);
      }
    }, {
      key: "first",
      get: function get() {
        return this._responses[0];
      }
    }, {
      key: "last",
      get: function get() {
        return this._responses[this._responses.length - 1];
      }
    }]);

    return ResponseCollection;
  }();

  function _typeof$7(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }

  var numericSort = function numericSort(a, b) {
    return Number(a) - Number(b);
  };

  var EventManager =
  /*#__PURE__*/
  function () {
    function EventManager() {
      this._events = {};
    }

    var _proto = EventManager.prototype;

    _proto.asEvent = function asEvent(eventName, target, params) {
      var event = new Event();
      event.name = eventName;

      if (target) {
        event.target = target;
      }

      if (params) {
        event.params = params;
      }

      return event;
    };

    _proto.attach = function attach(eventName, listener) {
      var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

      if (!isString$3(eventName)) {
        throw new Error("Event Name must be a string. \"".concat(_typeof$7(eventName), "\" given."));
      }

      if (!this._events[eventName]) {
        this._events[eventName] = {};
      }

      var eventList = this._events[eventName];

      if (!eventList[priority]) {
        eventList[priority] = [[]];
      }

      this._events[eventName][priority][0].push(listener);

      return listener;
    };

    _proto.detach = function detach(listener, eventName) {
      var _this = this;

      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (!eventName || eventName === '*' && !force) {
        Object.keys(this._events).forEach(function (_eventName) {
          _this.detach(listener, _eventName, true);
        });
        return;
      }

      if (!this._events[eventName]) {
        return;
      }

      var priorities = Object.keys(this._events[eventName]);
      priorities.forEach(function (priority) {
        var listeners = _this._events[eventName][Number(priority)];

        var foundIndex = listeners[0].indexOf(listener);

        if (foundIndex === -1) {
          return;
        }

        listeners[0].splice(foundIndex, 1);

        if (!listeners[0].length) {
          delete _this._events[eventName][Number(priority)];
        }
      }); // no priority arrays left for event name. So, delete event name
      // TODO: write test to check the removal of the last event in a priority removes the event key

      if (!this._events[eventName] || !Object.keys(this._events[eventName]).length) {
        delete this._events[eventName];
      }
    }
    /**
     * Clear all listeners for the given event name
     * @param {string} eventName
     */
    ;

    _proto.clearListeners = function clearListeners(eventName) {
      this._events[eventName] = [];
    }
    /**
     * Trigger an Event
     * @param {string} eventName
     * @param {string|Object} [target]
     * @param {Object} [params]
     * @return {ResponseCollection}
     */
    ;

    _proto.trigger = function trigger(eventName, target, params) {
      return this.triggerListeners(this.asEvent(eventName, target, params));
    }
    /**
     * Trigger an Event, With stop condition
     * @param {function} callback
     * @param {string} eventName
     * @param {string|Object} [target]
     * @param {Object} [params]
     * @return {ResponseCollection}
     */
    ;

    _proto.triggerUntil = function triggerUntil(callback, eventName, target, params) {
      return this.triggerListeners(this.asEvent(eventName, target, params), callback);
    }
    /**
     * Trigger an Event
     * @param {Event} event
     * @return {ResponseCollection}
     */
    ;

    _proto.triggerEvent = function triggerEvent(event) {
      return this.triggerListeners(event);
    }
    /**
     * Trigger an event until...
     * @param {function} callback
     * @param {Event} event
     * @returns {ResponseCollection}
     */
    ;

    _proto.triggerEventUntil = function triggerEventUntil(callback, event) {
      return this.triggerListeners(event, callback);
    }
    /**
     * Trigger the listeners
     * @param {Event} event
     * @param {function} [callback]
     * @returns {ResponseCollection}
     * @private
     */
    ;

    _proto.triggerListeners = function triggerListeners(event, callback) {
      var _this2 = this;

      var name = event.name;

      if (!name) {
        throw new Error('Event requires a name.');
      }

      var listenersByPriority;

      if (this._events[name]) {
        listenersByPriority = this._events[name];

        if (this._events['*']) {
          var _priorities = Object.keys(this._events['*']);

          _priorities.forEach(function (priority) {
            _this2._events['*'][Number(priority)].forEach(function (listOfListeners, mPriority) {
              if (!listenersByPriority[mPriority]) {
                listenersByPriority[mPriority] = [listOfListeners];
              } else {
                listenersByPriority[mPriority].push(listOfListeners);
              }
            });
          });
        }
      } else if (this._events['*']) {
        listenersByPriority = this._events['*'];
      } else {
        listenersByPriority = [];
      } // eslint-disable-next-line no-param-reassign


      event.stopPropagation(false);
      var responses = new ResponseCollection();
      var priorities = Object.keys(listenersByPriority).sort(numericSort).reverse();
      priorities.every(function (priority) {
        var listOfListeners = listenersByPriority[Number(priority)];
        return listOfListeners.every(function (listeners) {
          return listeners.every(function (listener) {
            var response = listener(event);
            responses.push(response);

            if (event.isPropagationStopped) {
              responses.stopped = true;
              return false;
            }

            if (callback && callback(response)) {
              responses.stopped = true;
              return false;
            }

            return true;
          });
        });
      });
      return responses;
    };

    return EventManager;
  }();

  function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

  var IdentifierProvider =
  /*#__PURE__*/
  function () {
    function IdentifierProvider() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          shortTermId = _ref.shortTermId,
          sessionId = _ref.sessionId,
          tracingId = _ref.tracingId,
          testIdentifiers = _ref.testIdentifiers;

      if (!shortTermId) {
        throw new Error('Configuration parameter `shortTermId` is required.');
      }

      if (!sessionId) {
        throw new Error('Configuration parameter `shortTermId` is required.');
      }

      if (!tracingId) {
        throw new Error('Configuration parameter `tracingId` is required.');
      }

      this._shortTermId = shortTermId;
      this._tracingId = tracingId;
      this._sessionId = sessionId;

      if (typeof testIdentifiers !== 'undefined') {
        this._testCaseId = testIdentifiers.testCaseId;
        this._testSessionId = testIdentifiers.testSessionId;
      }
    }
    /**
     * @type {string} Short Term Id
     */


    _createClass$5(IdentifierProvider, [{
      key: "shortTermId",
      get: function get() {
        return this._shortTermId.value;
      }
      /**
       * @type {string} Session Id
       */

    }, {
      key: "sessionId",
      get: function get() {
        return this._sessionId.value;
      }
      /**
       * @type {string} Session Id
       */

    }, {
      key: "tracingId",
      get: function get() {
        return this._tracingId.value;
      }
      /**
       * @type {string} TestCase Id
       */

    }, {
      key: "testCaseId",
      get: function get() {
        return this._testCaseId;
      }
      /**
       * @type {string} TestSession Id
       */

    }, {
      key: "testSessionId",
      get: function get() {
        return this._testSessionId;
      }
    }]);

    return IdentifierProvider;
  }();

  function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

  var PREFIX_OPT_OUT_GUEST = 'optout';
  var PREFIX_OPT_OUT_MISSING_ID = 'optout';
  var PREFIX_OPT_OUT_SIGNED_IN = 'optout';
  var PREFIX_OPT_IN_GUEST = 'sgnout';
  var PREFIX_OPT_IN_MISSING_ID = 'dnrhid'; // Did not receive hashed id

  var PREFIX_OPT_IN_SIGNED_IN = 'signin';

  var Prefix =
  /*#__PURE__*/
  function () {
    function Prefix() {
      this._isOptOut = false;
      this._isSignedOut = false;
      this._isMissingId = false;
    }

    var _proto = Prefix.prototype;

    /**
     * Default string representation
     * @returns {string}
     */
    _proto.toString = function toString() {
      return this.value;
    }
    /**
     * Set Signed Out state
     */
    ;

    /**
     * Populate the state from a given object.
     * @param obj
     */
    _proto.populate = function populate(obj) {
      if (obj.isOptOut) {
        this.isOptOut = obj.isOptOut;
      }

      if (obj.isMissingId) {
        this.isMissingId = obj.isMissingId;
      }

      if (obj.isSignedOut) {
        this.isSignedOut = obj.isSignedOut;
      }
    }
    /**
     * Return serialized form for export
     * @returns {Object}
     */
    ;

    _proto.asObject = function asObject() {
      return {
        isOptOut: this._isOptOut,
        isMissingId: this._isMissingId,
        isSignedOut: this._isSignedOut
      };
    };

    _createClass$6(Prefix, [{
      key: "_optOutValue",
      get: function get() {
        if (this._isSignedOut) {
          return PREFIX_OPT_OUT_GUEST;
        }

        if (this._isMissingId) {
          return PREFIX_OPT_OUT_MISSING_ID;
        }

        return PREFIX_OPT_OUT_SIGNED_IN;
      }
    }, {
      key: "_optInValue",
      get: function get() {
        if (this._isSignedOut) {
          return PREFIX_OPT_IN_GUEST;
        }

        if (this._isMissingId) {
          return PREFIX_OPT_IN_MISSING_ID;
        }

        return PREFIX_OPT_IN_SIGNED_IN;
      }
      /**
       * Return the current prefix
       * @returns {string}
       */

    }, {
      key: "value",
      get: function get() {
        return this._isOptOut ? this._optOutValue : this._optInValue;
      }
    }, {
      key: "isSignedOut",
      set: function set(flag) {
        this._isSignedOut = Boolean(flag);
      }
      /**
       * Set Missing Id State
       */

    }, {
      key: "isMissingId",
      set: function set(flag) {
        this._isMissingId = Boolean(flag);
      }
      /**
       * set Opt Out State
       */

    }, {
      key: "isOptOut",
      set: function set(flag) {
        this._isOptOut = Boolean(flag);
      }
    }]);

    return Prefix;
  }();

  /**
   * List of the User Permission Levels.
   *
   * This represents the specific amount of data the user wishes to share.
   *
   *   MAXIMAL:   'all'      Share everything.
   *   MINIMAL:   'minimal'  Share as little as possible.
   *   EXEMPT:    'exempt'   User is not offered the setting.
   *
   * @typedef {string} schema~UserPermissionLevel
   * @enum {string} schema~UserPermissionLevel}
   */
  var Ws1Level;

  (function (Ws1Level) {
    Ws1Level["MAXIMAL"] = "all";
    Ws1Level["MINIMAL"] = "minimal";
    Ws1Level["EXEMPT"] = "exempt";
  })(Ws1Level || (Ws1Level = {}));

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  var PrefixUserEventListener =
  /*#__PURE__*/
  function () {
    /**
     * @param {SessionId} sessionId
     * @param {TelemetryService} telemetryService
     */
    function PrefixUserEventListener(sessionId, telemetryService) {
      this._sessionId = sessionId; // TODO: We specifically want env.signedIn, env.visitorId, and platformPrivacyWs1
      // find a means to simplify integration to the components we need

      this._telemetryService = telemetryService;
      this._prefix = new Prefix(); // We cannot attach to this.updatePrefix because of "this" scoping.

      this._listeners = [[this.updatePrefix.bind(this), 'signedInStateChange'], [this.updatePrefix.bind(this), 'platformPrivacyLevelChange']];
      this.attachListeners(telemetryService.eventManager);
      this.updatePrefix();
    }
    /**
     * Attach Listeners
     * @param {EventManager} eventManager
     */


    var _proto = PrefixUserEventListener.prototype;

    _proto.attachListeners = function attachListeners(eventManager) {
      this._listeners.forEach(function (listenerDefinition) {
        var _listenerDefinition = _slicedToArray(listenerDefinition, 2),
            listener = _listenerDefinition[0],
            eventName = _listenerDefinition[1];

        eventManager.attach(eventName, listener);
      });
    }
    /**
     * Update the prefix with the new state
     */
    ;

    _proto.updatePrefix = function updatePrefix()
    /* event */
    {
      var telemetry = this._telemetryService; // TODO: When configuration is migrated away from "env" this event can probably have a "user" property

      var isSignedOut = !telemetry._legacyEnvironment.isSignedIn;
      var isMissingId = !telemetry._legacyEnvironment.userVisitorId;
      var isOptOut = telemetry.platformPrivacyLevel === Ws1Level.MINIMAL;
      this._prefix.isSignedOut = isSignedOut;
      this._prefix.isOptOut = isOptOut;
      this._prefix.isMissingId = isMissingId;
      this._sessionId.prefix = this._prefix.value;
    };

    return PrefixUserEventListener;
  }();

  var rngBrowser = createCommonjsModule(function (module) {
    // Unique ID creation requires a high quality random # generator.  In the
    // browser this is a little complicated due to unknown quality of Math.random()
    // and inconsistent support for the `crypto` API.  We do the best we can via
    // feature-detection
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && msCrypto.getRandomValues.bind(msCrypto);

    if (getRandomValues) {
      // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
      var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      // Math.random()-based (RNG)
      //
      // If all else fails, use Math.random().  It's fast, but is of unspecified
      // quality.
      var rnds = new Array(16);

      module.exports = function mathRNG() {
        for (var i = 0, r; i < 16; i++) {
          if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
          rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
        }

        return rnds;
      };
    }
  });

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */
  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  function bytesToUuid(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex;
    return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
  }

  var bytesToUuid_1 = bytesToUuid;

  function v4(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }

    options = options || {};
    var rnds = options.random || (options.rng || rngBrowser)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || bytesToUuid_1(rnds);
  }

  var v4_1 = v4;

  /**
   * Cast a value to a timestamp.
   * @param {Number|Date|string} value
   * @returns {number}
   */
  var asTimestamp = function asTimestamp(value) {
    // Date
    if (value instanceof Date) {
      return value.getTime();
    } // Timestamp


    if (typeof value === 'number') {
      return value;
    } // String (Date compatible)


    if (typeof value === 'string') {
      var timestamp = new Date(value).getTime(); // eslint-disable-next-line no-restricted-globals

      return isNaN(timestamp) ? false : timestamp;
    } // Unknown value


    return false;
  };

  function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }
  /**
   * @alias SessionId~State
   */

  var State =
  /*#__PURE__*/
  function () {
    function State() {
      this._created = 0;
      this._lastAccess = 0;
    }
    /**
     * Created Time
     * @returns {number}
     */
    // @ts-ignore


    var _proto = State.prototype;

    /**
     * Populate state from object
     * @param {object} state
     */
    _proto.populate = function populate(state) {
      this._created = state.created;
      this._lastAccess = state.lastAccess;
    }
    /**
     * Return state as object
     * @returns {object}
     */
    ;

    _proto.asObject = function asObject() {
      return {
        created: this._created,
        lastAccess: this._lastAccess
      };
    };

    _createClass$7(State, [{
      key: "created",
      get: function get() {
        return this._created;
      }
      /**
       * Created Time
       * @param {Date|number|string} dateOrTimestamp
       */
      // @ts-ignore
      ,
      set: function set(dateOrTimestamp) {
        this._created = asTimestamp(dateOrTimestamp) || 0;
      }
      /**
       * Last Access Time
       * @returns {number}
       */

    }, {
      key: "lastAccess",
      get: function get() {
        return this._lastAccess;
      }
      /**
       * Last Access Time
       * @param {Date|number|string} dateOrTimestamp
       */
      ,
      set: function set(dateOrTimestamp) {
        this._lastAccess = asTimestamp(dateOrTimestamp) || 0;
      }
    }]);

    return State;
  }();

  function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

  var TimeLimitValidator =
  /*#__PURE__*/
  function () {
    function TimeLimitValidator(ttl) {
      this._ttl = ttl;
    }
    /**
     * Current TTL
     * @returns {number}
     */


    var _proto = TimeLimitValidator.prototype;

    /**
     * Is the given state valid
     * @param {number|Date} referenceTime
     */
    _proto.isValid = function isValid(referenceTime) {
      var now = Date.now();

      if (typeof referenceTime === 'number') {
        return now <= referenceTime + this._ttl;
      }

      if (referenceTime instanceof Date) {
        return now <= referenceTime.getTime() + this._ttl;
      } // referenceTime is of unknown type


      return false;
    };

    _createClass$8(TimeLimitValidator, [{
      key: "ttl",
      get: function get() {
        return this._ttl;
      }
    }]);

    return TimeLimitValidator;
  }();

  var MINUTE = 60 * 1000;
  var HOUR = 60 * MINUTE;
  var MAX_LIFETIME = 24 * HOUR;
  var MAX_IDLE = 30 * MINUTE; // TODO: Align this with with Validator Interface design
  // https://github.com/zendframework/zend-validator/blob/master/src/ValidatorInterface.php

  var StateValidator =
  /*#__PURE__*/
  function () {
    function StateValidator() {
      this._idleValidator = new TimeLimitValidator(MAX_IDLE);
      this._lifetimeValidator = new TimeLimitValidator(MAX_LIFETIME);
    }
    /**
     * Is the given state valid
     * @param {SessionId~State} state
     */


    var _proto = StateValidator.prototype;

    _proto.isValid = function isValid(state) {
      return this._idleValidator.isValid(state.lastAccess) && this._lifetimeValidator.isValid(state.created);
    };

    return StateValidator;
  }();

  var SessionIdHydrator =
  /*#__PURE__*/
  function () {
    function SessionIdHydrator() {}

    var _proto = SessionIdHydrator.prototype;

    _proto.hydrate = function hydrate(sessionId, obj) {
      if (!obj) {
        return;
      }

      if (obj.state) {
        sessionId._state.populate(obj.state);
      }

      if (obj.prefix) {
        // eslint-disable-next-line no-param-reassign
        sessionId.prefix = obj.prefix;
      }

      if (obj.id) {
        // eslint-disable-next-line no-param-reassign
        sessionId._id = obj.id;
      }
    };

    return SessionIdHydrator;
  }();

  //TODO: It would be nice to generalize this to be a general serializer/unserializer
  var SessionIdExtractor =
  /*#__PURE__*/
  function () {
    function SessionIdExtractor() {}

    var _proto = SessionIdExtractor.prototype;

    _proto.extract = function extract(sessionId) {
      return {
        id: sessionId._id,
        prefix: sessionId._prefix,
        // Delegate serialization for sub-objects
        state: sessionId._state.asObject()
      };
    };

    return SessionIdExtractor;
  }();

  function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }
  var replaceRegExp = /[^0-9a-f]/ig;
  var DEFAULT_CACHE_KEY = 'identifier-session-id';

  var SessionId =
  /*#__PURE__*/
  function () {
    function SessionId() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._id = undefined;
      this._prefix = config.prefix || 'unknwn';
      this._state = new State();
      this._validator = config.validator || new StateValidator();
      this._hydrator = config.hydrator || new SessionIdHydrator();
      this._extractor = config.extractor || new SessionIdExtractor();
      this._cacheThrottle = 1000;
      this._cacheLastSave = 0;
      this._cacheKey = config.cacheKey || DEFAULT_CACHE_KEY;
      this._cache = config.cache;
      this.load();
    }
    /**
     * Prefix
     * @param {string} value
     */


    var _proto = SessionId.prototype;

    /**
     * Default string representation
     * @returns {string}
     */
    _proto.toString = function toString() {
      return this.value;
    }
    /**
     * Regenerate the ID
     * @private
     */
    ;

    _proto.regenerate = function regenerate() {
      this._id = "".concat(v4_1()).concat(v4_1()).replace(replaceRegExp, '');
      this._state.created = Date.now();
      this._state.lastAccess = Date.now(); // Save because it's a regeneration, do not throttle

      this.save();
    }
    /**
     * Load state from
     */
    ;

    _proto.load = function load() {
      if (!this._cache) {
        return;
      }

      var data = this._cache.get(this._cacheKey);

      if (!data) {
        return;
      }

      this._hydrator.hydrate(this, data);
    }
    /**
     * Save state to cache
     */
    ;

    _proto.save = function save() {
      if (!this._cache) {
        return;
      }

      var data = this._extractor.extract(this);

      this._cache.set(this._cacheKey, data);

      this._cacheLastSave = Date.now();
    }
    /**
     * Save to cache, but max out at one save per {cacheThrottle} ms.
     */
    ;

    _proto.throttledSave = function throttledSave() {
      if (Date.now() - this._cacheLastSave > this._cacheThrottle) {
        this.save();
      }
    };

    _createClass$9(SessionId, [{
      key: "prefix",
      set: function set(value) {
        // Error check? [a-wyz]{6}?
        this._prefix = value;
      }
      /**
       * Prefix
       * @returns {string}
       */
      ,
      get: function get() {
        return this._prefix;
      }
      /**
       * ID
       * @returns {string}
       */

    }, {
      key: "value",
      get: function get() {
        if (this.isExpired) {
          this.regenerate();
        }

        this._state.lastAccess = Date.now(); // Prevent from spamming the cache on every read access.

        this.throttledSave();
        return "".concat(this.prefix, "x").concat(this._id);
      }
      /**
       * Is the ID still valid
       * @returns {*}
       */

    }, {
      key: "isExpired",
      get: function get() {
        return !this._validator.isValid(this._state);
      }
    }]);

    return SessionId;
  }();

  var ShortTermIdExtractor =
  /*#__PURE__*/
  function () {
    function ShortTermIdExtractor() {}

    var _proto = ShortTermIdExtractor.prototype;

    _proto.extract = function extract(shortTermId) {
      return {
        id: shortTermId._id,
        state: shortTermId._state.asObject()
      };
    };

    return ShortTermIdExtractor;
  }();

  var ShortTermIdHydrator =
  /*#__PURE__*/
  function () {
    function ShortTermIdHydrator() {}

    var _proto = ShortTermIdHydrator.prototype;

    _proto.hydrate = function hydrate(shortTermId, obj) {
      if (!obj) {
        return;
      }

      if (obj.state) {
        shortTermId._state.populate(obj.state);
      }

      if (obj.id) {
        // eslint-disable-next-line no-param-reassign
        shortTermId._id = obj.id;
      }
    };

    return ShortTermIdHydrator;
  }();

  var MINUTE$1 = 60 * 1000;
  var HOUR$1 = 60 * MINUTE$1;
  var MAX_LIFETIME$1 = 48 * HOUR$1; // TODO: Align this with with Validator Interface design
  // https://github.com/zendframework/zend-validator/blob/master/src/ValidatorInterface.php

  var StateValidator$1 =
  /*#__PURE__*/
  function () {
    function StateValidator() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._lifetimeValidator = config.validator || new TimeLimitValidator(MAX_LIFETIME$1);
    }
    /**
     * Is the given state valid
     * @param {ShortTermId~State} state
     */


    var _proto = StateValidator.prototype;

    _proto.isValid = function isValid(state) {
      return this._lifetimeValidator.isValid(state.created);
    };

    return StateValidator;
  }();

  function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }
  /**
   * @alias ShortTermId~State
   */

  var State$1 =
  /*#__PURE__*/
  function () {
    function State() {
      this._created = 0;
    }
    /**
     * Created Time
     * @returns {number}
     */
    // @ts-ignore


    var _proto = State.prototype;

    /**
     * Populate state from object
     * @param {object} state
     */
    _proto.populate = function populate(state) {
      this._created = state.created;
    }
    /**
     * Return state as object
     * @returns {object}
     */
    ;

    _proto.asObject = function asObject() {
      return {
        created: this._created
      };
    };

    _createClass$a(State, [{
      key: "created",
      get: function get() {
        return this._created;
      }
      /**
       * Created Time
       * @param {Date|number|string} dateOrTimestamp
       */
      // @ts-ignore
      ,
      set: function set(dateOrTimestamp) {
        this._created = asTimestamp(dateOrTimestamp) || 0;
      }
    }]);

    return State;
  }();

  function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); return Constructor; }
  var replaceRegExp$1 = /[^0-9a-f]/ig;
  /**
   * Default Key for storing the Id to the cache.
   * @type {string}
   */

  var DEFAULT_CACHE_KEY$1 = 'identifier-short-term-id';

  var ShortTermId =
  /*#__PURE__*/
  function () {
    function ShortTermId() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._id = undefined;
      this._state = new State$1();
      this._validator = config.validator || new StateValidator$1();
      this._hydrator = config.hydrator || new ShortTermIdHydrator();
      this._extractor = config.extractor || new ShortTermIdExtractor();
      this._cacheKey = config.cacheKey || DEFAULT_CACHE_KEY$1;

      if (config.appName) {
        var appName = config.appName.toLowerCase();
        this._cacheKey = "".concat(this._cacheKey, "-").concat(appName);
      } // Cache


      this._cache = config.cache;
      this.load();
    }
    /**
     * ID
     * @returns {string}
     */


    var _proto = ShortTermId.prototype;

    /**
     * Default string representation
     * @returns {string}
     */
    _proto.toString = function toString() {
      return this.value;
    }
    /**
     * Regenerate the ID
     * @private
     */
    ;

    _proto.regenerate = function regenerate() {
      this._id = "".concat(v4_1()).concat(v4_1()).replace(replaceRegExp$1, '');
      this._state.created = Date.now();
      this.save();
    }
    /**
     * Load state from
     */
    ;

    _proto.load = function load() {
      if (!this._cache) {
        return;
      }

      var data = this._cache.get(this._cacheKey);

      if (!data) {
        return;
      }

      this._hydrator.hydrate(this, data);
    }
    /**
     * Save state to cache
     */
    ;

    _proto.save = function save() {
      if (!this._cache) {
        return;
      }

      var data = this._extractor.extract(this);

      this._cache.set(this._cacheKey, data);
    };

    _createClass$b(ShortTermId, [{
      key: "value",
      get: function get() {
        if (this.isExpired) {
          this.regenerate();
        }

        return this._id;
      }
      /**
       * Is the ID still valid
       * @returns {*}
       */

    }, {
      key: "isExpired",
      get: function get() {
        return !this._validator.isValid(this._state);
      }
    }]);

    return ShortTermId;
  }();

  var TracingIdExtractor =
  /*#__PURE__*/
  function () {
    function TracingIdExtractor() {}

    var _proto = TracingIdExtractor.prototype;

    _proto.extract = function extract(tracingId) {
      return {
        id: tracingId._id,
        state: tracingId._state.asObject()
      };
    };

    return TracingIdExtractor;
  }();

  var TracingIdHydrator =
  /*#__PURE__*/
  function () {
    function TracingIdHydrator() {}

    var _proto = TracingIdHydrator.prototype;

    _proto.hydrate = function hydrate(tracingId, obj) {
      if (!obj) {
        return;
      }

      if (obj.state) {
        tracingId._state.populate(obj.state);
      }

      if (obj.id) {
        // eslint-disable-next-line no-param-reassign
        tracingId._id = obj.id;
      }
    };

    return TracingIdHydrator;
  }();

  function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); return Constructor; }
  /**
   * @alias TracingId~State
   */

  var State$2 =
  /*#__PURE__*/
  function () {
    function State() {
      this._created = 0;
    }
    /**
     * Created Time
     * @returns {number}
     */
    // @ts-ignore


    var _proto = State.prototype;

    /**
     * Populate state from object
     * @param {object} state
     */
    _proto.populate = function populate(state) {
      this._created = state.created;
    }
    /**
     * Return state as object
     * @returns {object}
     */
    ;

    _proto.asObject = function asObject() {
      return {
        created: this._created
      };
    };

    _createClass$c(State, [{
      key: "created",
      get: function get() {
        return this._created;
      }
      /**
       * Created Time
       * @param {Date|number|string} dateOrTimestamp
       */
      // @ts-ignore
      ,
      set: function set(dateOrTimestamp) {
        this._created = asTimestamp(dateOrTimestamp) || 0;
      }
    }]);

    return State;
  }();

  function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); return Constructor; }

  var TracingId =
  /*#__PURE__*/
  function () {
    function TracingId() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._id = undefined;
      this._state = new State$2();
      this._hydrator = config.hydrator || new TracingIdHydrator();
      this._extractor = config.extractor || new TracingIdExtractor();
    }
    /**
     * ID
     * @returns {string}
     */


    var _proto = TracingId.prototype;

    /**
     * Default string representation
     * @returns {string}
     */
    _proto.toString = function toString() {
      return this.value;
    }
    /**
     * Regenerate the ID
     * @private
     */
    ;

    _proto.regenerate = function regenerate() {
      this._id = v4_1();
      this._state.created = Date.now();
    };

    _createClass$d(TracingId, [{
      key: "value",
      get: function get() {
        this.regenerate();
        return this._id;
      }
    }]);

    return TracingId;
  }();

  function _defineProperties$e(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$e(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$e(Constructor.prototype, protoProps); if (staticProps) _defineProperties$e(Constructor, staticProps); return Constructor; }

  var DispatchedEvent =
  /*#__PURE__*/
  function () {
    function DispatchedEvent() {
      this._inputEvent = undefined;
      this._filteredEvent = undefined;
      this._payloads = new Map();
    }
    /**
     * Input Event for the dispatch
     * @returns {?Object}
     */


    var _proto = DispatchedEvent.prototype;

    /**
     * Set the payload for a given plugin id
     * @param {string} id
     * @param {object} payload
     */
    _proto.setPayload = function setPayload(id, payload) {
      this._payloads.set(id, payload);
    };

    _createClass$e(DispatchedEvent, [{
      key: "inputEvent",
      get: function get() {
        return this._inputEvent;
      }
      /**
       * Input Event for the dispatch
       * @param {?Object} inputEvent
       */
      ,
      set: function set(inputEvent) {
        this._inputEvent = inputEvent;
      }
      /**
       * Raw Event as passed into GCT
       * @returns {Object}
       * @deprecated
       */

    }, {
      key: "rawEvent",
      get: function get() {
        return this._inputEvent;
      }
      /**
       * Raw Event as passed into GCT
       * @param {Object} rawEvent
       * @deprecated
       */
      ,
      set: function set(rawEvent) {
        this._inputEvent = rawEvent;
      }
      /**
       * Filtered Event as passed into plugins
       * @returns {Object}
       */

    }, {
      key: "filteredEvent",
      get: function get() {
        return this._filteredEvent;
      }
      /**
       * Filtered Event as passed into plugins
       * @param {Object} filteredEvent
       */
      ,
      set: function set(filteredEvent) {
        this._filteredEvent = filteredEvent;
      }
      /**
       * Payload Map keyed by Plugin Id
       * `result[pluginId] = payloadObject`
       *
       * @returns {Map}
       */

    }, {
      key: "payloads",
      get: function get() {
        return this._payloads;
      }
    }]);

    return DispatchedEvent;
  }();

  function _defineProperties$f(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$f(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$f(Constructor.prototype, protoProps); if (staticProps) _defineProperties$f(Constructor, staticProps); return Constructor; }

  var EventInspector =
  /*#__PURE__*/
  function () {
    function EventInspector() {
      this._enabled = false;
      this._events = [];
    }
    /**
     * Enable the event Inspector
     */


    var _proto = EventInspector.prototype;

    _proto.enable = function enable() {
      this._enabled = true;
    }
    /**
     * Disable the event inspector
     */
    ;

    _proto.disable = function disable() {
      this._enabled = false;
    }
    /**
     * Is the event inspector enabled
     * @returns {boolean}
     */
    ;

    /**
     * Add an event to the event list.
     * If no preconfigured object is defined, a new one will be created
     * @param {DispatchedEvent} [dispatchedEvent]
     * @returns {DispatchedEvent}
     */
    _proto.addEvent = function addEvent(dispatchedEvent) {
      // TypeCheck?
      if (!dispatchedEvent) {
        // eslint-disable-next-line no-param-reassign
        dispatchedEvent = new DispatchedEvent();
      }

      if (this.isEnabled) {
        this.events.push(dispatchedEvent);
      }

      return dispatchedEvent;
    }
    /**
     * Clear the stored events
     */
    ;

    _proto.clear = function clear() {
      this._events = [];
    };

    _createClass$f(EventInspector, [{
      key: "isEnabled",
      get: function get() {
        return this._enabled;
      }
      /**
       * Return the full list of Events tracked
       * @returns {DispatchedEvent[]}
       */

    }, {
      key: "events",
      get: function get() {
        return this._events;
      }
    }]);

    return EventInspector;
  }();

  function _defineProperties$g(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$g(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$g(Constructor.prototype, protoProps); if (staticProps) _defineProperties$g(Constructor, staticProps); return Constructor; }

  var AbstractValidator =
  /*#__PURE__*/
  function () {
    function AbstractValidator() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._value = undefined;
      this._messages = new Map();
      this._messageTemplates = options.messageTemplates || {};
    }

    var _proto = AbstractValidator.prototype;

    _proto._createMessage = function _createMessage(messageKey, value) {
      var template = this._messageTemplates[messageKey];

      if (!template) {
        throw new Error("UNKNOWN_MESSAGE_KEY: No template found for the message key: ".concat(messageKey, "."));
      }

      return template.replace('{value}', value);
    };

    _proto.error = function error(messageKey, value) {
      this._messages.set(messageKey, this._createMessage(messageKey, value === undefined ? this.value : value));
    };

    _createClass$g(AbstractValidator, [{
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        this._value = value;

        this._messages.clear();
      }
    }, {
      key: "messages",
      get: function get() {
        return this._messages;
      }
    }]);

    return AbstractValidator;
  }();

  function _inheritsLoose$7(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var INVALID_NP_ACCOUNT_LOCALE = 'invalidNpAccountLocale';

  var messageTemplates = _defineProperty$3({}, INVALID_NP_ACCOUNT_LOCALE, 'Invalid NP Account Locale provided.');

  var localeRegex = /^[a-z]{2}_[A-Z]{2}$/;

  var NpAccountLocaleValidator =
  /*#__PURE__*/
  function (_AbstractValidator) {
    _inheritsLoose$7(NpAccountLocaleValidator, _AbstractValidator);

    function NpAccountLocaleValidator() {
      return _AbstractValidator.call(this, {
        messageTemplates: messageTemplates
      }) || this;
    }

    var _proto = NpAccountLocaleValidator.prototype;

    _proto.isValid = function isValid(value) {
      this.value = value;

      if (!localeRegex.test(value)) {
        this.error(INVALID_NP_ACCOUNT_LOCALE);
        return false;
      }

      return true;
    };

    return NpAccountLocaleValidator;
  }(AbstractValidator);

  function _slicedToArray$1(arr, i) { return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _nonIterableRest$1(); }

  function _nonIterableRest$1() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$1(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$1(arr) { if (Array.isArray(arr)) return arr; }

  /**
   * @private
   * @type {RegExp}
   */
  var regex;
  /**
   * @private
   * @returns {RegExp}
   */

  function getComponentParseRegex() {
    if (!regex) {
      regex = new RegExp('^' + '([a-z]{2,3})' // Language    2*3 ALPHA
      + '(?:[-_]([a-z]{4}))?' // Script  4   ALPHA
      + '(?:[-_]((?:[a-z]{2})|(?:[0-9]{3})))?' // Region  2* ALPHA | 3 * DIGIT
      + '((?:[-_]' // Variants: Leading "-" included in match
      + '(?:(?:[a-z0-9]{5,8})|(?:[0-9][a-z0-9]{3}))' // Variant: 5*8 ALNUM | DIGIT, 3*ALNUM
      + ')*)' + '((?:' // Extensions/Private Use, leading "-" included in match
      + '(?:[-_][a-wyz0-9]{1})' // Singleton
      + '(?:[-_][a-z0-9]{2,8})+' // One or more patterns
      + ')*)' + '([-_]x' // Private Use
      + '(?:[-_][a-z0-9]{1,8})+' // x- 1*8 ALNUM
      + ')?' + '$', 'i');
    }

    return regex;
  }
  /**
   * Convert the variant string match to an array.
   * @private
   * @param {string} variantString
   * @returns {string[]} Array of variant sub-tags
   */


  function convertVariantStringMatchToArray(variantString) {
    if (!variantString.length) {
      return [];
    }

    return variantString.split(/-|_/).slice(1);
  }
  /**
   * @typedef {Array} Parse~ComponentList
   * @property {string}   Parse~ComponentList.0 - Language Id
   * @property {string}   Parse~ComponentList.1 - Script Id
   * @property {string}   Parse~ComponentList.2 - Region Id
   * @property {string[]} Parse~ComponentList.3 - Variants
   * @property {Array}    Parse~ComponentList.4 - Extensions
   *
   */

  /**
   * Returns the component parts of the Tag.
   * @param {string} tagString
   * @returns {Parse~ComponentList}  Returns the result as an array
   *  to avoid the overhead of object initialization.  Internal use only.
   * @private
   */


  function asComponents(tagString) {
    var matches = getComponentParseRegex().exec(tagString);

    if (!matches) {
      return null;
    }

    var _matches = _slicedToArray$1(matches, 5),
        languageId = _matches[1],
        scriptId = _matches[2],
        regionId = _matches[3],
        variantString = _matches[4];

    var variantArray = convertVariantStringMatchToArray(variantString); // Extensions not implemented yet.

    var extensionArray = [];
    return [languageId, scriptId, regionId, variantArray, extensionArray];
  }
  /**
   * @typedef {Object} LanguageObject
   * @property {string} languageId
   * @property {string} scriptId
   * @property {string} regionId
   * @property {string[]} variants
   * @property {Array} extensions
   */

  /**
   * Create a Language Tag from a string representation.
   *
   * @param {string} tagString
   * @return {LanguageObject}  Language Tag, null on failure
   * @see asComponents
   */


  var parseLanguageTag = function parseLanguageTag(tagString) {
    var componentParts = asComponents(tagString);

    if (!componentParts) {
      return null;
    }

    var _componentParts = _slicedToArray$1(componentParts, 5),
        languageId = _componentParts[0],
        scriptId = _componentParts[1],
        regionId = _componentParts[2],
        variants = _componentParts[3],
        extensions = _componentParts[4];

    return {
      languageId: languageId,
      scriptId: scriptId,
      regionId: regionId,
      variants: variants,
      extensions: extensions
    };
  };

  function _inheritsLoose$8(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var INVALID_NP_ACCOUNT_LANGUAGE = 'invalidPsnAccountLanguage';

  var messageTemplates$1 = _defineProperty$4({}, INVALID_NP_ACCOUNT_LANGUAGE, 'Invalid PSN Account Language provided.');

  var PsnAccountLanguageValidator =
  /*#__PURE__*/
  function (_AbstractValidator) {
    _inheritsLoose$8(PsnAccountLanguageValidator, _AbstractValidator);

    function PsnAccountLanguageValidator() {
      return _AbstractValidator.call(this, {
        messageTemplates: messageTemplates$1
      }) || this;
    }

    var _proto = PsnAccountLanguageValidator.prototype;

    _proto.isValid = function isValid(value) {
      this.value = value;
      var parsedLanguage = parseLanguageTag(value);
      /**
       * Requirements:
       *    Value is parsable as BCP-47
       *    Value contains a Language Id (e.g.: Not x-lobjan (private extension only)
       *
       */

      if (!parsedLanguage || !parsedLanguage.languageId) {
        this.error(INVALID_NP_ACCOUNT_LANGUAGE);
        return false;
      }

      return true;
    };

    return PsnAccountLanguageValidator;
  }(AbstractValidator);

  function _inheritsLoose$9(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var INVALID_NP_ACCOUNT_REGION = 'invalidPsnAccountRegion';

  var messageTemplates$2 = _defineProperty$5({}, INVALID_NP_ACCOUNT_REGION, 'Invalid PSN Account Region provided.');

  var localeRegex$1 = /^[A-Z]{2}$/;

  var PsnAccountRegionValidator =
  /*#__PURE__*/
  function (_AbstractValidator) {
    _inheritsLoose$9(PsnAccountRegionValidator, _AbstractValidator);

    function PsnAccountRegionValidator() {
      return _AbstractValidator.call(this, {
        messageTemplates: messageTemplates$2
      }) || this;
    }

    var _proto = PsnAccountRegionValidator.prototype;

    _proto.isValid = function isValid(value) {
      this.value = value;

      if (!localeRegex$1.test(value)) {
        this.error(INVALID_NP_ACCOUNT_REGION);
        return false;
      }

      return true;
    };

    return PsnAccountRegionValidator;
  }(AbstractValidator);

  // Javascript strings are encoded in UTF-16. Each position in a javascript
  // string is a UTF-16 code unit, which may or may not require multiple bytes
  // to encode in UTF-8. Also, a "character" can actually be composed of two
  // UTF-16 code units, which should be a "high surrogate" code unit followed by a
  // "low surrogate" code unit. However, Javascript will happily accept malformed
  // strings, with high or low surrogates appearing alone.
  var isHighSurrogate = function isHighSurrogate(v) {
    return v >= 0xD800 && v <= 0xDBFF;
  }; // Low surrogates actually have *higher* values than high surrogates. They are
  // named "low" surrogates because the spare bits are used to encode the lower
  // portion of the code point.

  var isLowSurrogate = function isLowSurrogate(v) {
    return v >= 0xDC00 && v <= 0xDFFF;
  };
  /**
   * Gets the number of bytes needed to encode a Javascript code unit in UTF-8.
   *
   * @param {string} v The code unit to encode.
   * @param {number} i The code unit's position in the string.
   * @param {string} str The string that the code unit is part of.
   */

  var utf8Bytes = function utf8Bytes(v, i, str) {
    var code = v.charCodeAt(0);

    if (code <= 0x7f) {
      // "Low ASCII compatible"
      return 1;
    }

    if (code <= 0x7ff) {
      return 2;
    }

    if (isLowSurrogate(code) && isHighSurrogate(str.charCodeAt(i - 1))) {
      // A low surrogate following a high surrogate means they will be
      // combined into a 4-byte UTF-8 character. And 3 bytes of that were
      // already accounted for that when we encountered the high surrogate, so
      // just add one byte here. Also, charCodeAt returns NaN for values out-of-bounds,
      // so the conditional is safe to call without bounds-checking i.
      return 1;
    } // Characters from 0x800 to 0xD799 (below high surrogate).
    // Characters from 0xE000 to 0xFFFF (above low surrogate).
    // Malformed low surrogates.
    // High surrogates (we won't find out whether or not they're malformed
    //   until we read the next character. Either way, 3 bytes).


    return 3;
  };
  /**
   * Gets the number of bytes needed to encode a Javascript string in UTF-8.
   *
   * @param {string} value The string in check.
   */

  var stringInBytes = function stringInBytes(value) {
    var i;
    var bytes = 0;

    for (i = 0; i < value.length; i += 1) {
      bytes += utf8Bytes(value[i], i, value);
    }

    return bytes;
  };

  var truncateByteLength = function truncateByteLength(value, limit) {
    var i;
    var bytes = 0;

    for (i = 0; i < value.length; i += 1) {
      bytes += utf8Bytes(value[i], i, value);

      if (bytes > limit) {
        break;
      }
    } // Don't chop a code point in half (but if the caller sent you a malformed
    // string, that's on them.) We don't need to bounds-check i, because charCodeAt returns NaN
    // for out-of-bounds positions. Both isHighSurrogate and isLowSurrogate will return false
    // when called with NaN as the parameter.


    if (isHighSurrogate(value.charCodeAt(i - 1)) && isLowSurrogate(value.charCodeAt(i))) {
      i -= 1;
    } // Although we only encode a whole code point, it's entirely possible that
    // a glyph composed of multiple code points could be severed in half. Also,
    // rendering glitches could arise from (e.g.) a right-to-left text portion
    // of a string becoming unclosed due to truncation.


    return value.substr(0, i);
  };

  var formatUriComponents = function formatUriComponents(parsedUri) {
    if (!parsedUri) {
      return '';
    }

    var result = []; // Empty scheme not a possibility

    if (parsedUri.scheme) {
      result.push("".concat(parsedUri.scheme, ":"));
    } // Empty Authority is possible


    if (!isUndefined(parsedUri.host) || !isUndefined(parsedUri.port)) {
      result.push('//');

      if (parsedUri.host) {
        result.push(parsedUri.host);
      }

      if (!isUndefined(parsedUri.port)) {
        result.push(":".concat(parsedUri.port));
      }
    } // Empty Path is not possible


    if (parsedUri.path) {
      result.push(parsedUri.path);
    } // Empty Query is possible


    if (!isUndefined(parsedUri.query)) {
      result.push("?".concat(parsedUri.query));
    }

    if (!isUndefined(parsedUri.hash)) {
      result.push("#".concat(parsedUri.hash));
    }

    return result.join('');
  };

  /**
   * Parse Scheme
   *  ^                    Anchor
   *  (                    Begin Capture
   *      [A-Za-z]           Leading Alpha
   *      [A-Za-z0-9.+-]*    Optional Continuation Characters
   *  )                    End Capture
   *  :                    Scheme Marker
   */

  var SCHEME_REGEX = /^([A-Za-z][A-Za-z0-9.+-]*):/;
  /**
   * Parse Authority
   * ^              Anchor
   * \/\/           Begin Authority Marker (//)
   * (              Begin Capture
   *   [^/\\?#]*       All characters except PATH_ROOT (/) PATH_ROOT (\) QUERY START (?) HASH START (#)
   * )              End Capture
   */

  var AUTHORITY_REGEX = /^\/\/([^/\\?#]*)/;
  /**
   * Parse Authority Port
   * :              Begin Port Marker (:)
   * [\d]{1,5}      Digit (1-5 length)
   * $              Anchor
   */

  var AUTHORITY_PORT_REGEX = /:[\d]{1,5}$/;
  /**
   * Parse Path
   * ^              Anchor
   * (              Begin Capture
   *   [^?#]*         All characters except QUERY START (?) HASH START (#)
   * )              End Capture
   */

  var PATH_REGEX = /^[^?#]*/;
  /**
   * Parse Query
   * ^              Anchor
   * ?              Begin Query Marker
   * (              Begin Capture
   *   [^#]*         All characters except HASH START (#)
   * )              End Capture
   */

  var QUERY_REGEX = /^\?([^#]*)/;

  var parseScheme = function parseScheme(uri) {
    var matches = SCHEME_REGEX.exec(uri);
    return matches ? matches[1] : undefined;
  };
  /**
   * Parse the Authority
   * Must be anchored at the root of the string
   * @param {string} uri
   */


  var parseAuthority = function parseAuthority(uri) {
    var matches = AUTHORITY_REGEX.exec(uri);

    if (!matches) {
      return undefined;
    }

    var authority = matches[1];
    var remainder = authority;
    var port; // User Info

    if (remainder.indexOf('@') !== -1) {
      var segments = remainder.split('@');
      remainder = segments.pop(); // userInfo = segments.join('@');  // USERINFO Support if extracted as standalone library
    }

    matches = AUTHORITY_PORT_REGEX.exec(remainder);

    if (matches) {
      port = matches[0].substr(1);
      var portLength = matches[0].length;
      remainder = remainder.substr(0, remainder.length - portLength);
    }

    return {
      authority: authority,
      host: remainder,
      port: port
    };
  };
  /**
   * Must be anchored to start of path to work as expected.
   * @param {string} url
   */


  var parsePath = function parsePath(url) {
    var match = PATH_REGEX.exec(url);

    if (!match) {
      return undefined;
    }

    return match[0];
  };
  /**
   * Must be anchored to start of path to work as expected.
   * @param {string} url
   */


  var parseQuery = function parseQuery(url) {
    var match = QUERY_REGEX.exec(url);

    if (!match) {
      return undefined;
    }

    return match[1];
  };

  var parseUri = function parseUri(uri) {
    var result = {
      scheme: undefined,
      authority: undefined,
      userInfo: undefined,
      port: undefined,
      path: '',
      query: undefined,
      hash: undefined
    };

    if (!isString$3(uri)) {
      return undefined;
    }

    var remainder = uri; // Scheme Parse

    var scheme = parseScheme(remainder);

    if (!isUndefined(scheme)) {
      remainder = remainder.substr(scheme.length + 1);
      result.scheme = scheme;
    } // Authority Parse


    var authority = parseAuthority(remainder);

    if (!isUndefined(authority)) {
      remainder = remainder.substr(authority.authority.length + 2);
      result.authority = authority.authority; // TODO: no userInfo property on authority
      // @ts-ignore

      result.userInfo = authority.userInfo;
      result.port = authority.port;
      result.host = authority.host;
    } // In case we aer just parsing only a hostname


    if (!remainder) {
      return result;
    } // Path


    var path = parsePath(remainder);

    if (!isUndefined(path)) {
      result.path = path;
      remainder = remainder.substr(path.length);
    }

    if (!remainder) {
      return result;
    }

    var query = parseQuery(remainder);

    if (!isUndefined(query)) {
      result.query = query;
      remainder = remainder.substr(query.length + 1);
    }

    if (remainder && remainder.substr(0, 1) === '#') {
      result.hash = remainder.substr(1);
    }

    return result;
  };

  var INVALID_URI = '';

  var censorUri = function censorUri(possibleUri, censorCallback) {
    var parsedUri = parseUri(possibleUri);

    if (!parsedUri) {
      return INVALID_URI;
    }

    return formatUriComponents(censorCallback(parsedUri));
  };

  var queryComponentAsKeyValue = function queryComponentAsKeyValue(component) {
    if (!component.length) {
      return undefined;
    }

    var parts = component.split('=');
    var key = parts.shift();
    var value = parts.length ? parts.join('=') : undefined;
    return [key, value];
  };
  /**
   * Return the query string as an array.
   * If the string is empty, then an empty array is returned
   * @param {string} queryString
   * @returns {Array[]}  Array of [?string key, ?string value] pairs
   */


  var queryStringAsArray = function queryStringAsArray(queryString) {
    if (isUndefined(queryString)) {
      return [];
    }

    return queryString.split('&').map(function (component) {
      return queryComponentAsKeyValue(component);
    });
  };

  /**
   * Replaces a regex match with either X or 9
   * @param match
   * @param p1
   * @returns {string}
   */

  var replacer = function replacer(_match, p1) {
    return p1 ? 'x' : '9';
  };
  /**
   * Matches either a-z or 0-9.
   * Intended to be run as a replacer
   * @type {RegExp}
   */


  var regexp = /([a-z])|([0-9])/gi;
  /**
   * Censor a given value.
   * @param value
   */

  var censor = function censor(value) {
    return value.replace(regexp, replacer);
  };
  /**
   * Given a query component, censors the appropriate portion
   * @param parts
   * @returns {string}
   */


  var censorComponent = function censorComponent(parts) {
    if (!parts) {
      return '';
    } // TODO: what if parts[0] is undefined
    // @ts-ignore


    return isUndefined(parts[1]) ? censor(parts[0]) : "".concat(parts[0], "=").concat(censor(parts[1]));
  };

  var replaceValueByCharacterCategory = function replaceValueByCharacterCategory(query) {
    return queryStringAsArray(query).map(function (component) {
      return censorComponent(component);
    }).join('&');
  };

  function _slicedToArray$2(arr, i) { return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _nonIterableRest$2(); }

  function _nonIterableRest$2() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$2(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$2(arr) { if (Array.isArray(arr)) return arr; }
  /**
   * Parse a query string.
   *
   * Duplicated query parameters are populated on a "last-wins" basis, i.e. subsequent keys will
   * overwrite existing keys of the same name.
   *
   * @param {string} searchString
   * @returns {Object<string,string>}  Parsed hash of Query String
   */

  var queryStringAsObject = function queryStringAsObject(searchString) {
    var result = {};
    queryStringAsArray(searchString).forEach(function (input) {
      if (input === undefined) {
        return;
      }

      var _input = _slicedToArray$2(input, 2),
          key = _input[0],
          value = _input[1];

      var decodedString = isString$3(key) ? decodeURIComponent(key) : '';
      var decodedValue = isString$3(value) ? decodeURIComponent(value) : '';
      result[decodedString] = decodedValue;
    });
    return result;
  };

  // From MDN
  var isLocalStorageAvailable = function isLocalStorageAvailable() {
    if (typeof window === 'undefined') {
      return false;
    }

    var storage;

    try {
      // eslint-disable-next-line no-undef
      storage = window.localStorage;
      var x = '__storage_test__';
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      if (typeof DOMException === 'undefined' || !storage) {
        return false;
      } // eslint-disable-next-line no-undef


      return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') && storage.length !== 0;
    }
  };

  var compact = function compact(array) {
    var length = array == null ? 0 : array.length;
    var srcIndex = 0;
    var resultIndex = 0;
    var result = [];

    while (srcIndex < length) {
      var value = array[srcIndex];

      if (value) {
        result[resultIndex] = value;
        resultIndex += 1;
      }

      srcIndex += 1;
    }

    return result;
  };

  /**
   *
   * @param {object} instance
   * @param {string[]} requiredFields
   * @throws MissingProperty
   */

  var checkRequiredProperties = function checkRequiredProperties(instance) {
    var requiredFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var missingFields = compact(requiredFields.map(function (field) {
      return typeof instance[field] === 'undefined' ? field : '';
    }));

    if (missingFields.length) {
      var keys = missingFields.map(function (key) {
        return "\"".concat(key, "\"");
      }).join(', ');
      throw new Error("MissingProperty: The following fields are required: ".concat(keys));
    }
  };

  function _defineProperties$h(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$h(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$h(Constructor.prototype, protoProps); if (staticProps) _defineProperties$h(Constructor, staticProps); return Constructor; }
  var requiredProperties = ['name', 'date', 'description', 'overrideKey'];
  /**
   * @typedef {Object} Deprecation~DeprecationConfig
   * @property {Date|string} date
   * @property {string} name
   * @property {string} description
   * @property {string} overrideKey
   */

  /**
   * Deprecation Class
   */

  var Deprecation =
  /*#__PURE__*/
  function () {
    /**
     * Default constructor
     * @param {Deprecation~DeprecationConfig} config Configuration
     */
    function Deprecation(config) {
      checkRequiredProperties(config, requiredProperties);
      this._date = new Date(config.date);
      this._name = String(config.name);
      this._description = String(config.description);
      this._overrideKey = String(config.overrideKey);
    }
    /**
     * Deprecation Name
     * @returns {string}
     */


    _createClass$h(Deprecation, [{
      key: "name",
      get: function get() {
        return this._name;
      }
      /**
       * Deprecation Date
       * @returns {Date}
       */

    }, {
      key: "date",
      get: function get() {
        return this._date;
      }
      /**
       * Description
       * @returns {string}
       */

    }, {
      key: "description",
      get: function get() {
        return this._description;
      }
      /**
       * Configuration Key to retain behaviour
       * @returns {string}
       */

    }, {
      key: "overrideKey",
      get: function get() {
        return this._overrideKey;
      }
    }]);

    return Deprecation;
  }();

  var findIndex = function findIndex(array, predicate) {
    var length = array == null ? 0 : array.length;

    if (!length) {
      return -1;
    }

    var currentIndex = 0;

    while (currentIndex < length) {
      if (predicate(array[currentIndex])) {
        return currentIndex;
      }

      currentIndex += 1;
    }

    return -1;
  };

  function _defineProperties$i(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$i(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$i(Constructor.prototype, protoProps); if (staticProps) _defineProperties$i(Constructor, staticProps); return Constructor; }

  var Psi =
  /*#__PURE__*/
  function () {
    function Psi(_ref) {
      var name = _ref.name,
          start = _ref.start,
          end = _ref.end;
      this._name = name;
      this._start = new Date(start);
      this._end = new Date(end);
    }

    _createClass$i(Psi, [{
      key: "name",
      get: function get() {
        return this._name;
      }
    }, {
      key: "start",
      get: function get() {
        return this._start;
      }
    }, {
      key: "end",
      get: function get() {
        return this._end;
      }
    }]);

    return Psi;
  }();

  function _defineProperties$j(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$j(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$j(Constructor.prototype, protoProps); if (staticProps) _defineProperties$j(Constructor, staticProps); return Constructor; }
  /**
   *
   * @param {Date} date
   * @returns {string}
   */

  var formatDate = function formatDate(date) {
    return date.toISOString().substr(0, 10);
  };

  var IMPLEMENTATION_DATE = new Date('2017-12-01');
  var rawPsiList = [{
    name: 15,
    start: '2017-08-31T00:00:00Z',
    end: '2017-12-06T23:59:59Z'
  }, {
    name: 16,
    start: '2017-12-07T00:00:00Z',
    end: '2018-03-14T23:59:59Z'
  }, {
    name: 17,
    start: '2018-03-15T00:00:00Z',
    end: '2018-06-06T23:59:59Z'
  }, {
    name: 18,
    start: '2018-06-07T00:00:00Z',
    end: '2018-08-29T23:59:59z'
  }, {
    name: 19,
    start: '2018-08-30T00:00:00Z',
    end: '2018-12-05T23:59:59Z'
  }, {
    name: 20,
    start: '2018-12-06T00:00:00Z',
    end: '2019-03-13T23:59:59Z'
  }, {
    name: 21,
    start: '2019-03-14T00:00:00Z',
    end: '2019-06-05T23:59:59Z'
  }, {
    name: 22,
    start: '2019-06-06T00:00:00Z',
    end: '2019-08-28T23:59:59Z'
  }, {
    name: 23,
    start: '2019-08-29T00:00:00Z',
    end: '2019-12-04T23:59:59Z'
  }, {
    name: 24,
    start: '2019-12-05T00:00:00Z',
    end: '2020-03-11T23:59:59Z'
  }, {
    name: '25(est)',
    start: '2020-03-12T00:00:00Z',
    end: '2020-06-03T23:59:59Z'
  }, {
    name: '26(est)',
    start: '2020-06-04T00:00:00Z',
    end: '2020-08-26T23:59:59Z'
  }, {
    name: '27(est)',
    start: '2020-08-27T00:00:00Z',
    end: '2020-12-02T23:59:59Z'
  }];
  var psiList = rawPsiList.map(function (json) {
    return new Psi(json);
  });
  /**
   * Finds the first PSI containng the given date.
   * @param date
   */

  var findPsiIndexContaining = function findPsiIndexContaining(date) {
    // Deprecated before this feature went live.
    // Ensure that users get one full PSI (16) for warnings.
    if (date < IMPLEMENTATION_DATE) {
      return 0;
    }

    var psiIndex = findIndex(psiList, function (psi) {
      return psi.start <= date && date <= psi.end;
    }); // After last PSI

    if (psiIndex === -1) {
      return psiList.length;
    } // Found PSI


    return psiIndex;
  };

  var DeprecationManager =
  /*#__PURE__*/
  function () {
    function DeprecationManager() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._logger = config.logger;
      this._overrides = config.overrides || {};
      this._referenceDate = config.referenceDate;
      this._alwaysThrow = Boolean(config.alwaysThrow);
    }
    /**
     *
     * @returns {LoggerInterface}
     */


    var _proto = DeprecationManager.prototype;

    /**
     *
     * @param {Deprecation} deprecation
     */
    _proto.trigger = function trigger(deprecation) {
      this.logDeprecation(deprecation);

      if (this._alwaysThrow) {
        this.triggerException(deprecation);
        return;
      }

      if (!this.canTriggerException(deprecation)) {
        return;
      }

      if (this.isOverrideActiveFor(deprecation)) {
        this.logOverrideUsed(deprecation);
        return;
      }

      this.triggerException(deprecation);
    }
    /**
     *
     * @param {Deprecation} deprecation
     */
    ;

    _proto.logOverrideUsed = function logOverrideUsed(deprecation) {
      this.logger.error('A thrown error was muted by the use of configuration.\n' + 'This feature is on track for removal.\n' + 'Update your code immediately.', {
        name: deprecation.name,
        description: deprecation.description,
        overrideKey: deprecation.overrideKey,
        featureRemovalOn: this.featureRemovalDateStringFor(deprecation)
      });
    }
    /**
     *
     * @param {Deprecation} deprecation
     * @returns {boolean}
     */
    ;

    _proto.isOverrideActiveFor = function isOverrideActiveFor(deprecation) {
      return Boolean(this.overrides[deprecation.overrideKey]);
    }
    /**
     * Log a deprecation
     * @param deprecation
     */
    ;

    _proto.logDeprecation = function logDeprecation(deprecation) {
      var _this = this;

      this.logger.warning('Deprecation Notice: ### IMPORTANT ###\n' + 'Feature has been flagged as deprecated, and is on track for active removal.', function () {
        return {
          name: deprecation.name,
          description: deprecation.description,
          deprecatedAsOf: deprecation.date,
          overrideKey: deprecation.overrideKey,
          exceptionsStartOn: _this.exceptionDateStringFor(deprecation),
          featureRemovalOn: _this.featureRemovalDateStringFor(deprecation)
        };
      });
    }
    /**
     * Is is possible to throw an error?
     * @param {Deprecation} deprecation
     * @returns {boolean}
     */
    ;

    _proto.canTriggerException = function canTriggerException(deprecation) {
      var exceptionPsi = this.exceptionPsiFor(deprecation);

      if (!exceptionPsi) {
        return false;
      }

      return this._referenceDate >= exceptionPsi.start;
    }
    /**
     * Throw an error
     * @param {Deprecation} deprecation
     * @throws DeprecationError
     */
    ;

    _proto.triggerException = function triggerException(deprecation) {
      this.logger.error('Feature is deprecated.', {
        name: deprecation.name,
        description: deprecation.description
      });
      throw new Error("DeprecationError: \"".concat(deprecation.name, "\" is deprecated. ").concat(deprecation.description, "."));
    }
    /**
     * Determine when exceptions will be thrown
     * @param deprecation
     * @returns {Object}
     */
    ;

    _proto.exceptionPsiFor = function exceptionPsiFor(deprecation) {
      var thisPsiIndex = findPsiIndexContaining(deprecation.date);
      var targetPsi = psiList[thisPsiIndex + 2];
      return targetPsi || undefined;
    }
    /**
     * Determine when exceptions will be thrown
     * @param deprecation
     * @returns {string}
     */
    ;

    _proto.exceptionDateStringFor = function exceptionDateStringFor(deprecation) {
      var targetPsi = this.exceptionPsiFor(deprecation);
      return targetPsi ? "PSI ".concat(targetPsi.name, " (").concat(formatDate(targetPsi.start), ")") : 'TBD';
    }
    /**
     * Determine when the feature will be removed.
     * @param deprecation
     * @returns {string}
     */
    ;

    _proto.featureRemovalDateStringFor = function featureRemovalDateStringFor(deprecation) {
      var thisPsiIndex = findPsiIndexContaining(deprecation.date);
      var targetPsi = psiList[thisPsiIndex + 3];

      if (!targetPsi) {
        return 'TBD';
      }

      return "PSI ".concat(targetPsi.name, " (").concat(formatDate(targetPsi.start), ")");
    };

    _createClass$j(DeprecationManager, [{
      key: "logger",
      get: function get() {
        return this._logger;
      }
      /**
       * Override Flags
       * @returns {Object}
       */

    }, {
      key: "overrides",
      get: function get() {
        return this._overrides;
      }
      /**
       *
       * @returns {boolean}
       */

    }, {
      key: "alwaysThrow",
      get: function get() {
        return this._alwaysThrow;
      }
      /**
       * Reference Date
       * @returns {Date}
       */

    }, {
      key: "referenceDate",
      get: function get() {
        return this._referenceDate;
      }
    }]);

    return DeprecationManager;
  }();

  function _defineProperties$k(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$k(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$k(Constructor.prototype, protoProps); if (staticProps) _defineProperties$k(Constructor, staticProps); return Constructor; }

  /**
   * Methods to support deprecations in code that lives outside the service factories.
   * Mainly to be used to handle deprecations in static code that exist outside of telemetryService's reach
   *
   * This is not to be used generally, and is a shim to migrate code to a more functional/testable state only.
   */

  /**
   * Static Queue
   * @type {Array}
   */
  var deprecationQueue = [];
  /**
   * Deprecation Manager instance
   *
   * @type {DeprecationManager}
   */

  var staticDeprecationManager;
  var StaticDeprecationManager =
  /*#__PURE__*/
  function () {
    function StaticDeprecationManager() {}

    var _proto = StaticDeprecationManager.prototype;

    /**
     * Enqueue a deprecation
     *
     * @param {Deprecation} deprecation
     */
    _proto.trigger = function trigger(deprecation) {
      if (!staticDeprecationManager) {
        deprecationQueue.push(deprecation);
        return;
      }

      staticDeprecationManager.trigger(deprecation);
    };

    /**
     * To support tests only, because of hidden global state
     */
    _proto.__resetState = function __resetState() {
      staticDeprecationManager = undefined;
      deprecationQueue = [];
    };

    _createClass$k(StaticDeprecationManager, [{
      key: "queue",
      get: function get() {
        return deprecationQueue;
      }
      /**
       * Set the deprecation manager to use for static code.
       * @return {DeprecationManager}
       */

    }, {
      key: "deprecationManager",
      get: function get() {
        return staticDeprecationManager;
      }
      /**
       * Set the deprecation manager to use for static code.
       * @param {DeprecationManager} deprecationManager
       */
      ,
      set: function set(deprecationManager) {
        staticDeprecationManager = deprecationManager; // Trigger any queued events

        deprecationQueue.forEach(function (deprecation) {
          if (typeof staticDeprecationManager !== 'undefined') {
            staticDeprecationManager.trigger(deprecation);
          }
        });
        deprecationQueue = [];
      }
    }]);

    return StaticDeprecationManager;
  }();

  // Cache

  /**
   * List of the User Permission Levels.
   *
   * This represents the specific amount of data the user wishes to share.
   *
   *   MAXIMAL:   'all'      Share everything.
   *   MINIMAL:   'minimal'  Share as little as possible.
   *   EXEMPT:    'exempt'   User is not offered the setting.
   *
   * @typedef {string} schema~UserPermissionLevel
   * @enum {string} schema~UserPermissionLevel}
   */
  var UserPermissionLevel = {
    MAXIMAL: 'all',
    MINIMAL: 'minimal',
    EXEMPT: 'exempt'
  };
  UserPermissionLevel.ALL = [UserPermissionLevel.MAXIMAL, UserPermissionLevel.EXEMPT, UserPermissionLevel.MINIMAL];

  var isValidPlatformPrivacyLevel = (function (value) {
    return UserPermissionLevel.ALL.indexOf(value) >= 0;
  });

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function (object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];

        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }

      return object;
    };
  }

  var _createBaseFor = createBaseFor;

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */

  var baseFor = _createBaseFor();
  var _baseFor = baseFor;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */

  function baseForOwn(object, iteratee) {
    return object && _baseFor(object, iteratee, keys_1);
  }

  var _baseForOwn = baseForOwn;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  var identity_1 = identity;

  /**
   * Casts `value` to `identity` if it's not a function.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Function} Returns cast function.
   */

  function castFunction(value) {
    return typeof value == 'function' ? value : identity_1;
  }

  var _castFunction = castFunction;

  /**
   * Iterates over own enumerable string keyed properties of an object and
   * invokes `iteratee` for each property. The iteratee is invoked with three
   * arguments: (value, key, object). Iteratee functions may exit iteration
   * early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @since 0.3.0
   * @category Object
   * @param {Object} object The object to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Object} Returns `object`.
   * @see _.forOwnRight
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.forOwn(new Foo, function(value, key) {
   *   console.log(key);
   * });
   * // => Logs 'a' then 'b' (iteration order is not guaranteed).
   */

  function forOwn(object, iteratee) {
    return object && _baseForOwn(object, _castFunction(iteratee));
  }

  var forOwn_1 = forOwn;

  /**
   * Array.prototype.includes
   * Native Support in:
   *   Chrome 47+
   *   Edge 14+
   *   IE:  -not supported-
   *   Firefox 43+
   *   Opera 34+
   *   Safari 9+
   *
   *   Android Browser
   *   Chrome for Android
   *   Edge Mobile: 14+
   *   IE Mobile: --- not supported ---
   *   Firefox for Android: 43+
   *   Opera Android: 34+
   *   iOS Safari: 9+
   *
   * @param {Array} array
   * @param {*} value
   * @return {boolean}
   * @private
   */
  var _arrayIncludesNative = function _arrayIncludesNative(array, value) {
    return array.includes(value);
  };
  /**
   * ES2009 Version.
   * This is NOT Identical to array.includes in regards to holes (empty slots) in an array.
   *   IE 11
   *
   * IE 9 does not support array.indexOf.
   * Hopefully no-one is still targeting that.
   * @param {Array} array
   * @param {*} value
   */


  var _arrayIncludesFill = function _arrayIncludesFill(array, value) {
    return array.indexOf(value) >= 0;
  }; // eslint-disable-next-line import/prefer-default-export


  var arrayIncludes = typeof Array.prototype.includes === 'function' ? _arrayIncludesNative : _arrayIncludesFill;

  /**
   * Data Type.
   *
   * This type defines the types of a given data element.
   *
   * DATE:     Value is of type date.
   * STRING:   Value is of type string.
   * ARRAY:    Value is of type array.
   * OBJECT:   Value is of type object.
   * FLOAT:    Value is of type float.
   * INT:      Value is of type integar.
   * NUMBER:   Value is of type number.
   * BOOLEAN:  Value is of type boolean.
   *
   */
  var PropertyType = {
    DATE: 'd',
    STRING: 's',
    ARRAY: 'a',
    OBJECT: 'e',
    FLOAT: 'f',
    INT: 'i',
    NUMBER: 'n',
    BOOLEAN: 'b'
  };

  function _typeof$8(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }
  var scalarTypes = ['string', 'number', 'boolean', 'undefined'];
  /**
   * Does the given type name represent a scalar value
   *
   * @param {string} typeName
   */

  var isScalarType = function isScalarType(typeName) {
    return arrayIncludes(scalarTypes, typeName);
  };
  /**
   * Is the value a scalar type
   * @param {*} value
   */

  var isScalar = function isScalar(value) {
    return isScalarType(_typeof$8(value)) || value === null;
  };
  /**
   * Is the object of a given class
   * @param {*} value
   * @param {string} className
   */

  var isObjectClass$2 = function isObjectClass(value, className) {
    return Object.prototype.toString.call(value) === "[object ".concat(className, "]");
  };
  /**
   * Is Function
   * @param {*} value
   */


  var isFunction$1 = function isFunction(value) {
    return typeof value === 'function';
  };
  /**
   * Is String
   * @param {*} value
   */

  var isString$4 = function isString(value) {
    return typeof value === 'string';
  };
  /**
   * PolyFill for Number.isInt (ES7)
   * @param {*} value
   */
  // eslint-disable-next-line no-restricted-globals

  var isInt = function isInt(value) {
    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
  };
  /**
   * PolyFill for Number.isFinite (ES7)
   * @param {*} value
   */
  // eslint-disable-next-line no-restricted-globals

  var isFloat = function isFloat(value) {
    return typeof value === 'number' && isFinite(value);
  };
  /**
   * Is the value a number: (NaN, -NaN, Infinity, -Infinity, or Finite(Float)
   * You probably don't want to use this function.
   */

  var isNumber$1 = function isNumber(value) {
    return typeof value === 'number';
  };
  /**
   * Is the value an object
   * @param {*} value
   */

  var isObject$1 = function isObject(value) {
    return _typeof$8(value) === 'object';
  };
  /**
   * Is the value an Object object.
   * @param {*} value
   */

  var isPlainObject$1 = function isPlainObject(value) {
    return isObjectClass$2(value, 'Object');
  };
  /**
   * Is the value an array
   * @param {*} value
   */

  var isArray$1 = function isArray(value) {
    return isObjectClass$2(value, 'Array');
  };
  /**
   * Is the value a date
   * @param {*} value
   */

  var isDate$1 = function isDate(value) {
    return isObjectClass$2(value, 'Date');
  };
  /**
   * Is the value null, or undefined
   * @param value
   */

  var isNullOrUndefined$1 = function isNullOrUndefined(value) {
    return value === null || value === undefined;
  };
  /**
   * Is string value null, undefined or spaces, this function doesn't check if value passed is a valid string.
   * @param {string} value
   */

  var isEmptyOrSpaces = function isEmptyOrSpaces(value) {
    return isNullOrUndefined$1(value) || value.match(/^\s*$/) !== null;
  };
  /**
   * Does the value match the schema definition.
   * @param {*} value        Value to test
   * @param {Object} schema  Schema definition
   * @returns {boolean}
   */

  var isValidSchemaTypeValue = function isValidSchemaTypeValue(value, schema) {
    var schemaType = schema.type;

    switch (schemaType) {
      case PropertyType.STRING:
        if (schema.allowNumber) {
          if (typeof value === 'number') {
            return true;
          }
        }

        return typeof value === 'string';

      case PropertyType.NUMBER:
        return typeof value === 'number';

      case PropertyType.OBJECT:
        return isObjectClass$2(value, 'Object') && !isNullOrUndefined$1(value);

      case PropertyType.BOOLEAN:
        return typeof value === 'boolean';

      case PropertyType.INT:
        return isInt(value);

      case PropertyType.FLOAT:
        return isFloat(value);

      case PropertyType.ARRAY:
        return isArray$1(value);

      case PropertyType.DATE:
        return isDate$1(value);

      default:
        break;
    }

    return false;
  };

  /**
   * @callback schema~FilterCallback
   * @param {*}  Value
   * @param {Object}  Value Schema
   *
   * @return {*}  Processed Value
   */

  /**
   * @callback schema~Filter
   * @param {Object}   Object to filter
   */

  /**
   * @typedef {Object} schema~FilterConfiguration
   * @param {boolean} typeCheck     Enable Type Check Filter
   * @param {boolean} privacyCheck  Enable Privacy Check Filter
   */

  /**
   * Apply the given filters, return the result, recursively.
   *
   * This will apply all the filters against the value, and return the result.
   * If the value is an object, this will call the filters on each property, recursively.
   *
   *
   * @param {schema~FilterCallback[]}   filters         Plugin Filters
   * @param {*}                              values           Target Value
   * @param {Object}                         valueSchema     Target Value Schema
   *
   * @returns {*} effectiveValue    Value as modified by applied filters.
   */

  var applyFilters = function applyFilters(filters, values, valueSchema) {
    // No value.
    if (values === undefined) {
      return undefined;
    }

    var effectiveValue = filters.reduce(function (_value, filter) {
      return filter(_value, valueSchema);
    }, values);

    if (effectiveValue === undefined) {
      return undefined;
    }

    if (isPlainObject$1(effectiveValue)) {
      var result = {};
      forOwn_1(effectiveValue, function (value, key) {
        var propertySchema = valueSchema.properties && valueSchema.properties[key] || {};
        result[key] = applyFilters(filters, value, propertySchema);
      });
      return result;
    }

    if (isArray_1(effectiveValue)) {
      var propertySchema = valueSchema.collection || {};
      return effectiveValue.map(function (value) {
        return applyFilters(filters, value, propertySchema);
      });
    } // Use Case 2.3.1: [DEFAULT-VALUE]
    // Use Case 2.3.2: [REQUIRED-VALUE]
    // Cycle through all defined values, to allow for default/missing value handling.
    // Object.keys(eventSchema.properties).forEach((key) => {
    //     const propertySchema = eventSchema.properties[key];
    //     const propertyValue = value[key];
    //     result[key] = applyFilter(propertyValue, propertySchema, isAllowed);
    // });
    // Cycle through only event properties, to check for validity.


    return effectiveValue;
  };

  var filterEnvironment = (function (activeSchema, filters, rawEnvironment) {
    var schema = activeSchema.environment;
    return applyFilters(filters, rawEnvironment, schema || {});
  });

  /**
   * Apply type-checking rules to the value, as defined by eventSchema.
   *
   * @param {*}        value           Value to process
   * @param {Object}   eventSchema     EventSchema for the given value.
   * @returns {*}      filtered value or undefined if not allowed
   */

  var applyFilterTypeCheck = function applyFilterTypeCheck(value, eventSchema) {
    // Use Case 1: [TYPE-CHECK]
    // Ensure the passed in value matches what is expected for the property, type wise.
    if (!isValidSchemaTypeValue(value, eventSchema)) {
      return eventSchema.invalidValue !== undefined ? eventSchema.invalidValue : undefined;
    } // Use Case 2.1: [TYPE-CHECK] type='array'
    // Validate all elements of an array match the collectionSchema


    if (eventSchema.type === PropertyType.ARRAY) {
      return value.map(function (collectionValue) {
        return applyFilterTypeCheck(collectionValue, eventSchema.collection || {});
      });
    } // Use Case 2.2: [TYPE-CHECK] type='string', 'int', 'float', 'number', 'null', 'undefined', 'boolean', 'date'
    // No additional work for these types


    if (isScalar(value) || eventSchema.type === PropertyType.DATE || eventSchema.type === PropertyType.OBJECT) {
      return value;
    } // Use Case 2.3: [TYPE-CHECK] type=unknown


    return undefined;
  };

  /**
   * Data Privacy Level.
   *
   * This type defines the categorization of a given data element.
   *
   * REQUIRED:   Value is required.     == Operational
   * OPTIONAL:   Value is not-required. == Non-Operational
   *
   * Specific handling of the field will depend on the UserPermissionLevel.
   * @typedef {{REQUIRED: string, OPTIONAL: string}} schema~PropertyClassification
   */
  var PropertyClassification = {
    REQUIRED: 'r',
    OPTIONAL: 'o'
  };
  PropertyClassification.ALL = [PropertyClassification.REQUIRED, PropertyClassification.OPTIONAL];

  /**
   * Apply any value hydration including type convertion.
   *
   * @param {*}        value           Value to process
   * @param {Object}   eventSchema     EventSchema for the given value.
   * @returns {*}      hydrated value or undefined if not allowed
   */

  var hydrateValues = (function (value, eventSchema) {
    // schema of type date accept attempt to hydrate strings into dates.
    // GHOST-1445.
    if (eventSchema.type === PropertyType.DATE) {
      if (typeof value === 'string') {
        return new Date(value);
      }
    }

    return value;
  });

  var ws1RestrictFilter = function ws1RestrictFilter(value, valueSchema) {
    // Pass through if Classification is REQUIRED
    if (valueSchema.c === PropertyClassification.REQUIRED) {
      return value;
    } // By default, all values will be blanked.


    return undefined;
  };

  var getPolicyFilters = (function (schemaOptions, platformPrivacyLevel) {
    var filters = [hydrateValues, applyFilterTypeCheck];

    if (!(platformPrivacyLevel === 'all' || platformPrivacyLevel === 'exempt')) {
      filters.push(ws1RestrictFilter);
    }

    return filters.concat(schemaOptions.filters);
  });

  var isUseLastLocationEnabled = (function (config) {
    return config.useLastLocation && config.useLastLocation.enable === true;
  });

  /**
   * Determine if an event should be throttled given it's type and a plugin
   *
   * @private
   *
   * @param      {ThrottlerInterface} throttler  Event Throttler
   * @param      {string}  eventMetadata  The event type object
   * @param      {string}  pluginId  The plugin name
   * @return     {boolean}   Returns true if the event type is throttled for the plugin based on config
   */
  var isEventThrottledForPluginId = (function (throttler, eventMetadata, pluginId) {
    return throttler.isPluginEventTypeMuted(eventMetadata, pluginId);
  });

  var applyThrottlerToPluginIds = (function (throttler, eventMetadata, pluginIds) {
    return pluginIds.filter(function (pluginId) {
      if (isEventThrottledForPluginId(throttler, eventMetadata, pluginId)) {
        return false;
      }

      return true;
    });
  });

  var dispatchRequestToPlugin = (function (request, plugin) {
    return plugin.dispatch(request.event, request);
  });

  var doDispatchToPluginIdSet = (function (plugins, runtimePluginConfigs, dispatchedEvent, targetPluginIds, filteredEvent, filteredEnvironment, eventMetadata) {
    // No Content to dispatch
    if (!filteredEvent) {
      return;
    }

    targetPluginIds.forEach(function (pluginId) {
      var plugin = plugins[pluginId];

      if (!plugin) {
        return;
      }

      plugin.environment = filteredEnvironment;
      var request = {
        environment: filteredEnvironment || {},
        event: filteredEvent,
        config: runtimePluginConfigs[pluginId] || {},
        eventMetadata: eventMetadata,
        gctVersion: '4.15.0'
      };
      var payload = dispatchRequestToPlugin(request, plugin);
      dispatchedEvent.setPayload(pluginId, payload);
    });
  });

  // TODO: move this to factory configration.
  var tracingIdEx = new RegExp('[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$');
  /**
   * Enrich Event with Identifiers
   * @param {Object} rawEvent [Modified] Event Object
   * @param {Object} identifiers  Identifier Interface
   * @private
   */

  var dispatchApplyIdentifiers = (function (rawEvent, identifiers) {
    // eslint-disable-next-line no-param-reassign
    rawEvent.sessionId = identifiers.sessionId; // eslint-disable-next-line no-param-reassign

    rawEvent.shortTermId = identifiers.shortTermId; // if tracingId is passed in we should not generate new one.

    if (typeof rawEvent.tracingId === 'undefined' // TODO: this test should be done as a test.
    || !tracingIdEx.test(rawEvent.tracingId)) {
      // eslint-disable-next-line no-param-reassign
      rawEvent.tracingId = identifiers.tracingId;
    }

    if (typeof identifiers.testCaseId !== 'undefined') {
      // eslint-disable-next-line no-param-reassign
      rawEvent.testCaseId = identifiers.testCaseId;
    }

    if (typeof identifiers.testSessionId !== 'undefined') {
      // eslint-disable-next-line no-param-reassign
      rawEvent.testSessionId = identifiers.testSessionId;
    }
  });

  /**
   * Add privacySettings value to StartUp events
   * @param {Object} rawEvent  [MODIFIED] Event
   * @param {string} platformPrivacyLevel
   * @return {Object} Mutated rawEvent
   * @private
   */
  var dispatchEnrichStartUpWithPrivacySettings = (function (rawEvent, platformPrivacyLevel) {
    // To avoid mutating the environment object we added a readonly property to startupEvent.
    if (rawEvent.type !== 'Startup') {
      return rawEvent;
    } // eslint-disable-next-line no-param-reassign


    rawEvent.privacySettings = platformPrivacyLevel;
    return rawEvent;
  });

  /**
   * @HACK
   * Run additional filters against the event last minute.
   * @TODO: Integrate this into the regular event processing flow, preferably through a more generalized
   *   approach, such as having an event listener that will run on a `dispatch` event or suite of events
   *   such as `dispatch.prepareEvent` (processing) `dispatch` (send to plugins) and `dispatchPlugin` (send
   *   to spcefic plugin, which would allow for programmatic cancellation, such as what Macross does)
   *
   * @param {UriCensor}  censor   UriSensor
   * @param {string} platformPrivacyLevel  platformPrivacyLevel
   * @param {object} event  [MODIFIED] An event
   * @return {object} event The input event
   */

  var censorKnownUriFieldsOnEvent = (function (censor, platformPrivacyLevel, event) {
    //  Event is not defined
    // OR privacyLevel is not 'minimal'
    if (!event || platformPrivacyLevel !== UserPermissionLevel.MINIMAL) {
      return event;
    }

    var propertiesToFilter = ['url', 'apiUrl', 'deeplink', 'httpReferrer', 'pageUrl'];
    propertiesToFilter.forEach(function (key) {
      if (event[key]) {
        // eslint-disable-next-line no-param-reassign
        event[key] = censor(event[key]);
      }
    });
    return event;
  });

  var enrichEvent = (function (identifiers, uriCensor, platformPrivacyLevel, inputEvent) {
    var clonedEvent = cloneDeep_1(inputEvent);
    dispatchEnrichStartUpWithPrivacySettings(clonedEvent, platformPrivacyLevel);
    dispatchApplyIdentifiers(clonedEvent, identifiers);
    censorKnownUriFieldsOnEvent(uriCensor, platformPrivacyLevel, clonedEvent);
    return clonedEvent;
  });

  var filterEvent = (function (eventSchema, filters, rawEvent) {
    return applyFilters(filters, rawEvent, eventSchema);
  });

  /**
   * get the event schema that will be used to format based on event meta data.
   *
   * if default schema in use the localname of the event is used to backfill.
   * this should be fixed and the default schema should export with namespace in name.
   *
   * in future we need to remove that and have GCTE export events in FQN format <namespace:type>
   * https://jira.sie.sony.com/browse/GHOST-1761
   */
  var getEventSchema = (function (activeSchema, eventMetadata) {
    var eventSchema = activeSchema.events || {};
    var schemaName = eventMetadata.eventNamespace === 'default' ? eventMetadata.eventLocalName : eventMetadata.eventName;
    return eventSchema[schemaName] || {};
  });

  /**
   * Gets list of plugins where to sent a given event type.
   *
   * Use the Event Name directly.
   *
   * Legacy Behaviour:
   *   Use the keys that are defined in RegisterEvent, and then rebuild them based on the event type.
   *   This is prone to error if the key and the event name don't match.
   *
   *
   * @private
   *
   * @param      {LogInterface}  logger       Logger
   * @param      {object}        eventsConfig config.events
   * @param      {Event}         eventMetadata    The event type object
   *
   * @return     {Array}   Returns the list of plugins where given event type should be sent to
   */
  var getPluginIdsForEventType = (function (logger) {
    var eventsConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var eventMetadata = arguments.length > 2 ? arguments[2] : undefined;

    if (eventsConfig[eventMetadata.eventLocalName] !== undefined) {
      return eventsConfig[eventMetadata.eventLocalName];
    }

    if (eventsConfig[eventMetadata.eventName] !== undefined) {
      return eventsConfig[eventMetadata.eventName];
    } // TODO: Create a Strict Mode thing for this, SilentFail(...) type thing.


    logger.error('UnknownEvent: config.events does not contain an entry for the requested event.', {
      eventType: eventMetadata.eventLocalName
    });
    return [];
  });

  var isValidEvent = (function (event) {
    return event && event.location && event.locationType;
  });

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */

  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED$2);

    return this;
  }

  var _setCacheAdd = setCacheAdd;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */

  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;
    this.__data__ = new _MapCache();

    while (++index < length) {
      this.add(values[index]);
    }
  } // Add methods to `SetCache`.


  SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
  SetCache.prototype.has = _setCacheHas;
  var _SetCache = SetCache;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }

    return -1;
  }

  var _baseFindIndex = baseFindIndex;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }

    return -1;
  }

  var _strictIndexOf = strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseIndexOf(array, value, fromIndex) {
    return value === value ? _strictIndexOf(array, value, fromIndex) : _baseFindIndex(array, _baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */

  function arrayIncludes$1(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && _baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes$1;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }

    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }

    return result;
  }

  var _arrayMap = arrayMap;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas;

  /** Used as the size to enable large array optimizations. */

  var LARGE_ARRAY_SIZE$1 = 200;
  /**
   * The base implementation of methods like `_.difference` without support
   * for excluding multiple arrays or iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of filtered values.
   */

  function baseDifference(array, values, iteratee, comparator) {
    var index = -1,
        includes = _arrayIncludes,
        isCommon = true,
        length = array.length,
        result = [],
        valuesLength = values.length;

    if (!length) {
      return result;
    }

    if (iteratee) {
      values = _arrayMap(values, _baseUnary(iteratee));
    }

    if (comparator) {
      includes = _arrayIncludesWith;
      isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE$1) {
      includes = _cacheHas;
      isCommon = false;
      values = new _SetCache(values);
    }

    outer: while (++index < length) {
      var value = array[index],
          computed = iteratee == null ? value : iteratee(value);
      value = comparator || value !== 0 ? value : 0;

      if (isCommon && computed === computed) {
        var valuesIndex = valuesLength;

        while (valuesIndex--) {
          if (values[valuesIndex] === computed) {
            continue outer;
          }
        }

        result.push(value);
      } else if (!includes(values, computed, comparator)) {
        result.push(value);
      }
    }

    return result;
  }

  var _baseDifference = baseDifference;

  /** Built-in value references. */

  var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;
  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */

  function isFlattenable(value) {
    return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }

  var _isFlattenable = isFlattenable;

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */

  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1,
        length = array.length;
    predicate || (predicate = _isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];

      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          _arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }

    return result;
  }

  var _baseFlatten = baseFlatten;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);

      case 1:
        return func.call(thisArg, args[0]);

      case 2:
        return func.call(thisArg, args[0], args[1]);

      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }

    return func.apply(thisArg, args);
  }

  var _apply = apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax = Math.max;
  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */

  function overRest(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
          index = -1,
          length = nativeMax(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }

      index = -1;
      var otherArgs = Array(start + 1);

      while (++index < start) {
        otherArgs[index] = args[index];
      }

      otherArgs[start] = transform(array);
      return _apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var baseSetToString = !_defineProperty ? identity_1 : function (func, string) {
    return _defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant_1(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;
  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeNow = Date.now;
  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */

  function shortOut(func) {
    var count = 0,
        lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;

      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }

      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */

  var setToString = _shortOut(_baseSetToString);
  var _setToString = setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */

  function baseRest(func, start) {
    return _setToString(_overRest(func, start, identity_1), func + '');
  }

  var _baseRest = baseRest;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */

  function isArrayLikeObject(value) {
    return isObjectLike_1(value) && isArrayLike_1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject;

  /**
   * Creates an array of `array` values not included in the other given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * **Note:** Unlike `_.pullAll`, this method returns a new array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @see _.without, _.xor
   * @example
   *
   * _.difference([2, 1], [2, 3]);
   * // => [1]
   */

  var difference = _baseRest(function (array, values) {
    return isArrayLikeObject_1(array) ? _baseDifference(array, _baseFlatten(values, 1, isArrayLikeObject_1, true)) : [];
  });
  var difference_1 = difference;

  var logPluginIdResolution = (function (logger, pluginIdsForEventType, pluginIds, event) {
    if (!pluginIds) {
      logger.debug('No plugins defined for event type', {
        eventType: event.type,
        inputEvent: event
      });
    }

    if (pluginIds.length !== pluginIdsForEventType.length) {
      logger.debug('Plugins are throttled for this event.', {
        inputEvent: event,
        throttled: difference_1(pluginIdsForEventType, pluginIds)
      });
    }
  });

  var legacyRequireEventProperties = (function (event) {
    if (!event) {
      throw new Error('Event is empty.');
    }

    if (!event.location) {
      throw new Error("Missing location field for event type '".concat(event.type, "'"));
    }

    if (!event.locationType) {
      throw new Error("Missing locationType field for event type '".concat(event.type, "'"));
    }
  });

  var notifyInvalidEvent = (function (logger, isUnifiedTelemetry, inputEvent) {
    logger.error('The event is missing .location or .locationType.  Aborting.', {
      inputEvent: inputEvent
    });

    if (!isUnifiedTelemetry) {
      // Process appropriate throw.
      legacyRequireEventProperties(inputEvent);
    }
  });

  var notifyInvalidPlugin = (function (logger, isUnifiedTelemetry, plugins, pluginIds) {
    var unknownIds = difference_1(pluginIds, Object.keys(plugins));

    if (!unknownIds.length) {
      return;
    }

    logger.warning('The following plugin ids are not loaded.', {
      unknownIds: unknownIds
    });

    if (!isUnifiedTelemetry) {
      throw new Error("Invalid plugin '".concat(unknownIds[0], "' in dispatch()! Please register plugin first."));
    }
  });

  var dispatchEvent = (function (identifiers, logger, schemaOptions, throttler, plugins, uriCensor, isUnifiedTelemetry, platformPrivacyLevel, inputEvent, environment, config, eventMetadata, activeSchema) {
    var dispatchedEvent = new DispatchedEvent();
    var filters = getPolicyFilters(schemaOptions, platformPrivacyLevel);
    var runtimePluginConfigs = config.plugins || {};

    if (!isValidEvent(inputEvent)) {
      notifyInvalidEvent(logger, isUnifiedTelemetry, inputEvent);
      return dispatchedEvent;
    }

    var pluginIdsForEventType = getPluginIdsForEventType(logger, config.events, eventMetadata);
    var pluginIds = applyThrottlerToPluginIds(throttler, eventMetadata, pluginIdsForEventType);
    logPluginIdResolution(logger, pluginIdsForEventType, pluginIds, inputEvent);
    notifyInvalidPlugin(logger, isUnifiedTelemetry, plugins, pluginIds); // .event Processing

    var enrichedEvent = enrichEvent(identifiers, uriCensor, platformPrivacyLevel, inputEvent);
    var eventSchema = getEventSchema(activeSchema, eventMetadata); // event version is used to identify which schema version was used in dispatch
    // default schema fill should send empty to sbahn.
    // https://jira.sie.sony.com/browse/GHOST-1760
    // eslint-disable-next-line no-param-reassign

    eventMetadata.version = eventSchema.version ? eventSchema.version : 'UNKNOWN';
    var filteredEvent = filterEvent(eventSchema, filters, enrichedEvent);
    var filteredEnvironment = filterEnvironment(activeSchema, filters, environment);
    doDispatchToPluginIdSet(plugins, runtimePluginConfigs, dispatchedEvent, pluginIds, filteredEvent, filteredEnvironment, eventMetadata);
    dispatchedEvent.inputEvent = cloneDeep_1(inputEvent);
    dispatchedEvent.filteredEvent = filteredEvent;
    return dispatchedEvent;
  });

  /**
   *
   * @param {LoggerInterface} logger
   * @param {DispatchedEvent} dispatchedEvent
   */
  var logDispatchedEvent = (function (logger, dispatchedEvent) {
    var isEventFiltered = dispatchedEvent.inputEvent && !dispatchedEvent.filteredEvent;
    var context = {
      inputEvent: dispatchedEvent.inputEvent,
      filteredEvent: dispatchedEvent.filteredEvent,
      messages: [],
      payloads: {}
    };
    dispatchedEvent.payloads.forEach(function (payload, pluginId) {
      context.payloads[pluginId] = payload;
    });

    if (isEventFiltered) {
      context.messages.push('Entire event was filtered.');
    }

    logger.debug('Dispatched Event', context);
  });

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   *
   * _.isUndefined(null);
   * // => false
   */
  function isUndefined$1(value) {
    return value === undefined;
  }

  var isUndefined_1 = isUndefined$1;

  var lowerCaseSpace = (function (v) {
    return v.toLowerCase().replace(/_/g, ' ');
  });

  function _slicedToArray$3(arr, i) { return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _nonIterableRest$3(); }

  function _nonIterableRest$3() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$3(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$3(arr) { if (Array.isArray(arr)) return arr; }
  /**
   * Utility function to generate an enum object from an array of keys
   *
   * @param    {array}    keys         The keys of the enum (values will be derived from those)
   * @param    {function} [formatter]  Formatter
   * @return   {object}   Return a frozen object which can be used as enum
   */

  var generateEnum = (function (keys) {
    var formatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity_1;
    var result = {};
    var len = keys.length;
    var key;
    var value; // eslint-disable-next-line no-plusplus

    for (var i = 0; i < len; i++) {
      if (isString_1(keys[i])) {
        key = keys[i];
        value = formatter(keys[i]);
      } else {
        // else if (isArray(keys[i])
        var _keys$i = _slicedToArray$3(keys[i], 2);

        key = _keys$i[0];
        value = _keys$i[1];
      } // else throw Error


      result[key] = value;
    }

    return Object.freeze(result);
  });

  /**
   * Values for age group.
   * ref: https://confluence.sie.sony.com/display/KP/Accounts+Service+Create+Account+ReqSpec
   * @enum {string}
   */

  var AGE_GROUP = ['AGE_GROUP_0', 'AGE_GROUP_1', 'AGE_GROUP_2', 'AGE_GROUP_3'];
  var AGE_GROUP$1 = generateEnum(AGE_GROUP, lowerCaseSpace);

  /**
   * Values for API status
   * @enum {string}
   */

  var API_STATUSES = ['SUCCESS', 'FAILURE'];
  var API_STATUSES$1 = generateEnum(API_STATUSES, lowerCaseSpace);

  var lowerCase = (function (v) {
    return v.toLowerCase();
  });

  /**
   * Values for banner types
   * @readonly
   * @enum {string}
   */

  var BANNER_TYPES = ['PAID_AD_VIEWED', 'PAID_AD_LOADED', 'VIDEO_AD_PLAYED', 'REFRESH_IMAGE_VIEWED', 'REFRESH_VIDEO_VIEWED', 'DEFAULT'];
  var BANNER_TYPES$1 = generateEnum(BANNER_TYPES, lowerCase);

  /**
   * Values for click types
   * @enum {string}
   */

  var CLICK_TYPES = [// Friend requests actions
  'INITIATE_FRIEND_REQUEST', 'SEND_FRIEND_REQUEST', 'SEND_CLOSE_FRIEND_REQUEST', 'CANCEL_FRIEND_REQUEST', 'VIEW_FRIEND_REQUEST', 'ACCEPT_FRIEND_REQUEST', 'ACCEPT_CLOSE_FRIEND_REQUEST', 'DELETE_FRIEND_REQUEST', 'INITIATE_REAL_NAME_REQUEST', 'SEND_REAL_NAME_REQUEST', 'CANCEL_REAL_NAME_REQUEST', 'VIEW_REAL_NAME_REQUEST', 'ACCEPT_REAL_NAME_REQUEST', 'DELETE_REAL_NAME_REQUEST', 'CANCEL_CLOSE_FRIEND_REQUEST', 'VIEW_CLOSE_FRIEND_REQUEST', 'REMOVE_FROM_FRIEND', 'SELECT_FRIEND', 'SEARCH_FRIENDS', // Block/unblock users
  'INITIATE_BLOCK_USER', 'BLOCK_USER', 'UNBLOCK_USER', // Follow/unfollow users
  'FOLLOW', 'UNFOLLOW', // Notifications
  ['CLICK_NOTIFICATION_ICON', 'click notifications icon'], // 'CLICK_NOTIFICATIONS_ICON', // Replacement for CLICK_NOTIFICATION_ICON
  'SELECT_NOTIFICATION', 'SELECT_NOTIFICATION_LINK', // Messaging & party actions
  'SELECT_MESSAGE', 'SELECT_MESSAGE_GROUP', 'INITIATE_MESSAGE', 'NEW_MESSAGE', 'SEND_MESSAGE', 'REMOVE_ME_FROM_GROUP', 'CHANGE_GROUP_NAME', 'ADD_PLAYERS', 'START_PARTY', 'JOIN_PARTY', // Now playing & sessions
  'JOIN_SESSION', 'REQUEST_TO_WATCH', 'VIEW_SESSION', 'VIEW_COMMUNITY_SESSION', 'VIEW_BROADCAST', 'SHARE_PLAY', // Profile actions
  'VIEW_PROFILE', 'VIEW_ACCOUNT', 'CHANGE_ONLINE_STATUS', 'CHANGE_ONLINE_STATUS_ONLINE', 'CHANGE_ONLINE_STATUS_OFFLINE', 'EDIT_PROFILE', 'CHANGE_BACKGROUND_IMAGE', 'INITIATE_CHANGE_BACKGROUND_IMAGE', 'INITIATE_CHANGE_BACKGROUND_COLOR', 'INITIATE_REMOVE_BACKGROUND_IMAGE', 'REMOVE_BACKGROUND_IMAGE', 'SET_BACKGROUND_IMAGE', 'CHANGE_PRIVACY_SETTING', 'VIEW_ALL_RELATED_TITLES', 'ACTIVATE_FRIEND_ONLINE_NOTIFICATION', 'DEACTIVATE_FRIEND_ONLINE_NOTIFICATION', 'SET_AVATAR', ['SET_AVATAR_PREMIUM', 'set premium avatar'], // 'SET_PREMIUM_AVATAR', // for BC in Tesseract, this value is needed
  'ADD_TO_CUSTOM_LIST', ['INITIATE_PROFILE_EDIT', 'click edit profile'], 'NOTIFY_WHEN_ONLINE', 'UPDATE_PROFILE_INFO', 'CHANGE_PROFILE_PICTURE', 'VIEW_ALL_TROPHIES', 'VIEW_ALL_FRIENDS', 'CREATE_ROADSTER_PROFILE', 'DELETE_PROFILE_PICTURE', // Team profile
  'VIEW_TEAM_MESSAGES', 'CLICK_EDIT_PROFILE_BUTTON', 'SEND_MESSAGE_OWNER', 'JOIN_TEAM', 'INITIATE_DECLINE_TEAM_INVITE', 'DECLINE_TEAM_INVITE', 'INITIATE_LEAVE_TEAM', 'LEAVE_TEAM', 'INITIATE_DISBAND_TEAM', 'DISBAND_TEAM', 'SEND_TEAM_INVITE', 'INITIATE_PROMOTE_TEAM_CAPTAIN', 'PROMOTE_TEAM_CAPTAIN', 'INITIATE_DEMOTE_TEAM_MEMBER', 'DEMOTE_TEAM_MEMBER', 'INITIATE_KICK_OUT_TEAM_MEMBER', 'KICK_OUT_TEAM_MEMBER', 'INITIATE_CANCEL_TEAM_INVITE', 'CANCEL_TEAM_INVITE', 'VIEW_BACKGROUND_IMAGE', 'VIEW_TOURNAMENT_RESULT', 'FIND_TOURNAMENTS', 'EXPAND_DESCRIPTION', 'VIEW_BLOCKED_PLAYER_DESCRIPTION', 'CREATE_TEAM', 'CANCEL_TEAM_CREATION', 'CHANGE_TEAM_NAME', 'CHANGE_TEAM_DESCRIPTION', 'CHANGE_TEAM_LOGO', 'REMOVE_TEAM_LOGO', 'SHOW_RECENT_TEAM_PERFORMANCE', 'HIDE_RECENT_TEAM_PERFORMANCE', 'INITIATE_CHANGE_TEAM_LOGO', // Activity feeds actions
  'LIKE', 'UNLIKE', 'INITIATE_COMMENT', 'INITIATE_SHARE', 'INITIATE_RESHARE', 'OPEN_INTRO', 'VIEW_ACTIVITY', 'INITIATE_POST_ANYTHING', 'ADD_TO_POST_ANYTHING', 'SUBMIT_POST_ANYTHING', 'SUBMIT_RESHARE', 'SUBMIT_COMMENT', 'GO_TO_LINK', // Trending medias actions
  'VIEW_GAME_BROADCAST', 'VIEW_GAME_VIDEO', 'VIEW_GAME_SCREENSHOT', // Gallery View actions
  'VIEW_CONTENT_DETAILS', 'VIEW_CONTENT_INFO', 'VIEW_LIKE_COUNT', 'VIEW_RESHARE_COUNT', 'DELETE_COMMENT', 'VIEW_IN_FACEBOOK', 'VIEW_IN_TWITTER', 'VIEW_IN_YOUTUBE', 'VIEW_IN_DAILYMOTION', 'VIEW_IN_NICONICO', 'VIEW_IN_LFPS', 'VIEW_PURCHASE_SUBSCRIPTION', 'VIEW_GIFT', 'VIEW_TAGGED_USERS', 'VIEW_RESHARE_ORIGINAL', 'LISTEN_IN_SPOTIFY', 'VIEW_FREE_TRIAL', 'VIEW_PROMO_SITE', 'VOTE_NOW', 'VIEW_VOTE_NOW_RESULTS', 'COMPARE_TROPHIES', 'WATCH_PS_VIDEO', 'VIEW_MY_VIDEOS', 'VIEW_PRODUCT_DEMOS', 'VIEW_FULL_GAME_TRIAL', 'FIND_FACEBOOK_FRIENDS', // Events actions
  'CREATE_EVENT', 'VIEW_EVENT', 'JOIN_EVENT', 'CANCEL_EVENT', 'CHANGE_EVENT_STATUS_GOING', 'CHANGE_EVENT_STATUS_NOT_GOING', ['UNREGISTER_EVENT', 'unregister from event'], ['VIEW_EVENT_SUPPORT', 'view event support page'], 'VIEW_TOURNAMENT_STANDINGS', 'VIEW_EVENT_WEBSITE', 'VIEW_TOURNAMENT_RULES', 'WATCH_EVENT_BROADCAST', ['VIEW_EVENT_BROADCASTS', 'view more event broadcasts'], ['VIEW_IN_STORE', 'view ps store'], ['VIEW_GAME_IN_STORE', 'view game in ps store'], 'VIEW_ALL_FRIENDS_IN_BROADCAST', 'VIEW_RELATED_EVENTS', // Trophies actions
  'VIEW_TROPHIES', 'VIEW_TROPHY', 'TROPHY_COMPARISON_ON', 'TROPHY_COMPARISON_OFF', // Party actions
  'GIVE_CONTROLLER_TO_VISITOR', 'TAKE_BACK_CONTROLLER_FROM_VISITOR', 'STOP_SHARE_PLAY', 'LEAVE_SHARE_PLAY', 'START_SHARE_PLAY', 'JOIN_SHARE_PLAY', 'WHAT_IS_SHARE_PLAY', 'SWITCH_TO_SHARE_PLAY_GAME_SCREEN', 'VIEW_OTHER_PARTIES', 'VIEW_PARTY_SETTINGS', 'LEAVE_PARTY', 'MUTE_CHAT_MYSELF', 'UNMUTE_CHAT_MYSELF', 'MUTE_CHAT_PLAYER', 'UNMUTE_CHAT_PLAYER', 'CHANGE_PARTY_PLAYER_LIMIT', 'SEND_INVITATIONS', 'INITIATE_CREATE_PARTY', 'ADJUST_PARTY_PRIVACY_PUBLIC', 'ADJUST_PARTY_PRIVACY_PRIVATE', 'ADJUST_AUDIO_MIX', 'ADJUST_CHAT_AUDIO_PRIORITIZE_PARTY_CHAT', 'ADJUST_CHAT_AUDIO_PRIORITIZE_GAME_CHAT', 'ADJUST_VIDEO_QUALITY_FOR_SHARE_PLAY_HIGH_RESOLUTION', 'ADJUST_VIDEO_QUALITY_FOR_SHARE_PLAY_STANDARD_RESOLUTION', 'ADJUST_VIDEO_QUALITY_FOR_SHARE_PLAY_HIGH_FRAME_RATE', 'ADJUST_VIDEO_QUALITY_FOR_SHARE_PLAY_STANDARD_FRAME_RATE', 'ADJUST_VOICE_SHARING_PERMISSIONS_ALWAYS_ALLOW', 'ADJUST_VOICE_SHARING_PERMISSIONS_DO_NOT_ALLOW', 'ADJUST_VOICE_SHARING_PERMISSIONS_ALLOW_FOR_PARTY', 'INVITE_PLAYERS_TO_PARTY', 'INVITE_MESSAGE_GROUP_TO_PARTY', 'INVITE_COMMUNITY_GROUP_TO_PARTY', 'CHANGE_CONTROLLER_TYPE', 'TEST_CONNECTION_SPEED', 'INITIATE_SEND_MESSAGE_TO_ALL', 'INITIATE_CREATE_NEW_EVENT', 'VIEW_CHAT_TRANSCRIPTION_PAGE', 'KICK_OUT_OF_PARTY', // Communities actions
  'VIEW_COMMUNITY', 'VIEW_COMMUNITIES', 'SEARCH_COMMUNITIES', 'FILTER_COMMUNITIES', 'CREATE_COMMUNITY', 'JOIN_COMMUNITY', ['INVITE_COMMUNITY', 'click invite to community icon'], // 'INVITE_TO_COMMUNITY', // replacement for INVITE_COMMUNITY
  ['COMMUNITY_SETTING', 'click community settings icon'], 'ACCEPT_COMMUNITY_MEMBERSHIP_REQUEST', 'DENY_COMMUNITY_MEMBERSHIP_REQUEST', 'DELETE_COMMUNITY', 'LEAVE_COMMUNITY', ['CHANGE_COMMUNITY_NAME_PERMISSION', 'change community name and permissions'], 'CHANGE_COMMUNITY_GAME_ASSOCIATION', ['CHANGE_COMMUNITY_IMAGE_BACKGROUND', 'change community image and background'], ['SUBMIT_FRIENDS_INVITATIONS_COMMUNITY', 'submit friends invitations to community'], 'CHANGE_COMMUNITY_NOTIFICATIONS', ['POST_COMMUNITY_WALL', 'post to community wall'], ['REPLY_COMMUNITY_POST', 'reply to community post'], ['VIEW_IMAGE_COMMUNITY_WALL', 'view image on community wall'], ['SEND_MESSAGE_COMMUNITY', 'send message to community member'], // 'SEND_MESSAGE_COMMUNITY_MEMBER', // Repalcement for SEND_MESSAGE_COMMUNITY,
  // Store actions
  'VIEW_IN_PS_STORE', 'VIEW_MY_ADD_ONS', 'VIEW_MY_THEMES', 'VIEW_MY_AVATARS', 'VIEW_STORE_ADD_ON', 'VIEW_STORE_THEME', 'VIEW_STORE_AVATAR', 'VIEW_STORE_EXTRA', 'VIEW_VOTE_TO_PLAY', 'ADD_TO_CART', 'REMOVE_FROM_CART', 'ADD_TO_CART_UPSELL', 'VERSION_UPSELL', 'PSPLUS_UPSELL', 'OPTIMUS', 'ADD_TO_WISHLIST', 'CREATE_WISHLIST', 'REMOVE_FROM_WISHLIST', 'PREORDER_INTRO', 'SUBSCRIBE_AUTOFUND', 'SUBSCRIBE_EXTEND_INTRO', 'REDEEM_VOUCHER', 'REDEEM_MONEY_VOUCHER', 'VOUCHER_APPLICATION_CASH', 'VOUCHER_APPLICATION_PRODUCT', 'VOUCHER_APPLICATION_PRODUCT_PERCENT_OFF', 'VOUCHER_APPLICATION_ORDER_PERCENT_OFF', 'MULTI_BUY_ADD_ANOTHER_ITEM', 'CHANGE_SUBSCRIPTION_STATUS', 'DOWNLOAD_PS_NOW_GAME', 'LOGIN', // FPI checkout actions
  'COUNTDOWNTIMER', 'STARTGAME_CLICK', 'DOWNLOAD_PAUSE', 'DOWNLOAD_RESUME', 'CONFIRM_PURCHASE', // OSK Search actions
  'OSK_SEARCH_TEXT_ENTRY', 'OSK_SEARCH_ZERO_STATE', 'OSK_SEARCH_NO_RESULTS', 'OSK_SEARCH_RESULTS_RETURN', // Live Detail actions
  'START_GAME', 'START_APP', 'CLOSE_GAME', 'CLOSE_APP', 'RATE', 'DOWNLOAD', 'DOWNLOAD_PROGRESS', 'TRY_FREE_DEMO', 'TRY_FULL_GAME', 'BUY', 'BUY_PS_PLUS_PRICE', 'PRE_ORDER', 'PRE_ORDER_COUNTDOWN', 'GET_IT_NOW', 'CLICK_LIVE_TILE', 'VIEW_LIVE_DETAIL', 'INITIATE_ADD_TO_LIBRARY', 'ADD_TO_LIBRARY', 'CLICK_TO_LIVE_BROADCAST', // Plus Destination
  'JOIN_PS_PLUS', 'MANAGE_SUBSCRIPTION', 'MANAGE_STORAGE', 'MANAGE_MEMBERSHIP', 'AUTO_RENEW_VALUE_PROP_YES', 'AUTO_RENEW_VALUE_PROP_NO', 'AUTO_RENEW_FEEDBACK_CONTINUE', 'AUTO_RENEW_CONFIRMATION_OK', // Who to Follow Destination
  'VIEW_MINI_PROFILE', // PSN account
  'JOIN_NOW', 'SIGN_UP', 'SIGN_IN', 'SIGN_OUT', 'SETUP_2_STEP_VERIFICATION', 'CHANGE_AUTO_RENEW_PAYMENT_SETTING', 'CHANGE_PASSWORD_PAYMENT_SETTING', 'SAVE_PAYMENT_METHOD_INFORMATION', 'REMOVE_PAYMENT_METHOD', 'SAVE_DEFAULT_PAYMENT_METHOD', 'ADD_PAYMENT_METHOD', 'CHANGE_AGE_VERIFICATION_DOCUMENT', 'COMPLETE_AGE_VERIFICATION_DOCUMENT', 'ABORT_SECURE_VERIFYING', 'ACTIVATE_2SV', 'DEACTIVATE_2SV', 'ADD_PHONE_NUMBER', 'REMOVE_PHONE_NUMBER', 'VERIFY_PHONE_NUMBER', 'SEND_FAMILY_INVITE', 'ACCEPT_FAMILY_INVITE', 'DECLINE_FAMILY_INVITE', 'REVOKE_FAMILY_INVITE', 'LEAVE_FAMILY', 'REMOVE_USER_FROM_FAMILY', 'PROMOTE_TO_GUARDIAN', 'CHANGE_PARENTAL_CONTROLS', 'DEMOTE_FROM_GUARDIAN', 'VIEW_AS_FAMILY_MANAGER', 'VIEW_AS_GUARDIAN', 'CREATE_MASTER_ACCOUNT', 'CREATE_YOUTH_ACCOUNT', 'CREATE_KID_ACCOUNT', 'CREATE_OFFLINE_ACCOUNT', 'CLAIM_YOUTH_ACCOUNT', 'CLAIM_KID_ACCOUNT', 'APPROVE_SUBACCOUNT', 'EDIT_ACCOUNT_INFO', 'CHANGE_SECURITY_SETTINGS', 'SUGGEST_ONLINE_ID', 'CONFIRM_ONLINE_ID', 'CHANGE_OLD_ID_DISPLAY_SETTING', 'DEACTIVATE_DEVICE', 'ACTIVATE_DEVICE', 'VERIFY_CODE', 'RESEND_CODE', 'SEND_EMAIL', // Grief reporting
  'INITIATE_GRIEF_REPORT', 'BACK_FROM_STEP_GRIEF_REPORT', 'CANCEL_GRIEF_REPORT', 'COMPLETE_STEP1_GRIEF_REPORT', 'COMPLETE_STEP2_GRIEF_REPORT', 'SEND_GRIEF_REPORT', // Quick view
  ['CLICK_QUICK_VIEW_SELECT_BANNER', 'quick view select banner'], ['CLICK_QUICK_VIEW_HOVER_BANNER', 'quick view hover banner'], ['CLICK_QUICK_VIEW_NAVIGATION', 'quick view navigation'], ['CLICK_QUICK_VIEW_CLOSE', 'quick view close'], ['CLICK_QUICK_VIEW_OPEN', 'quick view open'], // PS App actions
  'CLOSE_WINDOW', 'REDEEM_CODE_SCAN', 'REDEEM_CODE_MANUAL', 'EASY_SIGNIN_SCAN', 'EASY_SIGNIN_MANUAL', // Misc actions
  'FILTER_BY_MOST_RECENT', 'FILTER_BY_MOST_POPULAR', 'VIEW_ALL', 'OPEN', 'SEARCH', 'VIEW_SEARCH_RESULT', 'DELETE', 'EXIT_BACK', 'EXIT_PS_BUTTON', 'EXPAND_WINDOW', 'OPEN_GALLERY_VIEW', 'VIEW_NOTICE', 'CHECK_FOR_UPDATE', 'UPDATE_HISTORY', 'INFORMATION', 'ADD_TO_FOLDER', 'MOVE_FROM_FOLDER', 'EDIT_FOLDER', 'CLICK_TILE', 'CLICK_BANNER', 'SELECT_BANNER', 'CANCEL_OVERLAY', 'DISMISS_OVERLAY', 'PERMANENTLY_REMOVE_OVERLAY', 'CLICK_OVERLAY', 'FILTER_CATEGORY', 'SORT_CATEGORY', 'CLICK_RECOMMENDATION', 'FAVORITED', 'UNFAVORITED', // Social on web navigation
  'VIEW_FRIENDS', 'VIEW_HOME', 'VIEW_PDC', 'VIEW_ACTIVITY_FEED', 'CLICK_SUBSCRIPTION_MANAGEMENT', 'VIEW_DOWNLOAD_LIST', 'VIEW_DOWNLOAD_QUEUE', 'VIEW_MY_VIDEOS', 'VIEW_STOREFRONT_COUNTRY', 'VIEW_WISHLIST', 'CLICK_BUTTON', 'CLICK_ARROW', 'CLICK_ICON', 'CLICK_NAV', // Social on Web Footer navigation
  ['CLICK_TOS', 'click terms of service'], // 'CLICK_TERMS_OF_SERVICE', // Replacement for CLICK_TOS
  'CLICK_PRIVACY_POLICY', 'CLICK_ABOUT_US', ['CLICK_CA_PRIVACY_RIGHTS', 'click your ca privacy rights'], // 'CLICK_YOUR_CA_PRIVACY_RIGHTS', // Replacement for CLICK_CA_PRIVACY_RIGHTS
  'CLICK_BLOG', 'CLICK_SUPPORT', 'CLICK_CONTACT_US', ['CLICK_OPEN_OSS', 'click open source licenses'], // 'CLICK_OPEN_SOURCE_LICENSES', // Replacement for CLICK_OPEN_SOURCE_LICENSES
  'CLICK_CAREERS', 'CLICK_PAYMENT_MANAGEMENT', 'CLICK_REDEEM_CODES', // Social on Web trophies page
  ['VIEW_ADDON_TROPHIES', 'view add-on trophies'], 'VIEW_MORE_GAMES', // privacy
  'MANAGE_PERSONALIZATION_SETTINGS', 'VIEW_PRIVACY_SETTINGS', 'MANAGE_DATA_GATHERING_SETTINGS', // playtime Settings
  'CHANGE_PLAYTIME_LIMIT', // PS Vue Settings
  'SELECT_SET_HOME_DEVICE', 'SUBMIT_HOME_DEVICE', 'RETRY_DEVICE_LIMIT', 'CONFIRM_OUT_OF_DMA', 'ADD_TO_MY_DVR', 'REMOVE_FROM_MY_DVR', 'MORE_EPISODES', 'GO_TO_CHANNEL', 'START_WATCHING', 'CONTINUE_WATCHING', 'PLAY_LATEST_EPISODE', 'VIEW_FULL_DESCRIPTION', 'GO_BACK', 'GENRE', 'MULTIVIEW_PROGRAM_ADDED', 'MULTIVIEW_PROGRAM_REMOVED', 'MULTIVIEW_SWITCH_ONFOCUS', 'MULTIVIEW_SWITCH_OFFFOCUS', 'MULTIVIEW_WATCH', // AD Click
  'AD_CLICK', // Jetstream Navigation
  'CLICK_HEADER'];
  var CLICK_TYPES$1 = generateEnum(CLICK_TYPES, lowerCaseSpace);

  /**
   * Values for countries
   * @enum {string}
   */

  var COUNTRIES = ['AE', // United Arab Emirates (PSN supported)
  'AR', // Argentina (PSN supported)
  'AT', // Austria (PSN supported)
  'AU', // Australia (PSN supported)
  'BA', // Bosnia and Herzegovina (no PSN support)
  'BE', // Belgium (PSN supported)
  'BG', // Bulgaria (PSN supported)
  'BH', // Bahrain (PSN supported)
  'BO', // Bolivia (PSN supported)
  'BR', // Brazil (PSN supported)
  'CA', // Canada (PSN supported)
  'CH', // Switzerland (PSN supported)
  'CL', // Chile (PSN supported)
  'CN', // China (PSN supported)
  'CO', // Colombia (PSN supported)
  'CR', // Costa Rica (PSN supported)
  'CY', // Cyprus (PSN supported)
  'CZ', // Czech Republic (PSN supported)
  'DE', // Germany (PSN supported)
  'DK', // Denmark (PSN supported)
  'EC', // Ecuador (PSN supported)
  'EE', // Estonia (no PSN support)
  'ES', // Spain (PSN supported)
  'FI', // Finland (PSN supported)
  'FR', // France (PSN supported)
  'GB', // United Kingdom (PSN supported)
  'GR', // Greece (PSN supported)
  'GT', // Guatemala (PSN supported)
  'HK', // Hong Kong (PSN supported)
  'HN', // Honduras (PSN supported)
  'HR', // Croatia (PSN supported)
  'HU', // Hungary (PSN supported)
  'ID', // Indonesia (PSN supported)
  'IE', // Ireland (PSN supported)
  'IL', // Israel (PSN supported)
  'IN', // India (PSN supported)
  'IR', // Iran (no PSN support)
  'IS', // Iceland (PSN supported)
  'IT', // Italy (PSN supported)
  'JP', // Japan (PSN supported)
  'KR', // Korea (PSN supported)
  'KW', // Kuwait (PSN supported)
  'KZ', // Kazakhstan (no PSN support)
  'LB', // Lebanon (PSN supported)
  'LT', // Lithuania (no PSN support)
  'LU', // Luxembourg (PSN supported)
  'LV', // Latvia (no PSN support)
  'ME', // Montenegro (no PSN support)
  'MK', // Macedonia (no PSN support)
  'MT', // Malta (PSN supported)
  'MX', // Mexico (PSN supported)
  'MY', // Malaysia (PSN supported)
  'NI', // Nicaragua (PSN supported)
  'NL', // Netherlands (PSN supported)
  'NO', // Norway (PSN supported)
  'NZ', // New Zealand (PSN supported)
  'OM', // Oman (PSN supported)
  'PA', // Panama (PSN supported)
  'PE', // Peru (PSN supported)
  'PL', // Poland (PSN supported)
  'PT', // Portugal (PSN supported)
  'PY', // Paraguay (PSN supported)
  'QA', // Qatar (PSN supported)
  'RO', // Romania (PSN supported)
  'RS', // Serbia (no PSN support)
  'RU', // Russia (PSN supported)
  'SA', // Saudi Arabia (PSN supported)
  'SE', // Sweden (PSN supported)
  'SG', // Singapore (PSN supported)
  'SI', // Slovenia (PSN supported)
  'SK', // Slovakia (PSN supported)
  'SV', // El Salvador (PSN supported)
  'TH', // Thailand (PSN supported)
  'TR', // Turkey (PSN supported)
  'TW', // Taiwan (PSN supported)
  'UA', // Ukraine (PSN supported)
  'US', // United States (PSN supported)
  'UY', // Uruguay (PSN supported)
  'VN', // Vietnam (no PSN support)
  'ZA' // South Africa (PSN supported)
  ];
  var COUNTRIES$1 = generateEnum(COUNTRIES);

  /**
   * Values for device types
   * @enum {string}
   */

  var DEVICES = ['PS3', 'PS4', 'PS4K', 'TV', 'WEB', 'MWEB', 'ANDROID', 'IOS', 'ROKU', 'ANDROID_TV', 'FIRE_TV', 'APPLE_TV', 'CHROMECAST'];
  var DEVICES$1 = generateEnum(DEVICES, lowerCase);

  /**
   * Values for form actions used with form events
   * @enum {string}
   */

  var FORM_ACTIONS = ['START', 'COMPLETE', 'NEXT', 'BACK', 'CANCEL', 'SKIP', 'START_NESTED', 'COMPLETE_NESTED'];
  var FORM_ACTIONS$1 = generateEnum(FORM_ACTIONS, lowerCaseSpace);

  /**
   * Values for locales
   * @enum {string}
   */

  var LOCALES = ['ar_AE', 'ar_BH', 'ar_KW', 'ar_LB', 'ar_OM', 'ar_QA', 'ar_SA', 'ch_HK', 'ch_TW', 'cs_CZ', 'da_DK', 'de_AT', 'de_CH', 'de_DE', 'de_LU', 'el_GR', 'en_AE', 'en_AR', 'en_AU', 'en_BG', 'en_BH', 'en_BR', 'en_CA', 'en_CL', 'en_CO', 'en_CR', 'en_CY', 'en_CZ', 'en_DK', 'en_EC', 'en_FI', 'en_GB', 'en_GR', 'en_HK', 'en_HR', 'en_HU', 'en_ID', 'en_IE', 'en_IL', 'en_IN', 'en_IS', 'en_KW', 'en_LB', 'en_MT', 'en_MX', 'en_MY', 'en_NO', 'en_NZ', 'en_OM', 'en_PA', 'en_PE', 'en_PL', 'en_QA', 'en_RO', 'en_SA', 'en_SE', 'en_SG', 'en_SI', 'en_SK', 'en_TH', 'en_TR', 'en_TW', 'en_US', 'en_ZA', 'es_AR', 'es_BO', 'es_BR', 'es_CL', 'es_CO', 'es_CR', 'es_EC', 'es_ES', 'es_GT', 'es_HN', 'es_MX', 'es_NI', 'es_PA', 'es_PE', 'es_PY', 'es_SV', 'es_UY', 'fi_FI', 'fr_BE', 'fr_CA', 'fr_CH', 'fr_FR', 'fr_LU', 'hu_HU', 'id_ID', 'it_CH', 'it_IT', 'ja_JP', 'ko_KR', 'nl_BE', 'nl_NL', 'no_NO', 'pl_PL', 'pt_BR', 'pt_PT', 'ro_RO', 'ru_RU', 'ru_UA', 'sv_SE', 'th_TH', 'tr_TR', 'vi_VN', 'zh_CN', 'zh_HK', 'zh_TW'];
  var LOCALES$1 = generateEnum(LOCALES);

  /**
   * Values for network connection types
   * @enum {string}
   */
  var NETWORKS = Object.freeze({
    WIFI: 'wifi',
    WIRED: 'wired',
    CELL_LTE: 'cell lte',
    CELL_3G: 'cell 3G'
  });

  var lowerCaseColon = (function (v) {
    return v.toLowerCase().replace(/_/g, ':');
  });

  /**
   * Values for payment methods used with transaction events
   * @enum {string}
   */

  var PAYMENT_METHODS = ['CC_AMEX', 'CC_CARTEBANCAIRE', 'CC_CARTEBLEUE', 'CC_DISCOVER', 'CC_ELO', 'CC_HIPERCARD', 'CC_JCB', 'CC_MAESTRO', 'CC_MASTERCARD', 'CC_MASTERCARD_3DS', 'CC_VISA', 'CC_VISA_3DS', 'APM_PAYPAL', 'APM_PAYPAL_DI', 'APM_ALIPAY', 'APM_BOKU', 'APM_BOKU_DI', 'APM_CASHU', 'APM_CHINAUNIONPAY', 'APM_EDY', 'APM_GIROPAY', 'APM_IDEAL', 'APM_MISTERCASH', 'APM_PAYSAFECARD', 'APM_POSTEPAY', 'APM_SOFORT', 'APM_SOLO', 'APM_YANDEXMONEY', 'VOUCHER', 'WALLET'];
  var PAYMENT_METHODS$1 = generateEnum(PAYMENT_METHODS, lowerCaseColon);

  /**
   * Manage personalization settings personalization permission.
   * @enum {string}
   */

  var PERSONALIZED_ADS = [['ALLOW', 'allow advertising'], ['DISALLOW', 'disallow advertising'] // 'ALLOW_ADVERTISING', // Replacement for above
  // 'DISALLOW_ADVERTISING' // Replacement for above
  ];
  var PERSONALIZED_ADS$1 = generateEnum(PERSONALIZED_ADS, lowerCaseSpace);

  /**
   * Values for PS Now subscription types
   * @enum {string}
   */

  var PSNOW_TYPES = ['TRIAL', 'SUBSCRIPTION', 'NOT_SUBSCRIBED'];
  var PSNOW_TYPES$1 = generateEnum(PSNOW_TYPES, lowerCaseSpace);

  /**
   * Values for PS Plus sub types
   * @enum {string}
   */

  var PSPLUS_TYPES = ['FREE_TRIAL', 'SUBSCRIPTION', 'LAPSED', 'NEVER_SUBSCRIBED'];
  var PSPLUS_TYPES$1 = generateEnum(PSPLUS_TYPES, lowerCaseSpace);

  /**
   * Values for product types
   * @enum {string}
   */

  var PRODUCT_TYPES = ['GAME_DIGITAL', 'GAME_DISC', 'GAME_PSNOW_PS3', 'GAME_PSNOW_PS4', 'APP'];
  var PRODUCT_TYPES$1 = generateEnum(PRODUCT_TYPES);

  /**
   * Manage purchase recommendation settings tracking permission.
   * @enum {string}
   */

  var PURCHASE_REC = [['ALLOW', 'allow recommendations'], ['DISALLOW', 'disallow recommendations'] // 'ALLOW_RECOMMENDATIONS', // Replacement for above
  // 'DISALLOW_RECOMMENDATIONS' // Replacement for above
  ];
  var PURCHASE_REC$1 = generateEnum(PURCHASE_REC, lowerCaseSpace);

  /**
   * Values for remote fetch environment.
   * @enum {string}
   */
  var REMOTE_UPDATE_ENVIRONMENT = Object.freeze({
    E1: 'e1-np',
    NP: 'np'
  });

  /**
   * Values for error severities
   * @enum {string}
   */

  var SEVERITIES = ['CRITICAL', // Sev0 - Application crashes or user cannot login into app
  'MAJOR', // Sev1 - A feature within the app is broken and user flow is interrupted
  'MINOR', // Sev2 - A feature within the app is broken however user flow is not interrupted
  'NORMAL', // Sev3 - This is usually for expected errors
  'INFO' // Sev4 - This is usually for debug/info kind of errors
  ];
  var SEVERITIES$1 = generateEnum(SEVERITIES, lowerCase);

  /**
   * Values for startup types
   * @enum {string}
   */

  var STARTUP_TYPES = ['APP', ['PAGE', 'Page']];
  var STARTUP_TYPES$1 = generateEnum(STARTUP_TYPES);

  /**
   * Values for video stream types
   * @enum {string}
   */

  var STREAM_TYPES = ['LIVE', 'VOD', 'DVR', 'CATCH_UP', 'PROMO', 'TRAILER', 'PS_VUE_LIVE', 'TVOD', // TVOD=Transactional Video On Demand (usually EST (purchase) and VOD (usually means rental when you just say "VOD")
  'SVOD', // SVOD=Subscription Video On Demand, usually like the "Netflix model"
  'HLS', // HLS=HTTP Live Streaming
  'DASH', // DASH=Dynamic Adaptive Streaming over HTTP
  'NONE', 'UNKNOWN'];
  var STREAM_TYPES$1 = generateEnum(STREAM_TYPES);

  /**
   * Values for transaction types used with transaction events
   * @enum {string}
   */

  var TRANSACTION_TYPES = ['VOUCHER_CASH', 'VOUCHER_PRODUCT', 'FUNDING', 'FUNDING_3DS', 'BEGIN_3DS', 'COMPLETE_3DS', 'MISC', 'VIEW_PRODUCT', 'ADD_TO_CART', 'REMOVE_FROM_CART', 'VIEW_CART', 'CONFIRM_PURCHASE', 'PURCHASE', 'PURCHASE_3DS', 'BUY_NOW', 'BUY_NOW_3DS', 'PREORDER_PAY_NOW', 'PREORDER_PAY_NOW_3DS', 'RECOMMENDATION', 'VOUCHER_PRODUCT_PERCENT_OFF', 'VOUCHER_ORDER_PERCENT_OFF', 'VOUCHER_PRODUCT_FIXED_AMOUNT_OFF', ['APPLY_VOUCHER', 'voucher application'], 'PURCHASE_DETAILS', 'PROCESSING_PAYMENT', 'CONFIRM_PURCHASE_FPI' // 'VOUCHER_APPLICATION' // Replacement for APPLY_VOUCHER
  ];
  var TRANSACTION_TYPES$1 = generateEnum(TRANSACTION_TYPES, lowerCaseSpace);

  /**
   * Values for video actions
   * @enum {string}
   */

  var VIDEO_ACTIONS = ['START', 'PAUSE', 'RESUME', 'PROGRESS', 'COMPLETE', 'AUTO_START', 'ON_FOCUS_START', 'ON_FOCUS_AUTO_START', 'REBUFFER', 'PLAYER_ERROR'];
  var VIDEO_ACTIONS$1 = generateEnum(VIDEO_ACTIONS);

  /**
   * Values for video stream types
   * @enum {string}
   */

  var VIDEO_TYPES = ['TV_SHOWS', 'MOVIES', 'SPORTS', 'NEWS', 'SENTV_VIDEOS', 'INFOMERCIALS', 'PROMO', 'USER_GENERATED_CONTENT', 'LIVE_EVENT', 'CATCH_UP', 'CHANNEL', 'MUSIC', 'OTHER', 'NONE'];
  var VIDEO_TYPES$1 = generateEnum(VIDEO_TYPES);

  /**
   * Values for video formats
   * @enum {string}
   */

  var VIDEO_FORMATS = ['LIVE', 'PREVIEW', 'TRAILER', 'FULL'];
  var VIDEO_FORMATS$1 = generateEnum(VIDEO_FORMATS);

  /**
   * Values for window modes.
   * @enum {string}
   */

  var WINDOW_MODES = ['FULLSCREEN', 'PARTIAL', 'UNKNOWN'];
  var WINDOW_MODES$1 = generateEnum(WINDOW_MODES, lowerCaseSpace);

  /**
   * Object Values as Array cache
   * @type {Object.<string, Array>}
   */

  var valuesCache = {}; // TODO: Replace with Set();

  var buildCache = function buildCache(cacheKey, constantObject) {
    valuesCache[cacheKey] = Object.keys(constantObject).map(function (k) {
      return constantObject[k];
    });
  };

  var valueExistsIn = function valueExistsIn(cacheKey) {
    return function (constantObject) {
      return function (value) {
        if (isUndefined_1(valuesCache[cacheKey])) {
          buildCache(cacheKey, constantObject);
        }

        return arrayIncludes(valuesCache[cacheKey], value);
      };
    };
  };
  var isValidCountry = valueExistsIn('COUNTRIES')(COUNTRIES$1);
  var isValidDevice = valueExistsIn('DEVICES')(DEVICES$1);
  var isValidFormAction = valueExistsIn('FORM_ACTIONS')(FORM_ACTIONS$1);
  var isValidNetwork = valueExistsIn('NETWORKS')(NETWORKS);
  var isValidNetworkType = isValidNetwork;
  var isValidPaymentMethod = valueExistsIn('PAYMENT_METHODS')(PAYMENT_METHODS$1);
  var isValidPsNowType = valueExistsIn('PSNOW_TYPES')(PSNOW_TYPES$1);
  var isValidPSNowType = isValidPsNowType;
  var isValidPsPlusType = valueExistsIn('PSPLUS_TYPES')(PSPLUS_TYPES$1);
  var isValidSeverity = valueExistsIn('SEVERITIES')(SEVERITIES$1);
  var isValidStreamType = valueExistsIn('STREAM_TYPES')(STREAM_TYPES$1);
  var isValidTransactionType = valueExistsIn('TRANSACTION_TYPES')(TRANSACTION_TYPES$1);
  var isValidVideoAction = valueExistsIn('VIDEO_ACTIONS')(VIDEO_ACTIONS$1);
  var isValidVideoFormat = valueExistsIn('VIDEO_FORMATS')(VIDEO_FORMATS$1);
  var isValidVideoType = valueExistsIn('VIDEO_TYPES')(VIDEO_TYPES$1);
  var isValidWindowMode = valueExistsIn('WINDOW_MODES')(WINDOW_MODES$1);

  var _messageTemplates;

  function _inheritsLoose$a(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var MISSING_FIELD_DEVICE_ID = 'missingFieldDeviceId';
  var MISSING_FIELD_APP_NAME = 'missingFieldApplicationName';
  var MISSING_FIELD_BUILD_VERSION = 'missingFieldBuildVersion';
  var MISSING_FIELD_DEVICE_TYPE = 'missingFieldDeviceType';
  var MISSING_FIELD_CHARSET = 'missingFieldCharSet';
  var MISSING_PSN_ACCOUNT_LANGUAGE = 'missingPsnAccountLanguage';
  var MISSING_PSN_ACCOUNT_REGION = 'missingPsnAccountRegion';
  var INVALID_DEVICE_TYPE = 'invalidDeviceType';
  var INVALID_NETWORK_TYPE = 'invalidNetworkType';
  var INVALID_NP_ACCOUNT_LOCALE$1 = 'invalidNpAccountLocale';
  var INVALID_PSN_ACCOUNT_LANGUAGE = 'invalidPsnAccountLanguage';
  var INVALID_PSN_ACCOUNT_REGION = 'invalidPsnAccountRegion';
  var messageTemplates$3 = (_messageTemplates = {}, _defineProperty$6(_messageTemplates, MISSING_FIELD_DEVICE_ID, 'The field "deviceId" is required and cannot be empty.'), _defineProperty$6(_messageTemplates, MISSING_FIELD_APP_NAME, 'The field "appName" is required and cannot be empty.'), _defineProperty$6(_messageTemplates, MISSING_FIELD_BUILD_VERSION, 'The field "buildVersion" is required and cannot be empty.'), _defineProperty$6(_messageTemplates, MISSING_FIELD_DEVICE_TYPE, 'The field "deviceType" is required and cannot be empty.'), _defineProperty$6(_messageTemplates, MISSING_FIELD_CHARSET, 'The field "charset" is required and cannot be empty.'), _defineProperty$6(_messageTemplates, MISSING_PSN_ACCOUNT_LANGUAGE, '"psnAccountLanguage" cannot be empty if "psnAccountRegion" is set.'), _defineProperty$6(_messageTemplates, MISSING_PSN_ACCOUNT_REGION, '"psnAccountRegion" cannot be empty if "psnAccountLanguage" is set.'), _defineProperty$6(_messageTemplates, INVALID_DEVICE_TYPE, 'The provided "deviceType" is invalid: {value}.'), _defineProperty$6(_messageTemplates, INVALID_NETWORK_TYPE, 'The provided "networkType" is invalid: {value}.'), _defineProperty$6(_messageTemplates, INVALID_NP_ACCOUNT_LOCALE$1, 'The NP Account Locale "locale" provided is invalid: {value}.'), _defineProperty$6(_messageTemplates, INVALID_PSN_ACCOUNT_LANGUAGE, 'The PSN Account Language "psnAccountLanguage" is invalid: {value}.'), _defineProperty$6(_messageTemplates, INVALID_PSN_ACCOUNT_REGION, 'The PSN Account Language "psnAccountRegion" is invalid: {value}.'), _messageTemplates);

  var EnvironmentValidator =
  /*#__PURE__*/
  function (_AbstractValidator) {
    _inheritsLoose$a(EnvironmentValidator, _AbstractValidator);

    function EnvironmentValidator() {
      var _this;

      _this = _AbstractValidator.call(this, {
        messageTemplates: messageTemplates$3
      }) || this;
      _this.npAccountValidator = new NpAccountLocaleValidator();
      _this.psnAccountRegionValidator = new PsnAccountRegionValidator();
      _this.psnAccountLanguageValidator = new PsnAccountLanguageValidator();
      return _this;
    }

    var _proto = EnvironmentValidator.prototype;

    _proto.isValid = function isValid(env) {
      var result = true;

      if (!env.appName) {
        this.error(MISSING_FIELD_APP_NAME);
        result = false;
      }

      if (!env.buildVersion) {
        this.error(MISSING_FIELD_BUILD_VERSION);
        result = false;
      }

      if (!env.deviceId) {
        this.error(MISSING_FIELD_DEVICE_ID);
        result = false;
      }

      if (!env.deviceType) {
        this.error(MISSING_FIELD_DEVICE_TYPE);
        result = false;
      }

      if (!env.charset) {
        this.error(MISSING_FIELD_CHARSET);
        result = false;
      }

      if (!isValidDevice(env.deviceType)) {
        this.error(INVALID_DEVICE_TYPE, env.deviceType);
        result = false;
      }

      if (env.networkType && !isValidNetworkType(env.networkType)) {
        this.error(INVALID_NETWORK_TYPE, env.networkType);
        result = false;
      } // The validation here is not strict so that in case of country expansion for PSN,
      // app teams can pass in new values for locale without needing to update GCT "LOCALES"
      // enum. For additional information, please see:
      // https://github.snei.sony.com/SIE/grand-central-telemetry/pull/186
      //
      // However, this potentially creates the issue that app teams can pass in values which
      // are either not valid PSN account locales or not valid locales at all (such as zz_ZZ).
      // We will have to follow up to have better validation here, but keep in mind to have
      // a proper upgrade process for those teams who pass invalid values


      if (env.locale && !this.npAccountValidator.isValid(env.locale)) {
        this.error(INVALID_NP_ACCOUNT_LOCALE$1, env.locale);
        result = false;
      }

      if (env.psnAccountRegion && !this.psnAccountRegionValidator.isValid(env.psnAccountRegion)) {
        this.error(INVALID_PSN_ACCOUNT_REGION, env.psnAccountRegion);
        result = false;
      }

      if (env.psnAccountLanguage && !this.psnAccountLanguageValidator.isValid(env.psnAccountLanguage)) {
        this.error(INVALID_PSN_ACCOUNT_LANGUAGE, env.psnAccountLanguage);
        result = false;
      }

      if (env.psnAccountLanguage && !env.psnAccountRegion) {
        this.error(MISSING_PSN_ACCOUNT_REGION);
        result = false;
      }

      if (!env.psnAccountLanguage && env.psnAccountRegion) {
        this.error(MISSING_PSN_ACCOUNT_LANGUAGE);
        result = false;
      }

      return result;
    };

    return EnvironmentValidator;
  }(AbstractValidator);

  function _slicedToArray$4(arr, i) { return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _nonIterableRest$4(); }

  function _nonIterableRest$4() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$4(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$4(arr) { if (Array.isArray(arr)) return arr; }

  /**
   * @private
   * @type {RegExp}
   */
  var regex$1;
  /**
   * @private
   * @returns {RegExp}
   */

  function getComponentParseRegex$1() {
    if (!regex$1) {
      regex$1 = new RegExp('^' + '([a-z]{2,3})' // Language    2*3 ALPHA
      + '(?:[-_]([a-z]{4}))?' // Script  4   ALPHA
      + '(?:[-_]((?:[a-z]{2})|(?:[0-9]{3})))?' // Region  2* ALPHA | 3 * DIGIT
      + '((?:[-_]' // Variants: Leading "-" included in match
      + '(?:(?:[a-z0-9]{5,8})|(?:[0-9][a-z0-9]{3}))' // Variant: 5*8 ALNUM | DIGIT, 3*ALNUM
      + ')*)' + '((?:' // Extensions/Private Use, leading "-" included in match
      + '(?:[-_][a-wyz0-9]{1})' // Singleton
      + '(?:[-_][a-z0-9]{2,8})+' // One or more patterns
      + ')*)' + '([-_]x' // Private Use
      + '(?:[-_][a-z0-9]{1,8})+' // x- 1*8 ALNUM
      + ')?' + '$', 'i');
    }

    return regex$1;
  }
  /**
   * Convert the variant string match to an array.
   * @private
   * @param {string} variantString
   * @returns {string[]} Array of variant sub-tags
   */


  function convertVariantStringMatchToArray$1(variantString) {
    if (!variantString.length) {
      return [];
    }

    return variantString.split(/-|_/).slice(1);
  }
  /**
   * @typedef {Array} Parse~ComponentList
   * @property {string}   Parse~ComponentList.0 - Language Id
   * @property {string}   Parse~ComponentList.1 - Script Id
   * @property {string}   Parse~ComponentList.2 - Region Id
   * @property {string[]} Parse~ComponentList.3 - Variants
   * @property {Array}    Parse~ComponentList.4 - Extensions
   *
   */

  /**
   * Returns the component parts of the Tag.
   * @param {string} tagString
   * @returns {Parse~ComponentList}  Returns the result as an array
   *  to avoid the overhead of object initialization.  Internal use only.
   * @private
   */


  function asComponents$1(tagString) {
    var matches = getComponentParseRegex$1().exec(tagString);

    if (!matches) {
      return null;
    }

    var _matches = _slicedToArray$4(matches, 5),
        languageId = _matches[1],
        scriptId = _matches[2],
        regionId = _matches[3],
        variantString = _matches[4];

    var variantArray = convertVariantStringMatchToArray$1(variantString); // Extensions not implemented yet.

    var extensionArray = [];
    return [languageId, scriptId, regionId, variantArray, extensionArray];
  }
  /**
   * @typedef {Object} LanguageObject
   * @property {string} languageId
   * @property {string} scriptId
   * @property {string} regionId
   * @property {string[]} variants
   * @property {Array} extensions
   */

  /**
   * Create a Language Tag from a string representation.
   *
   * @param {string} tagString
   * @return {LanguageObject}  Language Tag, null on failure
   * @see asComponents
   */


  var parseLanguageTag$1 = (function (tagString) {
    var componentParts = asComponents$1(tagString);

    if (!componentParts) {
      return null;
    }

    var _componentParts = _slicedToArray$4(componentParts, 5),
        languageId = _componentParts[0],
        scriptId = _componentParts[1],
        regionId = _componentParts[2],
        variants = _componentParts[3],
        extensions = _componentParts[4];

    return {
      languageId: languageId,
      scriptId: scriptId,
      regionId: regionId,
      variants: variants,
      extensions: extensions
    };
  });

  function _defineProperties$l(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$l(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$l(Constructor.prototype, protoProps); if (staticProps) _defineProperties$l(Constructor, staticProps); return Constructor; }

  var LegacyEnvironmentControl =
  /*#__PURE__*/
  function () {
    /**
     *
     * @param {LegacyEnvironment} legacyEnvironment
     * @param options
     */
    function LegacyEnvironmentControl(legacyEnvironment) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this._legacyEnvironment = legacyEnvironment;
      this._logger = options.logger;
      this._deprecationManager = options.deprecationManager;
      /**
       * @type {NpAccountLocaleValidator}
       * @private
       */

      this._npAccountLocaleValidator = undefined;
      /**
       * @type {PsnAccountLanguageValidator}
       * @private
       */

      this._psnAccountLanguageValidator = undefined;
      /**
       * @type {PsnAccountRegionValidator}
       * @private
       */

      this._psnAccountRegionValidator = undefined;
    }
    /**
     * @private
     * @returns {PsnAccountLanguageValidator}
     */


    var _proto = LegacyEnvironmentControl.prototype;

    _proto._requireValidPlusUserType = function _requireValidPlusUserType(plusUserType) {
      if (plusUserType && !isValidPsPlusType(plusUserType)) {
        throw new Error('Invalid value for plusUserType.');
      }
    };

    _proto.user_signOut = function user_signOut() {
      this._legacyEnvironment.withUserSignedOut();
    };

    _proto.user_withPlusMembership = function user_withPlusMembership(plusUserType) {
      this._requireValidPlusUserType(plusUserType);

      this._legacyEnvironment.withUserPlusMembership(plusUserType);
    };

    _proto.user_withNoPlusMembership = function user_withNoPlusMembership(plusUserType) {
      this._requireValidPlusUserType(plusUserType);

      this._legacyEnvironment.withUserNoPlusMembership(plusUserType);
    };

    _proto.user_withPostalCode = function user_withPostalCode(postalCode) {
      var postalCodeValue;

      if (postalCode) {
        if (isString$4(postalCode) && !isEmptyOrSpaces(postalCode)) {
          postalCodeValue = postalCode.trim();
        } else if (isInt(postalCode) && postalCode > 0) {
          postalCodeValue = String(postalCode);
        }
      }

      this._legacyEnvironment.withUserPostalCode(postalCodeValue);
    };

    _proto.user_withDma = function user_withDma(dma) {
      var dmaValue;

      if (dma) {
        if (isString$4(dma) && !isEmptyOrSpaces(dma)) {
          dmaValue = dma.trim();
        } else if (isInt(dma) && dma > 0) {
          dmaValue = String(dma);
        }
      }

      this._legacyEnvironment.withUserDma(dmaValue);
    };

    _proto.user_withPsNowMembershipType = function user_withPsNowMembershipType(psNowMembershipType) {
      this._legacyEnvironment.withUserPsNowMembershipType(psNowMembershipType);
    };

    _proto._user_withPsnAccountLanguage = function _user_withPsnAccountLanguage(psnAccountLanguage) {
      if (psnAccountLanguage && !this.psnAccountLanguageValidator.isValid(psnAccountLanguage)) {
        throw new Error("Invalid value for \"psnAccountLanguage\": ".concat(psnAccountLanguage, "!"));
      }

      this._legacyEnvironment.withUserPsnAccountLanguage(psnAccountLanguage);
    };

    _proto._user_withPsnAccountRegion = function _user_withPsnAccountRegion(psnAccountRegion) {
      if (psnAccountRegion && !this.psnAccountRegionValidator.isValid(psnAccountRegion)) {
        throw new Error("Invalid value for \"psnAccountRegion\": ".concat(psnAccountRegion, "!"));
      }

      this._legacyEnvironment.withUserPsnAccountRegion(psnAccountRegion);
    };

    _proto.user_withPsnAccount = function user_withPsnAccount(psnAccountLanguage, psnAccountRegion) {
      // Setting this value invalidates locale
      this._legacyEnvironment.withoutUserNpLocale();

      this._user_withPsnAccountRegion(psnAccountRegion);

      this._user_withPsnAccountLanguage(psnAccountLanguage);
    };

    _proto.user_withNpAccountLocale = function user_withNpAccountLocale(npAccountLocale) {
      if (!npAccountLocale) {
        this.user_withPsnAccount(false, false);
        return;
      }

      this._deprecationManager.trigger(new Deprecation({
        date: '2019-03-12',
        name: 'environment.locale',
        description: 'Use of env.locale is deprecated, use psnAccountLanguage and psnAccountRegion.',
        overrideKey: 'allowEnvironmentLocale'
      })); // The validation here is not strict so that in case of country expansion for PSN,
      // app teams can pass in new values for locale without needing to update GCT "LOCALES"
      // enum. For additional information, please see:
      // https://github.snei.sony.com/SIE/grand-central-telemetry/pull/186
      //
      // However, at a minimum we ensure that the country is valid. Please note that this
      // validation is no the same as done in the constructor so we should revisit in the
      // future.


      if (!this.npAccountLocaleValidator.isValid(npAccountLocale)) {
        throw new Error("Invalid value for \"locale\": ".concat(npAccountLocale, "!"));
      }

      if (!isValidCountry(npAccountLocale.substr(-2))) {
        throw new Error("Invalid country in \"locale\": ".concat(npAccountLocale, "!"));
      }

      var languageTag = parseLanguageTag$1(npAccountLocale);

      if (!languageTag || !languageTag.languageId) {
        throw new Error('Invalid Locale encountered in userWithNpAccountLocale.  Should not be possible.');
      }

      this.user_withPsnAccount(languageTag.languageId, languageTag.regionId);
    };

    _proto.platform_withNetworkType = function platform_withNetworkType(networkType) {
      this._legacyEnvironment.withPlatformNetworkType(networkType);
    };

    _proto.compat_withPlusUserStatusAndType = function compat_withPlusUserStatusAndType(isPlusUser, plusUserType) {
      if (isPlusUser === true) {
        this.user_withPlusMembership(plusUserType);
        return;
      }

      if (isPlusUser === false) {
        this.user_withNoPlusMembership(plusUserType);
        return;
      } // Um. You just called a no-op.
      // TODO: Strict error mode to hard fail these scenarios.


      this._logger.error('updatePlusUserStatus called with invalid value for isPlusUser: ', JSON.stringify(isPlusUser));
    }
    /**
     *
     * Notes:
     *    Remove Parameter npAccountLocale after env.locale deprecation is expired.
     *    Final Signature should be:
     *      compat_withUserSignedIn(visitorId, psnAccount, postalCode, dma) {
     * @param visitorId
     * @param npAccountLocale
     * @param postalCode
     * @param dma
     * @param {?PsnAccountObject} psnAccount
     */
    ;

    _proto.compat_withUserSignedIn = function compat_withUserSignedIn(visitorId, npAccountLocale, postalCode, dma, psnAccount) {
      if (npAccountLocale && psnAccount) {
        throw new Error('Cannot use both npAccountLocale and psnAccount.');
      }

      this._legacyEnvironment.withUserSignedIn();

      this._legacyEnvironment.withUserVisitorId(visitorId);

      this.user_withDma(dma);
      this.user_withPostalCode(postalCode); // If this in an actual value, it will throw a deprecation.  Forwards properties internally.

      this.user_withNpAccountLocale(npAccountLocale);

      if (psnAccount) {
        if (!psnAccount.language || !psnAccount.region) {
          throw new Error('The PsnAccountObject must contain keys .language and .region');
        }

        this.user_withPsnAccount(psnAccount.language, psnAccount.region);
      }
    };

    _proto.compat_resolveUndefinedSignedIn = function compat_resolveUndefinedSignedIn() {
      if (this._legacyEnvironment.rawSignedIn !== undefined) {
        return;
      }

      this._legacyEnvironment.withUserSignedIn(); // Deprecation


      this._deprecationManager.trigger(new Deprecation({
        date: '2018-11-14',
        name: 'env.signedIn',
        description: 'Please set a value for env.signedIn.  Default value is changing.',
        overrideKey: 'allowUndefinedEnvSignedIn'
      }));
    };

    _proto.compat_resolveConstructorSignedOut = function compat_resolveConstructorSignedOut() {
      // Nothing to do if signed in.
      if (this._legacyEnvironment.isSignedIn) {
        return;
      }

      this._legacyEnvironment.withUserSignedOut();

      this._legacyEnvironment.withUserVisitorId(undefined);

      this._legacyEnvironment.withUserDma(undefined);

      this._legacyEnvironment.withUserPostalCode(undefined); // Legacy Behaviour was to remove Locale, migrate this forward to prevent unexpected data leak.


      this._legacyEnvironment.withoutUserNpLocale();

      this._legacyEnvironment.withUserPsnAccountRegion(undefined);

      this._legacyEnvironment.withUserPsnAccountLanguage(undefined);
    };

    _proto.compat_withUserSignedOutBlankAssociated = function compat_withUserSignedOutBlankAssociated() {
      this._legacyEnvironment.withUserSignedOut();

      this._legacyEnvironment.withUserVisitorId(undefined);

      this._legacyEnvironment.withUserDma(undefined);

      this._legacyEnvironment.withUserPostalCode(undefined); // Legacy Behaviour was to remove Locale, migrate this forward to prevent unexpected data leak.


      this._legacyEnvironment.withoutUserNpLocale();

      this._legacyEnvironment.withUserPsnAccountRegion(undefined);

      this._legacyEnvironment.withUserPsnAccountLanguage(undefined);
    };

    _createClass$l(LegacyEnvironmentControl, [{
      key: "psnAccountLanguageValidator",
      get: function get() {
        if (!this._psnAccountLanguageValidator) {
          this._psnAccountLanguageValidator = new PsnAccountLanguageValidator();
        }

        return this._psnAccountLanguageValidator;
      }
      /**
       * @private
       * @returns {PsnAccountRegionValidator}
       */

    }, {
      key: "psnAccountRegionValidator",
      get: function get() {
        if (!this._psnAccountRegionValidator) {
          this._psnAccountRegionValidator = new PsnAccountRegionValidator();
        }

        return this._psnAccountRegionValidator;
      }
      /**
       * @private
       */

    }, {
      key: "npAccountLocaleValidator",
      get: function get() {
        if (!this._npAccountLocaleValidator) {
          this._npAccountLocaleValidator = new NpAccountLocaleValidator();
        }

        return this._npAccountLocaleValidator;
      }
    }]);

    return LegacyEnvironmentControl;
  }();

  function _defineProperties$m(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$m(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$m(Constructor.prototype, protoProps); if (staticProps) _defineProperties$m(Constructor, staticProps); return Constructor; }
  /**
   * This class is to handle the legacy "Environment" variable that
   * was handled in TelemetryService constructor, and by various mutators within that service.
   *
   * As these are all Event level properties, that can be mutated and changed, the
   * architecture is updating to allow providing the "environment" property at `disptach()`
   * for all events.
   *
   */

  var LegacyEnvironment =
  /*#__PURE__*/
  function () {
    function LegacyEnvironment(env) {
      this._environment = Object.freeze(cloneDeep_1(env));
    }

    var _proto = LegacyEnvironment.prototype;

    _proto._replaceWith = function _replaceWith(env) {
      this._environment = Object.freeze(env);
    };

    _proto._unfrozenValue = function _unfrozenValue() {
      return cloneDeep_1(this.value);
    };

    _proto.withUserDma = function withUserDma(dma) {
      var env = this._unfrozenValue();

      env.DMA = dma || undefined;

      this._replaceWith(env);
    };

    _proto.withUserNoPlusMembership = function withUserNoPlusMembership() {
      var plusUserType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      var env = this._unfrozenValue();

      env.isPlusUser = false;
      env.plusUserType = plusUserType && isValidPsPlusType(plusUserType) ? plusUserType : undefined;

      this._replaceWith(env);
    };

    _proto.withoutUserNpLocale = function withoutUserNpLocale() {
      var env = this._unfrozenValue();

      delete env.locale;

      this._replaceWith(env);
    };

    _proto.withUserPsnAccountRegion = function withUserPsnAccountRegion(psnAccountRegion) {
      var env = this._unfrozenValue();

      env.psnAccountRegion = psnAccountRegion || undefined;

      this._replaceWith(env);
    };

    _proto.withUserPsnAccountLanguage = function withUserPsnAccountLanguage(psnAccountLanguage) {
      var env = this._unfrozenValue();

      env.psnAccountLanguage = psnAccountLanguage || undefined;

      this._replaceWith(env);
    };

    _proto.withUserPlusMembership = function withUserPlusMembership() {
      var plusUserType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      var env = this._unfrozenValue();

      env.isPlusUser = true;
      env.plusUserType = plusUserType && isValidPsPlusType(plusUserType) ? plusUserType : undefined;

      this._replaceWith(env);
    };

    _proto.withUserPostalCode = function withUserPostalCode(postalCode) {
      var env = this._unfrozenValue();

      env.postalCode = postalCode || undefined;

      this._replaceWith(env);
    };

    _proto.withUserPsNowMembershipType = function withUserPsNowMembershipType(psnowMembershipType) {
      var type = isValidPSNowType(psnowMembershipType) ? psnowMembershipType : undefined;

      var env = this._unfrozenValue();

      env.psnowMembershipType = type;

      this._replaceWith(env);
    };

    _proto.withUserSignedIn = function withUserSignedIn() {
      var env = this._unfrozenValue();

      env.signedIn = true;

      this._replaceWith(env);
    };

    _proto.withUserSignedOut = function withUserSignedOut() {
      var env = this._unfrozenValue();

      env.signedIn = false;

      this._replaceWith(env);
    };

    _proto.withUserVisitorId = function withUserVisitorId(visitorId) {
      var env = this._unfrozenValue();

      env.visitorId = visitorId || undefined;

      this._replaceWith(env);
    };

    _proto.withPlatformPrivacyWs1 = function withPlatformPrivacyWs1(value) {
      var env = this._unfrozenValue();

      var level = value;

      if (!isValidPlatformPrivacyLevel(value)) {
        level = UserPermissionLevel.MINIMAL;
      }

      env.platformPrivacyWs1 = level;

      this._replaceWith(env);
    };

    _proto.withPlatformNetworkType = function withPlatformNetworkType(networkType) {
      var type = isValidNetworkType(networkType) ? networkType : undefined;

      var env = this._unfrozenValue();

      env.networkType = type;

      this._replaceWith(env);
    };

    _createClass$m(LegacyEnvironment, [{
      key: "value",
      get: function get() {
        return this._environment;
      }
    }, {
      key: "platformNetworkType",
      get: function get() {
        return this.value.networkType;
      }
    }, {
      key: "rawSignedIn",
      get: function get() {
        return this.value.signedIn;
      }
    }, {
      key: "isSignedIn",
      get: function get() {
        // Undefined is "true"
        return this.value.signedIn === undefined || this.value.signedIn;
      }
    }, {
      key: "platformPrivacyWs1",
      get: function get() {
        return this.value.platformPrivacyWs1;
      }
    }, {
      key: "userVisitorId",
      get: function get() {
        return this.value.visitorId;
      }
    }]);

    return LegacyEnvironment;
  }();

  // This is an awful way to implement this, but short on time.  And this feature is temporary.
  // Force plugins.adobe.abortOnWs1 value if undefined.
  var abortAdobeOnWs1ByDefault = false;

  var INVALID_CHARS$1 = ['&quot;', '&rsquo;', '"', '&', '\'', '#', '\\$', '%', '\\^', '\\*', '!', '<', '>', '~', ';', '\\?', 'â„¢', 'Â®', 'Â©', ':'];
  var INVALID_CHARS_REGEX$1 = new RegExp("(".concat(INVALID_CHARS$1.join('|'), ")"), 'g');

  var Utils$1 =
  /*#__PURE__*/
  function () {
    function Utils() {}

    /**
     * truncateJsonToString will go through a JSON literal and truncate each
     * values until the stringified JSON length is less or equal to maxLength.
     * Truncation logic will truncate as many string, Array and Object as
     * necessary, maintaining at least maxValueLength characters of each,
     * to meet the maxLength requirement.
     *
     * @param  {JSON}    [MODIFIED] json is a JSON literal
     * @param  {integer} maxLength is the maximum desired length
     *                    for the JSON string in output
     * @param  {integer} maxValueLength is the maximum desired length
     *                    for a value that needs to be truncated
     * @return {string} return JSON as string that is truncated
     */
    Utils.truncateJsonToString = function truncateJsonToString(json, maxLength, maxValueLength) {
      if (!json) {
        return '';
      }

      var tempString = JSON.stringify(json);

      if (tempString.length <= maxLength) {
        return tempString;
      } // If the caller wants to keep maxValueLength characters worth
      // of data, and on top of that see an ellipsis, then the minimum
      // length to which we can cut down the string is as follows.


      var ellipsis = '...';
      var minTruncatedLength = maxValueLength + ellipsis.length;
      var props = Object.keys(json).map(function (key) {
        var value = json[key];
        var output;

        if (isNumber$1(value) || typeof value === 'undefined') {
          // consider numbers to have zero length so we never convert them to strings.
          // same with undefined values, because json conversion drops properties
          // whose values are undefined.
          output = '';
        } else if (isString$4(value)) {
          output = value;
        } else {
          // cast everything else to string.
          output = JSON.stringify(value);
        }

        return {
          key: key,
          value: value,
          output: output
        };
      }); // Loop and truncate until we reach desired length.

      while (tempString.length > maxLength && props.length > 0) {
        props.sort(function (a, b) {
          return b.output.length - a.output.length;
        }); // the longest value will be at the beginning of the array.

        var longest = props[0];

        if (longest.output.length <= minTruncatedLength) {
          // wow, we must have a lot of little properties!
          // finding and truncating big offenders isn't going to work.
          break;
        } // just remember, if a property is not (yet) a string, do it now and
        // then recompute the output json because the requirement to escape
        // any '"' chars that are present will increase its overall length.


        if (!isString$4(longest.value)) {
          longest.value = longest.output; // eslint-disable-next-line no-param-reassign

          json[longest.key] = longest.value;
          tempString = JSON.stringify(json);
        } // compute a new, truncated length for the longest property value.
        // choose whichever is the biggest of
        //  - only what we need to lop off to make the entire output json <= maxLength
        //  - no less than half it's current length
        //  - no less than the minimum permitted output length


        var truncatedLength = Math.max(longest.value.length - (tempString.length - maxLength), Math.floor(longest.value.length / 2), minTruncatedLength);
        longest.value = longest.value.substring(0, truncatedLength - ellipsis.length) + ellipsis;
        longest.output = longest.value; // eslint-disable-next-line no-param-reassign

        json[longest.key] = longest.value;
        tempString = JSON.stringify(json);
      }

      return tempString;
    }
    /**
     * String sanitization function: removes characters from INVALID_CHARS_REGEX
     * as well as leading/trailing whitespaces. It will also lowercase the output.
     *
     * @param      {string}  input        The input string to sanitize
     * @param      {RegExp}   otherChars   Other characters to filter
     * @param      {boolean} toLowerCase  Should sanitized string be lowercased?
     * @return     {string}  Returns sanitized string
     */
    ;

    Utils.cleanUpString = function cleanUpString(input) {
      var otherChars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var toLowerCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      if (!input) {
        return '';
      }

      var string = String(input);
      string = string.replace(INVALID_CHARS_REGEX$1, '');

      if (otherChars) {
        string = string.replace(otherChars, '');
      }

      string = string.replace(/[ ]{2,}/, ' ').replace(/\s?:\s?/g, ':').replace(/(^\s+|\s+$)/g, '');
      return toLowerCase ? string.toLowerCase() : string;
    }
    /**
     * Location string sanitization function: takes a location string and
     * sanitize each segment.
     *
     * @param      {string}  input   The location input string to sanitize
     * @return     {string}  Returns sanitized location string
     */
    ;

    Utils.cleanUpLocationString = function cleanUpLocationString(input) {
      var locationSegments = [];
      var tmp = input.split(':');

      for (var i = 0; i < tmp.length; i += 1) {
        if (tmp[i]) {
          locationSegments.push(Utils.cleanUpString(tmp[i]));
        }
      }

      return locationSegments.join(':');
    };

    return Utils;
  }();

  function _defineProperties$n(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$n(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$n(Constructor.prototype, protoProps); if (staticProps) _defineProperties$n(Constructor, staticProps); return Constructor; }

  var BasePlugin$2 =
  /*#__PURE__*/
  function () {
    /**
     * Base plugin constructor
     *
     * @param      {json}    [environment]  The environment configuration (e.g. telemetry's config.env)
     * @param      {json}    [config]       The plugin configuration (e.g. telemetry's config.plugins)
     * @param      {string}  pluginName   Name of the plugin - this is used for logging (e.g. 'Foo SDK' or 'Bar API')
     */
    function BasePlugin(environment, config, pluginName, serviceLocator) {
      /*
       * Migration Plan:
       *   Any plugin using the legacy loader will have the default this.logger injected into the config
       *   through the internal use `this.__logger` key.
       *
       *   Long term plan is to simply ditch the BasePlugin class entirely.
       *   All plugins will be required to implement `dispatch(_, request)`.
       *   All plugins will be expected to be instantiated by factory.
       *
       * The || NullLogger() is required so that plugin tests don't break for third parties.
       */
      this.environment = environment || {};
      this.config = config || {};
      this.__logger = this.config.__logger || new NullLogger$2();
      this.__pluginName = pluginName;
      this.__serviceLocator = serviceLocator;
      this._useAsyncInterface = false;
    }

    var _proto = BasePlugin.prototype;

    /**
     * Async Disptach
     * This should be a fully self contained request as the application and state may change interim
     * @param request
     * @returns {Promise.<Object>}
     * @private
     */
    _proto._dispatchAsync = function _dispatchAsync(request) {
      var _this = this;

      // TODO: Update to track Dispatch Result
      // TODO: Update to track Generated Messages
      // TODO: Update to interface with EventInspector
      // TODO: Update signature to return a DispatchResult instance, and not the payload
      var payloadPromise = Promise.resolve(null).then(function () {
        var payload = _this.buildPayloadAsync(request);

        if (!payload) {
          return payload;
        } // TODO: Remove this as a configuration parameter (use Null Dispatcher)


        if (!_this.config.dryRun) {
          _this.sendPayloadAsync(payload, request);
        }

        return payload;
      });
      return payloadPromise;
    }
    /**
     * Original Sync Dispatch
     * TODO: Add Deprecation
     * TODO: Figure Out Deprecation Path
     * @deprecated
     * @param event
     * @returns {*}
     * @private
     */
    ;

    _proto._dispatchSync = function _dispatchSync(event, request) {
      var payload = this.buildPayload(event, request);

      if (!payload) {
        // buildPayload should return false if an error occured when assembling
        // the payload or null if plugin should not send the event
        // In case of error (false) let's log it
        if (payload === false) {
          this.logger.warning("Could not build payload for ".concat(event.type, " event to ").concat(this.pluginName, "!"));
        }
      } else {
        this._logEventPayload(event, payload);

        if (this.config.dryRun) {
          this.logger.warning("Not sending ".concat(event.type, " event to ").concat(this.pluginName, " (dry run)"));
        } else {
          this.sendPayload(payload, event, request);
        }
      }

      return this.config.dryRun ? null : payload;
    }
    /**
     * Interface PluginDispatcher
     *
     * dispatch(event, Request)
     *   v1: Return Payload
     *   v+: Return Promise.<DispatchResponse>
     *
     *
     * Main dispatch function of the plugin. It will call the buildPayload
     * and sendPayload methods which must be defined by the plugin implementor.
     * It will take care of logging the payload before sending it and will
     * also handle dry run functionality.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    ;

    _proto.dispatch = function dispatch(event, request) {
      if (this._useAsyncInterface) {
        return this._dispatchAsync(request);
      } // TODO: Warning!


      return this._dispatchSync(event, request);
    }
    /**
     * Logs a payload.
     * @private
     * @param      {object}  event   Event object from one of the supported event types
     * @param      {object}  payload  The payload
     */
    ;

    _proto._logEventPayload = function _logEventPayload(event, payload) {
      var eventType = event && event.type || 'Unknown';
      this.logger.debug("".concat(this.pluginName, " ").concat(eventType, " Sending payload."), {
        payload: payload
      });
    }
    /**
     * Builds a payload to be sent to the plugin backend API or SDK. The method
     * should be implemented by the plugin author and its return value will be
     * passed to sendPayload() method. Return null if plugin should not sent the
     * event and return false if there is an error building the payload.
     *
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     * @return     {object}  Payload to be sent to backend API or SDK via sendPayload()
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayload = function buildPayload(event, request) {
      this.logger.warning("".concat(this.constructor.name, ".buildPayload() is not implemented by plugin!"));
      return {};
    } // eslint-disable-next-line no-unused-vars
    ;

    _proto.buildPayloadAsync = function buildPayloadAsync(request) {
      throw new Error('Method buildPayloadAsync is abstract.');
    }
    /**
     * Sends a payload to backend API or SDK. The payload object should be generated
     * by buildPayload() method. This method should be implemented by the plugin author.
     *
     * @param      {object}  payload Payload generated by buildPayload()
     * @param      {object}  event   Event object from one of the supported
     *                               event types (src/service/telemetry/events)
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayload = function sendPayload(payload, event, request) {
      this.logger.warning("".concat(this.constructor.name, ".sendPayload() is not implemented by plugin!"));
    }
    /**
     * @param {Object} payload
     * @param {Object} request
     */
    // eslint-disable-next-line no-unused-vars
    ;

    _proto.sendPayloadAsync = function sendPayloadAsync(payload, request) {
      throw new Error('Method sendPayloadAsync is abstract.');
    };

    _createClass$n(BasePlugin, [{
      key: "pluginName",
      get: function get() {
        return this.__pluginName;
      }
    }, {
      key: "serviceLocator",
      get: function get() {
        // TODO: Deprecate Use
        return this.__serviceLocator;
      }
    }, {
      key: "logger",
      get: function get() {
        return this.__logger;
      }
    }]);

    return BasePlugin;
  }();

  /**
   * Constants for Adobe Plugin of Grand Central Telemetry
   * @ignore
   */
  var AdobeConstants = {};
  AdobeConstants.MISSING_VISITOR_ID = '0000000000000000000000000000000000000000000000000000000000000000';
  AdobeConstants.COUNTRY_TERRITORY_ENUM = {
    ae: 'middle_east',
    ar: 'latam',
    at: 'europe_other',
    au: 'anz',
    ba: 'eastern_europe',
    be: 'benelux',
    bg: 'eastern_europe',
    bh: 'middle_east',
    bo: 'latam',
    br: 'latam',
    ca: 'usca',
    ch: 'europe_other',
    cl: 'latam',
    cn: 'china',
    co: 'latam',
    cr: 'latam',
    cy: 'europe_other',
    cz: 'eastern_europe',
    de: 'efigs',
    dk: 'nordics',
    ec: 'latam',
    ee: 'eastern_europe',
    sv: 'latam',
    gt: 'latam',
    hn: 'latam',
    py: 'latam',
    es: 'efigs',
    fi: 'nordics',
    fr: 'efigs',
    gb: 'efigs',
    gr: 'europe_other',
    hk: 'sceh',
    hr: 'europe_other',
    hu: 'eastern_europe',
    id: 'sceh',
    ie: 'europe_other',
    il: 'middle_east',
    "in": 'europe_other',
    ir: 'middle_east',
    is: 'europe_other',
    it: 'efigs',
    jp: 'scej',
    kr: 'scek',
    kw: 'middle_east',
    kz: 'middle_east',
    lb: 'middle_east',
    lt: 'eastern_europe',
    lu: 'benelux',
    lv: 'eastern_europe',
    me: 'eastern_europe',
    mk: 'eastern_europe',
    mt: 'europe_other',
    mx: 'latam',
    my: 'sceh',
    nl: 'benelux',
    ni: 'latam',
    no: 'nordics',
    nz: 'anz',
    om: 'middle_east',
    pa: 'latam',
    pe: 'latam',
    pl: 'eastern_europe',
    pt: 'europe_other',
    qa: 'middle_east',
    ro: 'eastern_europe',
    rs: 'eastern_europe',
    ru: 'eastern_europe',
    sa: 'middle_east',
    se: 'nordics',
    sg: 'sceh',
    si: 'europe_other',
    sk: 'eastern_europe',
    th: 'sceh',
    tr: 'europe_other',
    tw: 'sceh',
    ua: 'eastern_europe',
    us: 'usca',
    uy: 'latam',
    vn: 'sceh',
    za: 'africa'
  };
  Object.freeze(AdobeConstants.COUNTRY_TERRITORY_ENUM);
  /**
   * Default Organization ID.
   *
   * "This value should be the same for everybody."
   * @see https://github.snei.sony.com/SIE/grand-central-telemetry/issues/163
   *
   * @type {string}
   */

  AdobeConstants.DEFAULT_ORGANIZATION_ID = 'BD260C0F53C9733E0A490D45@AdobeOrg';
  /**
   * Tracking Server HTTP.
   *
   * "This value should be the same for everybody."
   * @see https://github.snei.sony.com/SIE/grand-central-telemetry/issues/163
   *
   * @type {string}
   */

  AdobeConstants.DEFAULT_TRACKING_SERVER = 'metrics.aem.playstation.com';
  /**
   * Tracking Server HTTPS.
   *
   * "This value should be the same for everybody."
   * @see https://github.snei.sony.com/SIE/grand-central-telemetry/issues/163
   *
   * @type {string}
   */

  AdobeConstants.DEFAULT_TRACKING_SERVER_SECURE = 'smetrics.aem.playstation.com';
  /**
   * Default Marketing Cloud Server (HTTP).
   *
   * @type {string}
   */

  AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER = 'metrics.aem.playstation.com';
  /**
   * Default Marketing Cloud Server (HTTPS).
   * @type {string}
   */

  AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER_SECURE = 'smetrics.aem.playstation.com';
  /**
   * Default Audience Manager Server (HTTP).
   *
   * @type {string}
   */

  AdobeConstants.DEFAULT_AUDIENCE_MANAGER_SERVER = 'sne.demdex.net';
  /**
   * Default Audience Manager Server (HTTPS).
   * @type {string}
   */

  AdobeConstants.DEFAULT_AUDIENCE_MANAGER_SERVER_SECURE = 'sne.demdex.net';
  /**
   * Regex for character filtering (the comma is a reserver character)
   */

  AdobeConstants.INVALID_COMMA_REGEX = /,/g;
  Object.freeze(AdobeConstants);

  function _typeof$9(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }
  /** `Object#toString` result references. */

  var symbolTag$2 = '[object Symbol]';
  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */

  function isSymbol(value) {
    return _typeof$9(value) == 'symbol' || isObjectLike_1(value) && _baseGetTag(value) == symbolTag$2;
  }

  var isSymbol_1 = isSymbol;

  /** Used as references for various `Number` constants. */

  var NAN = 0 / 0;
  /** Used to match leading and trailing whitespace. */

  var reTrim = /^\s+|\s+$/g;
  /** Used to detect bad signed hexadecimal string values. */

  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  /** Used to detect binary string values. */

  var reIsBinary = /^0b[01]+$/i;
  /** Used to detect octal string values. */

  var reIsOctal = /^0o[0-7]+$/i;
  /** Built-in method references without a dependency on `root`. */

  var freeParseInt = parseInt;
  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */

  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }

    if (isSymbol_1(value)) {
      return NAN;
    }

    if (isObject_1(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject_1(other) ? other + '' : other;
    }

    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }

    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }

  var toNumber_1 = toNumber;

  /** Used as references for various `Number` constants. */

  var INFINITY = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;
  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */

  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }

    value = toNumber_1(value);

    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }

    return value === value ? value : 0;
  }

  var toFinite_1 = toFinite;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */

  function toInteger(value) {
    var result = toFinite_1(value),
        remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }

  var toInteger_1 = toInteger;

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */

  function baseValues(object, props) {
    return _arrayMap(props, function (key) {
      return object[key];
    });
  }

  var _baseValues = baseValues;

  /**
   * Creates an array of the own enumerable string keyed property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */

  function values(object) {
    return object == null ? [] : _baseValues(object, keys_1(object));
  }

  var values_1 = values;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMax$1 = Math.max;
  /**
   * Checks if `value` is in `collection`. If `collection` is a string, it's
   * checked for a substring of `value`, otherwise
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * is used for equality comparisons. If `fromIndex` is negative, it's used as
   * the offset from the end of `collection`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object|string} collection The collection to inspect.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
   * @returns {boolean} Returns `true` if `value` is found, else `false`.
   * @example
   *
   * _.includes([1, 2, 3], 1);
   * // => true
   *
   * _.includes([1, 2, 3], 1, 2);
   * // => false
   *
   * _.includes({ 'a': 1, 'b': 2 }, 1);
   * // => true
   *
   * _.includes('abcd', 'bc');
   * // => true
   */

  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike_1(collection) ? collection : values_1(collection);
    fromIndex = fromIndex && !guard ? toInteger_1(fromIndex) : 0;
    var length = collection.length;

    if (fromIndex < 0) {
      fromIndex = nativeMax$1(length + fromIndex, 0);
    }

    return isString_1(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && _baseIndexOf(collection, value, fromIndex) > -1;
  }

  var includes_1 = includes;

  var MAX_EVAR_BYTES = 255; // Per product name or category; no limit overall.

  var MAX_PRODUCT_VALUE_BYTES = 100; // x09 tab
  // x0A carriage return
  // x0D newline
  // x23 # hash
  // x26 & ampersand
  // x3C < less-than
  // x3E > greater-than

  var adobeProhibitedChars = ['&quot;', '&rsquo;', '\x09', '\x0A', '\x0D', '\x23', '\x26', '\x3C', '\x3E']; // x21 ! exclamation mark
  // x22 "" double quote (this is what &quot; points to)
  // x24 $ dollar sign
  // x25 % percent
  // x27 ' single quote
  // x2A * asterisk
  // x3B ; semicolon
  // x3F ? question mark
  // x5E ^ caret
  // x7E ~ tilde
  // xAE registered symbol
  // xA9 copyright symbol
  // u2122 â„¢ trademark symbol (&trade;)
  // u2019 â€™ right single quote (&rsquo;)

  var additionalInvalidChars = ['\x21', '\x22', '\x24', '\x25', '\x27', '\x2A', '\x3B', '\x3F', '\x5E', '\x7E', '\xAE', '\xA9', "\u2122", "\u2019"]; // x2D , comma
  // x3D = equals
  // u201C â€œ left double quote
  // u201D â€ right double quote
  // u2018 â€˜ left single quote
  // u00ab Â« left double-angle quotation mark
  // u00bb Â» right double-angle quotation mark
  // x5B [ left square bracket
  // x5D ] right square bracket
  // x7B { left curly bracket
  // x7D } right curly bracket
  // x28 ( left parenthesis
  // x29 ) right parenthesis
  // x60 ` backtick
  // x2B + plus sign
  // x2F / slash
  // x7C | pipe
  // x40 @ at sign
  // x5C \ backslash

  var productStringInvalidChars = [',', '=', "\u201C", "\u201D", "\u2018", "\xAB", "\xBB", '[', ']', '{', '}', '(', ')', '`', '+', '/', '|', '@', '\\'];

  var escapeRegexSpecialCharacters = function escapeRegexSpecialCharacters(value) {
    return value.replace(/([.*^$+?|()[\]{}\\])/g, '\\$1');
  };

  var matchAll = function matchAll(values) {
    return new RegExp("(".concat(values.map(escapeRegexSpecialCharacters).join('|'), ")"), 'g');
  };

  var matchWhitespace = new RegExp('\\s+', 'g');
  var matchProductStringInvalidChars = matchAll(adobeProhibitedChars.concat(additionalInvalidChars).concat(productStringInvalidChars));
  /**
   * Applies string cleanup, without lower-casing the value.
   *
   * @param {string} value
   * @return {string}
   *
   * @private
   */

  var cleanNoCasing = function cleanNoCasing(value) {
    return Utils$1.cleanUpString(value, null, false);
  };
  /**
   * Applies string cleanup
   *
   * @param {string} value
   * @return {string}
   *
   * @private
   */

  var clean = function clean(value) {
    return Utils$1.cleanUpString(value);
  };
  /**
   * Applies string cleanup, cast '' to undefined.
   *
   * This is a convenience function for simple eVars instead of always typing `|| undefined`
   * @param {string} value
   * @return {string|undefined}
   *
   * @private
   */

  var cleanOrUndefined = function cleanOrUndefined(value) {
    return clean(value) || undefined;
  };
  /**
   * Given a colon-delimited string, filter the individual items, remove empty components
   *
   * This is primarily used in location based items.
   *
   * @param {string} value
   * @return {string|undefined}
   * @private
   */

  var cleanColonDelimitedListStripEmpty = function cleanColonDelimitedListStripEmpty(value) {
    return String(value).split(':').map(clean).filter(function (v) {
      return v;
    }).join(':') || undefined;
  };
  /**
   * Given a colon-delimited string, filter the individual items, retaining empty slots
   *
   * @param {string} value
   * @param {?function(string):string} cleanFn Function to use for cleaning the
   *     individual items. Defaults to clean.
   * @return {string|undefined}
   * @private
   */

  var cleanColonDelimitedList = function cleanColonDelimitedList(value, cleanFn) {
    if (typeof value !== 'string') {
      return undefined;
    }

    var cleaner = cleanFn || clean;
    return String(value).split(':').map(cleaner).join(':') || undefined;
  };
  /**
   * Truncate a string to a maximum number of characters. Optionally, a list of
   * field delimiters can be passed in, which will further truncate the string
   * (if it required truncation) to the last instance of one of those characters.
   * This is useful for (e.g.) avoiding chopping a field in half.
   *
   * If limit is zero or less, the empty string will be returned. It's a little
   * weird not to throw an exception for a negative length, but this behavior is
   * consistent with the built-in string.substr() function.
   *
   * @param {string} value
   * @param {number} limit
   * @param {?Array.<string>} delimiters
   * @return {string}
   */

  var truncateUtf8ByteLength = function truncateUtf8ByteLength(value, limit, delimiters) {
    // Optimization: At most, a javascript code unit could require 4 bytes of UTF-8.
    if (value.length * 4 <= limit) {
      return value;
    }

    var truncated = truncateByteLength(value, limit);

    if (truncated === value || !delimiters || delimiters.length === 0) {
      return truncated;
    } // Find the last instance of any of the delimiter characters.


    var lastDelimiterIndex = delimiters.map(function (delimiter) {
      return truncated.lastIndexOf(delimiter);
    }).reduce(function (a, b) {
      return Math.max(a, b);
    }, 0);
    return truncated.substr(0, lastDelimiterIndex);
  };
  var strip = function strip(exclude) {
    var excludeRegExp = exclude instanceof RegExp ? exclude : matchAll(isArray$1(exclude) ? exclude : [exclude]);
    return function (value) {
      return value.replace(excludeRegExp, '');
    };
  };

  var lowercase = function lowercase(value) {
    return value.toLowerCase();
  };

  var identity$1 = function identity(v) {
    return v;
  };

  var compressWhitespace = function compressWhitespace(value) {
    return value.replace(matchWhitespace, ' ');
  };

  var cleanWhitespace = function cleanWhitespace(value) {
    return compressWhitespace(value).trim();
  };

  var cleanEvar = function cleanEvar(v) {
    var excludeChars = adobeProhibitedChars.concat(additionalInvalidChars);
    return strip(excludeChars)(v);
  };

  var cleanEvarAllowingCurrency = function cleanEvarAllowingCurrency(v) {
    var excludeChars = adobeProhibitedChars.concat(additionalInvalidChars).filter(function (c) {
      return c !== '$';
    });
    return strip(excludeChars)(v);
  };
  var cleanEvarAllowingUrlChars = function cleanEvarAllowingUrlChars(v) {
    var excludeChars = adobeProhibitedChars.concat(additionalInvalidChars).filter(function (c) {
      return !arrayIncludes(['?', '&'], c);
    });
    return strip(excludeChars)(v);
  };

  var asArray = function asArray(v) {
    return isArray$1(v) ? v : [v];
  };

  var asString = function asString(v) {
    return arrayIncludes([undefined, null, false], v) ? '' : String(v);
  };
  /**
   * TODO: Do not allow this to clean as well.
   * @param delimiter
   * @returns {function(*=)}
   */


  var legacyAsDelimitedString = function legacyAsDelimitedString(delimiter) {
    return function (value) {
      return asArray(value).map(asString).map(strip(delimiter)).map(cleanEvar).map(cleanWhitespace).join(delimiter);
    };
  };

  var asDelimitedString = function asDelimitedString(delimiter) {
    return function (value) {
      return asArray(value).map(asString) // Convert all values to string
      .map(strip(delimiter)) // Strip the delimited
      .map(cleanWhitespace) // Normalize subcomponent whitespace
      .join(delimiter);
    };
  }; // Join as string


  var asColonDelimitedString = legacyAsDelimitedString(':');
  var asCommaDelimitedString = asDelimitedString(',');
  var asHyphenDelimitedString = legacyAsDelimitedString('-');
  var asPipeDelimitedString = legacyAsDelimitedString('|');
  var asSemicolonDelimitedString = legacyAsDelimitedString(';');
  var asProductValue = function asProductValue(v) {
    return truncateUtf8ByteLength(cleanWhitespace(strip(matchProductStringInvalidChars)(v)), MAX_PRODUCT_VALUE_BYTES);
  };
  var asCurrency = function asCurrency(v) {
    return Number(v).toFixed(2);
  };
  /**
   * Given a string, process it into an acceptable shape for an Adobe eVar.
   *
   * @param {string} v
   * @param {object} [options]
   * @param {boolean} [options.allowUppercase] If true, don't enforce lowercasing.
   * @param {array.<string>} [options.delimiters] If present, and the value is
   *     longer than the limit, truncate to the last instance of a delimiter.
   * @return {string|undefined}
   */

  var asEvar = function asEvar(v, options) {
    if (arrayIncludes([undefined, null, false], v)) {
      return undefined;
    }

    if (typeof v === 'number') {
      return v;
    }

    var _ref = options || {},
        allowUppercase = _ref.allowUppercase,
        cleaner = _ref.cleaner,
        delimiters = _ref.delimiters;

    var casing = allowUppercase ? identity$1 : lowercase;
    var cleanFn = cleaner || cleanEvar;
    return truncateUtf8ByteLength(casing(cleanWhitespace(cleanFn(v))), MAX_EVAR_BYTES, delimiters) || undefined;
  };
  /**
   * Given a string, process it into an acceptable shape for an Adobe list variable.
   * Unlike asEvar, this function does not accept any options, but those could be added if necessary.
   *
   * @param {string} v
   * @return {string|undefined}
   */

  var asAdobeList = function asAdobeList(v) {
    if (arrayIncludes([undefined, null, false], v)) {
      return undefined;
    }

    if (typeof v === 'number') {
      return v;
    }

    return lowercase(cleanWhitespace(cleanEvar(v))) || undefined;
  };

  var validString = function validString(value) {
    return value && isString_1(value) && !isEmptyOrSpaces(value);
  };
  /**
   *
   * @param {string} psnAccountRegion
   * @returns {string}
   */


  var getTerritory = function getTerritory(psnAccountRegion) {
    if (!psnAccountRegion) {
      return 'empty';
    }

    var lowerCaseRegion = psnAccountRegion.toLowerCase();
    var resolvedTerritory = AdobeConstants.COUNTRY_TERRITORY_ENUM[lowerCaseRegion];
    return resolvedTerritory || 'other';
  };

  var getBaseLanguage = function getBaseLanguage(psnAccountLanguage) {
    if (!psnAccountLanguage) {
      return 'empty';
    } // Legacy Behaviour is to only pass in the base language code, no discernment between zh-CN (zh-Hant) and zh-TW (zh-Hans)
    // TODO: Find out how to report these if more resolution is required.


    var parts = parseLanguageTag$1(psnAccountLanguage);

    if (!parts.languageId) {
      return 'empty';
    } // Legacy Behaviour forced this value to lowercase


    return parts.languageId.toLowerCase();
  };
  /**
   *
   * @param {string} psnAccountRegion
   * @returns {string}
   */


  var getCountry = function getCountry(psnAccountRegion) {
    if (!psnAccountRegion) {
      return 'empty';
    }

    return psnAccountRegion.toLowerCase();
  };

  var _localeInformation = function _localeInformation(psnAccountLanguage, psnAccountRegion) {
    var language = getBaseLanguage(psnAccountLanguage);
    var country = getCountry(psnAccountRegion);
    var territory = getTerritory(psnAccountRegion);
    return [territory, country, language].join('-');
  };

  var trimmedStringOrEmpty = function trimmedStringOrEmpty(value) {
    if (!validString(value)) {
      return 'empty';
    }

    return value.trim();
  };

  var evar2LocaleInformation = (function (_ref) {
    var environment = _ref.environment;
    // if environment is null or undefined we'll fill it with empty object.
    var env = environment || {};

    var localeInfo = _localeInformation(env.psnAccountLanguage, env.psnAccountRegion);

    var postalCode = trimmedStringOrEmpty(env.postalCode);
    var DMA = trimmedStringOrEmpty(env.DMA);
    return asEvar(asColonDelimitedString([localeInfo, postalCode, DMA]), {
      allowUppercase: true
    });
  });

  /**
   * Generate post anything metadata from tiles
   *
   * @param {Object} tile
   * @returns {?string}
   */
  var postAnything = function postAnything(tile) {
    var arr = [];

    if (tile.postAnythingHasText) {
      arr.push('txt');
    }

    if (tile.postAnythingHasImage) {
      arr.push('img');
    }

    if (tile.postAnythingHasUrl) {
      arr.push('url');
    }

    if (tile.postAnythingHasGameTag) {
      arr.push('gam');
    }

    if (tile.postAnythingHasFriendTag) {
      arr.push('frn');
    }

    if (arr.length !== 0) {
      return arr.join('|');
    }

    return 'no post contents';
  };

  /**
   * Generate bucket for impression data in list3
   *
   * @param {?int}
   * @returns {?string}
   */
  var impressionTime = function impressionTime(time) {
    // build dwell time buckets based on GCT calculated dwell time
    var impressionTimeBucket = 'no impression';

    if (time > 60000) {
      impressionTimeBucket = '60s+';
    } else if (time >= 30000) {
      impressionTimeBucket = '30-59s';
    } else if (time >= 10000) {
      impressionTimeBucket = '10-29s';
    } else if (time >= 5000) {
      impressionTimeBucket = '5-9.9s';
    } else if (time >= 2000) {
      impressionTimeBucket = '2-4.9s';
    } else if (time >= 500) {
      impressionTimeBucket = '0.5-1.9s';
    }

    return impressionTimeBucket;
  };

  /**
   * eVar5 and eVar6 don't map to prop https://jira.sie.sony.com/browse/HATRK-2524
   *
   * p1 = A/B Test                  / v1 = Page Name
   * p5 = Filter values from string / v5 = Age
   * p6 = Sort values from string   / v6 = Gender
   * p33 = Deprecated               / v33 = Recommendation Campaign Id
   * p39 = Deprecated               / v39 = Load Time (ms)
   * p58 = A/B PDP                  / v58 = PS Now Subscription
   * p60 = PS4 Nav Scene Action     / v60 = EA Access Member Status
   * p68 = Page URL                 / v68 = Page URL
   * @since 0.6.26 evar39 doesn't map to prop https://jira.sie.sony.com/browse/GHOST-305
   * TODO: Why is 68 in this list? I think this may be "69"
   */

  var NONMAPPED_EVARS = [1, 5, 6, 33, 39, 58, 60, 68];
  /**
   * Maps eVars to props on the Adobe Payload given as argument
   *
   * eVars in NONMAPPED_EVARS are not mapped. eVars above 75 are not mapped.
   * eVars are copied on prop using following format: eVar42 => prop42 = 'D=v42'
   *
   * @param      {object}  payload  [MODIFIED] The payload with variables
   */

  var populateProps = function populateProps(payload) {
    Object.keys(payload).forEach(function (key) {
      if (key.substr(0, 4) === 'eVar') {
        var num = parseInt(key.substr(4), 10);

        if (num < 76 && !includes_1(NONMAPPED_EVARS, num) && !payload["prop".concat(num)]) {
          // eslint-disable-next-line no-param-reassign
          payload["prop".concat(num)] = "D=v".concat(num);
        }
      }
    });
  };
  /**
   * Generate proper linkType for Adobe based on an event object
   *
   * @param      {object}  event   The GCT event as dispatched
   * @return     {string}  The link type.
   */


  var getLinkType = function getLinkType(event) {
    if (event.downloadClick) {
      return 'd';
    }

    if (event.exitClick) {
      return 'e';
    }

    return 'o';
  };
  /**
   * Generate a single banner string for `list1` attribute which one banner
   *
   * @private
   *
   * @param      {string}    bannerId A single banner ID
   * @return     {string}    single banner ID for list1 is returned as a string formatted per Adobe spec
   */


  var getBannerInfo = function getBannerInfo(bannerId) {
    return Utils$1.cleanUpString(bannerId);
  };
  /**
   * Generate a string for `list1` attribute which represent banners
   *
   * @param      {object}    event The event object which contains an array of banner IDs
   * @return     {?string}   list1 is returned as a string formatted per Adobe spec, null if no .banners
   */


  var getBannersInfo = function getBannersInfo(event) {
    if (!event.banners || !event.banners.length) {
      return null;
    }

    return event.banners.map(function (bannerId) {
      return getBannerInfo(bannerId);
    }).join(',');
  };
  /**
   * List of tile types for which tile id property should be added to the list3 attribute string
   * I tile type is not specified in this array 'no tile id' should be used.
   */


  var TILE_TYPES_WITH_TILE_ID = ['store promo story tile', 'publisher promo story tile', 'screenshot upload verified story tile', 'video upload verified story tile'];
  /**
   * Returns the tile id to be used in the `list3` attribute. 'tile id' will only be returned for
   * tile types defined in TILE_TYPES_WITH_TILE_ID.
   *
   * @param       {string} tileType Type specified in the object representing the tile
   * @param       {string} tileId Id specified in the object representing the tile
   * @return      {string} returns the tile id to be used or 'no tile id' if no id specified
   */

  var _getTileId = function _getTileId(tileType, tileId) {
    var type = tileType && tileType.toLowerCase();
    return type && includes_1(TILE_TYPES_WITH_TILE_ID, type) && tileId || 'no tile id';
  };
  /**
   * Generate a single item for `list3` attribute which represent a single tile,
   * the string is truncated if > 255b
   * -> if so, truncate tileCaption to 30b; if still > 255b
   * -> if so, truncate tileTitle to 30b; if still > 255b
   * -> if so, truncate campaignID to 30b; if still > 255b
   * -> if so, truncate productTitle to 30b; At this point, it is certain list3 will meet the size limit
   *
   * @private
   *
   * @param      {object}    tile The tile object which represents a single tile
   * @return     {string}    list3 is returned as a string formatted per Adobe spec
   */
  // eslint-disable-next-line arrow-body-style


  var getTileInfo = function getTileInfo() {
    var tile = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var clean = function clean(str, other) {
      return Utils$1.cleanUpString(str, other);
    };

    var generateCleanStringAndSizeObject = function generateCleanStringAndSizeObject(val, other, limit) {
      var cleanStr = limit === undefined ? clean(val, other) : clean(val, other).substr(0, limit);
      return {
        cleanString: cleanStr,
        size: stringInBytes(cleanStr)
      };
    };

    var buildString = function buildString(arr) {
      return arr.map(function (o) {
        return o.cleanString;
      }).join(':');
    }; // build tilePositionBucket based on tilePosition


    var tilePositionBucket;

    if (tile.tilePosition === 0) {
      tilePositionBucket = 'zero';
    } else if (tile.tilePosition >= 53) {
      tilePositionBucket = '53+';
    } else if (tile.tilePosition >= 33) {
      tilePositionBucket = '33-52';
    } else if (tile.tilePosition >= 23) {
      tilePositionBucket = '23-32';
    } else if (tile.tilePosition >= 18) {
      tilePositionBucket = '18-22';
    } else if (tile.tilePosition >= 13) {
      tilePositionBucket = '13-17';
    } else {
      tilePositionBucket = tile.tilePosition;
    }

    var sanitizedTileType = generateCleanStringAndSizeObject(tile.tileType, AdobeConstants.INVALID_COMMA_REGEX); // note that the size of the string in this array is different than the byte array we use later to truncate in later stage.

    var objectsArray = [sanitizedTileType, generateCleanStringAndSizeObject(tile.productTitle || 'no product', AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(tile.ctaType || 'no cta', AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(tilePositionBucket, AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(impressionTime(tile.impressionTime), AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(_getTileId(sanitizedTileType.cleanString, tile.tileId || tile.tileTrackingId), AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(tile.campaignId || 'no campaign', AdobeConstants.INVALID_COMMA_REGEX, 100), generateCleanStringAndSizeObject(tile.tileAuthor || 'no author', AdobeConstants.INVALID_COMMA_REGEX), generateCleanStringAndSizeObject(tile.tileTitle || 'no title', AdobeConstants.INVALID_COMMA_REGEX, 50), generateCleanStringAndSizeObject(tile.tileCaption || 'no caption', AdobeConstants.INVALID_COMMA_REGEX, 20), generateCleanStringAndSizeObject(postAnything(tile), AdobeConstants.INVALID_COMMA_REGEX)];

    var totalByte = function totalByte(obj) {
      return obj.map(function (o) {
        return o.size;
      }).reduce(function (r, n) {
        return r + n;
      }, 0) + (obj.length - 1);
    }; // the sequence of positions in objectsArray that we invoke in sequence to make sure the object is of the right size.


    var productTitleIndex = 1;
    var campaignIdIndex = 6;
    var captionIndex = 9;
    var titleIndex = 8;
    var variableTruncateSize = 30;
    var overallListThresholdSize = 255;
    [captionIndex, titleIndex, campaignIdIndex, productTitleIndex].forEach(function (position) {
      if (totalByte(objectsArray) > overallListThresholdSize) {
        if (objectsArray[position].size > variableTruncateSize) {
          objectsArray[position] = generateCleanStringAndSizeObject(truncateByteLength(objectsArray[position].cleanString, variableTruncateSize));
        }
      }
    });
    return buildString(objectsArray);
  };
  /**
   * Generate a string for `list3` attribute which represent tiles
   *
   * @param      {object}    event   The event object which contains an array of tiles
   * @return     {?string}    list3 is returned as a string formatted per Adobe spec
   */


  var getTilesInfo = function getTilesInfo(event) {
    if (!event.tiles || !event.tiles.length) {
      return null;
    }

    return event.tiles.map(function (tile) {
      return getTileInfo(tile);
    }).join(',');
  };
  /**
   * Generate a single item for `list2` attribute which represent a single recommendation
   *
   * @private
   *
   * @param      {object}    [recommendation={}] The recommendation object which represents a single recommendation
   * @return     {string}    list2 is returned as a string formatted per Adobe spec
   */
  // eslint-disable-next-line arrow-body-style


  var getRecommendationInfo = function getRecommendationInfo() {
    var recommendation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return [Utils$1.cleanUpString(recommendation.name, AdobeConstants.INVALID_COMMA_REGEX), Utils$1.cleanUpString(recommendation.sku || 'no product sku', AdobeConstants.INVALID_COMMA_REGEX)].join(':');
  };
  /**
   * Generate a string for `list2` attribute which represent recommendations
   *
   * @param      {object}    event   The event object which contains an array of recommendations
   * @return     {?string}   list2 is returned as a string formatted per Adobe spec, null if no .recommendations
   */


  var getRecommendationsInfo = function getRecommendationsInfo(event) {
    if (!event.recommendations || !event.recommendations.length) {
      return null;
    }

    return event.recommendations.map(function (rec) {
      return getRecommendationInfo(rec);
    }).join(',');
  };

  var _staticDeprecationManager = new StaticDeprecationManager();

  var getLocaleInfo = function getLocaleInfo(env) {
    var deprecation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _staticDeprecationManager;
    deprecation.trigger(new Deprecation({
      date: '2019-03-12',
      name: 'adobeUtils.getLocaleInfo',
      description: 'If anyone is using this, let GHOST know.',
      overrideKey: 'allowAdobeUtilsGetLocaleInfo'
    }));
    var contextEnv = env || {};

    if (contextEnv.locale && (!contextEnv.psnAccountLanguage || !contextEnv.psnAccountRegion)) {
      var parts = env.locale.split('_');
      contextEnv = cloneDeep_1(env); // eslint-disable-next-line prefer-destructuring

      contextEnv.psnAccountLanguage = parts[0]; // eslint-disable-next-line prefer-destructuring

      contextEnv.psnAccountRegion = parts[1];
    }

    return evar2LocaleInformation({
      environment: contextEnv
    });
  };

  var AdobeUtils = {
    populateProps: populateProps,
    getLinkType: getLinkType,
    getBannerInfo: getBannerInfo,
    getBannersInfo: getBannersInfo,
    getTileInfo: getTileInfo,
    getTilesInfo: getTilesInfo,
    getLocaleInfo: getLocaleInfo,
    getRecommendationInfo: getRecommendationInfo,
    getRecommendationsInfo: getRecommendationsInfo
  };

  var GctVersion = '4.15.0';

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }

    return false;
  }

  var _arraySome = arraySome;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;
  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */

  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    } // Assume cyclic values are equal.


    var stacked = stack.get(array);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var index = -1,
        result = true,
        seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array); // Ignore non-index properties.

    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }

      if (compared !== undefined) {
        if (compared) {
          continue;
        }

        result = false;
        break;
      } // Recursively compare arrays (susceptible to call stack limits).


      if (seen) {
        if (!_arraySome(other, function (othValue, othIndex) {
          if (!_cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }

    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  var _equalArrays = equalArrays;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;
  /** `Object#toString` result references. */

  var boolTag$3 = '[object Boolean]',
      dateTag$3 = '[object Date]',
      errorTag$2 = '[object Error]',
      mapTag$5 = '[object Map]',
      numberTag$3 = '[object Number]',
      regexpTag$3 = '[object RegExp]',
      setTag$5 = '[object Set]',
      stringTag$4 = '[object String]',
      symbolTag$3 = '[object Symbol]';
  var arrayBufferTag$3 = '[object ArrayBuffer]',
      dataViewTag$4 = '[object DataView]';
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
      symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;
  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$4:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }

        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$3:
        if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
          return false;
        }

        return true;

      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq_1(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$3:
      case stringTag$4:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';

      case mapTag$5:
        var convert = _mapToArray;

      case setTag$5:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
        convert || (convert = _setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        } // Assume cyclic values are equal.


        var stacked = stack.get(object);

        if (stacked) {
          return stacked == other;
        }

        bitmask |= COMPARE_UNORDERED_FLAG$1; // Recursively compare objects (susceptible to call stack limits).

        stack.set(object, other);
        var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag$3:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }

    }

    return false;
  }

  var _equalByTag = equalByTag;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$2 = 1;
  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$b = objectProto$d.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
        objProps = _getAllKeys(object),
        objLength = objProps.length,
        othProps = _getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }

    var index = objLength;

    while (index--) {
      var key = objProps[index];

      if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
        return false;
      }
    } // Assume cyclic values are equal.


    var stacked = stack.get(object);

    if (stacked && stack.get(other)) {
      return stacked == other;
    }

    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;

    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      } // Recursively compare objects (susceptible to call stack limits).


      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }

      skipCtor || (skipCtor = key == 'constructor');
    }

    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }

    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  var _equalObjects = equalObjects;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$3 = 1;
  /** `Object#toString` result references. */

  var argsTag$3 = '[object Arguments]',
      arrayTag$2 = '[object Array]',
      objectTag$3 = '[object Object]';
  /** Used for built-in method references. */

  var objectProto$e = Object.prototype;
  /** Used to check objects for own properties. */

  var hasOwnProperty$c = objectProto$e.hasOwnProperty;
  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */

  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_1(object),
        othIsArr = isArray_1(other),
        objTag = objIsArr ? arrayTag$2 : _getTag(object),
        othTag = othIsArr ? arrayTag$2 : _getTag(other);
    objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
    othTag = othTag == argsTag$3 ? objectTag$3 : othTag;
    var objIsObj = objTag == objectTag$3,
        othIsObj = othTag == objectTag$3,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer_1(object)) {
      if (!isBuffer_1(other)) {
        return false;
      }

      objIsArr = true;
      objIsObj = false;
    }

    if (isSameTag && !objIsObj) {
      stack || (stack = new _Stack());
      return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }

    if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
      var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new _Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }

    if (!isSameTag) {
      return false;
    }

    stack || (stack = new _Stack());
    return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */

  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
      return value !== value && other !== other;
    }

    return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  var _baseIsEqual = baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;
  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */

  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }

    object = Object(object);

    while (index--) {
      var data = matchData[index];

      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }

    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new _Stack();

        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }

        if (!(result === undefined ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
          return false;
        }
      }
    }

    return true;
  }

  var _baseIsMatch = baseIsMatch;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */

  function isStrictComparable(value) {
    return value === value && !isObject_1(value);
  }

  var _isStrictComparable = isStrictComparable;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */

  function getMatchData(object) {
    var result = keys_1(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];
      result[length] = [key, value, _isStrictComparable(value)];
    }

    return result;
  }

  var _getMatchData = getMatchData;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }

      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }

  var _matchesStrictComparable = matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatches(source) {
    var matchData = _getMatchData(source);

    if (matchData.length == 1 && matchData[0][2]) {
      return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }

    return function (object) {
      return object === source || _baseIsMatch(object, source, matchData);
    };
  }

  var _baseMatches = baseMatches;

  function _typeof$a(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }
  /** Used to match property names within property paths. */

  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;
  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */

  function isKey(value, object) {
    if (isArray_1(value)) {
      return false;
    }

    var type = _typeof$a(value);

    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol_1(value)) {
      return true;
    }

    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }

  var _isKey = isKey;

  /** Error message constants. */

  var FUNC_ERROR_TEXT = 'Expected a function';
  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */

  function memoize(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }

    var memoized = function memoized() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }

      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };

    memoized.cache = new (memoize.Cache || _MapCache)();
    return memoized;
  } // Expose `MapCache`.


  memoize.Cache = _MapCache;
  var memoize_1 = memoize;

  /** Used as the maximum memoize cache size. */

  var MAX_MEMOIZE_SIZE = 500;
  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */

  function memoizeCapped(func) {
    var result = memoize_1(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }

      return key;
    });
    var cache = result.cache;
    return result;
  }

  var _memoizeCapped = memoizeCapped;

  /** Used to match property names within property paths. */

  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  /** Used to match backslashes in property paths. */

  var reEscapeChar = /\\(\\)?/g;
  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */

  var stringToPath = _memoizeCapped(function (string) {
    var result = [];

    if (string.charCodeAt(0) === 46
    /* . */
    ) {
        result.push('');
      }

    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  var _stringToPath = stringToPath;

  /** Used as references for various `Number` constants. */

  var INFINITY$1 = 1 / 0;
  /** Used to convert symbols to primitives and strings. */

  var symbolProto$2 = _Symbol ? _Symbol.prototype : undefined,
      symbolToString = symbolProto$2 ? symbolProto$2.toString : undefined;
  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */

  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }

    if (isArray_1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return _arrayMap(value, baseToString) + '';
    }

    if (isSymbol_1(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }

  var _baseToString = baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */

  function toString(value) {
    return value == null ? '' : _baseToString(value);
  }

  var toString_1 = toString;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */

  function castPath(value, object) {
    if (isArray_1(value)) {
      return value;
    }

    return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
  }

  var _castPath = castPath;

  /** Used as references for various `Number` constants. */

  var INFINITY$2 = 1 / 0;
  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */

  function toKey(value) {
    if (typeof value == 'string' || isSymbol_1(value)) {
      return value;
    }

    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }

  var _toKey = toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */

  function baseGet(object, path) {
    path = _castPath(path, object);
    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[_toKey(path[index++])];
    }

    return index && index == length ? object : undefined;
  }

  var _baseGet = baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */

  function get(object, path, defaultValue) {
    var result = object == null ? undefined : _baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  var get_1 = get;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  var _baseHasIn = baseHasIn;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */

  function hasPath(object, path, hasFunc) {
    path = _castPath(path, object);
    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = _toKey(path[index]);

      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }

      object = object[key];
    }

    if (result || ++index != length) {
      return result;
    }

    length = object == null ? 0 : object.length;
    return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
  }

  var _hasPath = hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */

  function hasIn(object, path) {
    return object != null && _hasPath(object, path, _baseHasIn);
  }

  var hasIn_1 = hasIn;

  /** Used to compose bitmasks for value comparisons. */

  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;
  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */

  function baseMatchesProperty(path, srcValue) {
    if (_isKey(path) && _isStrictComparable(srcValue)) {
      return _matchesStrictComparable(_toKey(path), srcValue);
    }

    return function (object) {
      var objValue = get_1(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
    };
  }

  var _baseMatchesProperty = baseMatchesProperty;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }

  var _baseProperty = baseProperty;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */

  function basePropertyDeep(path) {
    return function (object) {
      return _baseGet(object, path);
    };
  }

  var _basePropertyDeep = basePropertyDeep;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */

  function property(path) {
    return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
  }

  var property_1 = property;

  function _typeof$b(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }
  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */

  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }

    if (value == null) {
      return identity_1;
    }

    if (_typeof$b(value) == 'object') {
      return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
    }

    return property_1(value);
  }

  var _baseIteratee = baseIteratee;

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */

  function createBaseEach(eachFunc, fromRight) {
    return function (collection, iteratee) {
      if (collection == null) {
        return collection;
      }

      if (!isArrayLike_1(collection)) {
        return eachFunc(collection, iteratee);
      }

      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while (fromRight ? index-- : ++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }

      return collection;
    };
  }

  var _createBaseEach = createBaseEach;

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */

  var baseEach = _createBaseEach(_baseForOwn);
  var _baseEach = baseEach;

  /**
   * The base implementation of `_.some` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  function baseSome(collection, predicate) {
    var result;
    _baseEach(collection, function (value, index, collection) {
      result = predicate(value, index, collection);
      return !result;
    });
    return !!result;
  }

  var _baseSome = baseSome;

  function _typeof$c(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }
  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */

  function isIterateeCall(value, index, object) {
    if (!isObject_1(object)) {
      return false;
    }

    var type = _typeof$c(index);

    if (type == 'number' ? isArrayLike_1(object) && _isIndex(index, object.length) : type == 'string' && index in object) {
      return eq_1(object[index], value);
    }

    return false;
  }

  var _isIterateeCall = isIterateeCall;

  /**
   * Checks if `predicate` returns truthy for **any** element of `collection`.
   * Iteration is stopped once `predicate` returns truthy. The predicate is
   * invoked with three arguments: (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false], Boolean);
   * // => true
   *
   * var users = [
   *   { 'user': 'barney', 'active': true },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // The `_.matches` iteratee shorthand.
   * _.some(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.some(users, ['active', false]);
   * // => true
   *
   * // The `_.property` iteratee shorthand.
   * _.some(users, 'active');
   * // => true
   */

  function some(collection, predicate, guard) {
    var func = isArray_1(collection) ? _arraySome : _baseSome;

    if (guard && _isIterateeCall(collection, predicate, guard)) {
      predicate = undefined;
    }

    return func(collection, _baseIteratee(predicate, 3));
  }

  var some_1 = some;

  /**
   * Types that do not require a Quantity, Price, or Revenue
   * @type {string[]}
   */

  var quantityPriceRevenueOptional = [TRANSACTION_TYPES$1.RECOMMENDATION, TRANSACTION_TYPES$1.VIEW_PRODUCT];
  /**
   * Types that do not require a check for valid Name and Sku.
   * @type {string[]}
   */

  var nameSkuCheckNotRequiredTypes = [TRANSACTION_TYPES$1.VOUCHER_CASH, TRANSACTION_TYPES$1.FUNDING_3DS, TRANSACTION_TYPES$1.FUNDING];
  /**
   * Is a check on name and sku required
   * @param transactionType
   */

  var isNameSkuCheckRequired = function isNameSkuCheckRequired(transactionType) {
    return !arrayIncludes(nameSkuCheckNotRequiredTypes, transactionType);
  };
  /**
   * Are QPR values required for the given transaction type.
   * @param transactionType
   */


  var isQuantityPriceRevenueRequired = function isQuantityPriceRevenueRequired(transactionType) {
    return !arrayIncludes(quantityPriceRevenueOptional, transactionType);
  };
  /**
   * Is valid quantity value
   * @param quantity
   */
  // eslint-disable-next-line no-restricted-globals


  var isValidQuantity = function isValidQuantity(quantity) {
    return !isNaN(quantity) && quantity >= 1;
  };
  /**
   * Is a float or string-float
   * @param value
   */
  // eslint-disable-next-line no-restricted-globals


  var isFloat$1 = function isFloat(value) {
    return !isNaN(parseFloat(value));
  };
  /**
   * Is the products definition valid
   * @param products
   * @param {string} transactionType
   * @param {adobe~BuildPayloadContext} context
   * @returns {boolean}
   */


  var isValidTransactionProducts = function isValidTransactionProducts(products, transactionType, _ref) {
    var logger = _ref.logger;

    // Type MISC does not set products value
    if (!products || !products.length) {
      return true;
    } // No Products set on MISC type


    if (transactionType === TRANSACTION_TYPES$1.MISC) {
      return true;
    }

    var productCount = products.length;
    var product;

    for (var i = 1; i <= productCount; i += 1) {
      product = products[i - 1];

      if (isQuantityPriceRevenueRequired(transactionType)) {
        if (!isValidQuantity(product.quantity)) {
          logger.warning("Invalid quantity for product ".concat(i));
          return false;
        }

        if (!isFloat$1(product.totalPrice)) {
          logger.warning("Invalid totalPrice for product ".concat(i));
          return false;
        }

        if (!isFloat$1(product.totalRevenue)) {
          logger.warning("Invalid totalRevenue for product ".concat(i));
          return false;
        }
      }

      if (isNameSkuCheckRequired(transactionType)) {
        if (!isString$4(product.name) || !product.name) {
          logger.warning("Invalid name string for product ".concat(i));
          return false;
        }

        if (!isString$4(product.sku) || !product.sku) {
          logger.warning("Invalid sku string for product ".concat(i));
          return false;
        }
      }
    }

    return true;
  };
  /**
   * Is the transaction valid
   * The result of this computation is stored in the context data
   *
   * @returns {boolean}
   */


  var isValidTransaction = function isValidTransaction(context) {
    var event = context.event,
        data = context.data;

    if (data.isValidTransaction !== undefined) {
      return data.isValidTransaction;
    }

    data.isValidTransaction = false;
    var transaction = event.transaction; // Require a transaction

    if (!transaction) {
      return false;
    } // Require valid transaction type


    if (!isValidTransactionType(transaction.type)) {
      return false;
    } // If a payment method is provided, it must be valid


    if (transaction.paymentMethod && !isValidPaymentMethod(transaction.paymentMethod)) {
      return false;
    } // Are all products valid


    if (!isValidTransactionProducts(transaction.products, transaction.type, context)) {
      return false;
    }

    data.isValidTransaction = true;
    return true;
  };

  /**
   * event111 - Tile Impression
   * see: list3
   *
   * @param {adobe~BuildPayloadContext} context
   */

  var event111 = function event111(_ref) {
    var event = _ref.event,
        data = _ref.data;

    // PageView and Imp set event; VideoStream does not.
    if (event.type === 'PageView' || event.type === 'Impression') {
      data.pushEvent(111);
    }
  };
  /**
   * Generate Tile Data from event.tiles
   *
   * @param {Object} event
   * @returns {?string}
   */


  var list3FromTiles = function list3FromTiles(event) {
    if (!event.tiles) {
      return undefined;
    }

    return AdobeUtils.getTilesInfo(event);
  };
  /**
   * Generate Tile Data from event.tile
   *
   * @param {Object} event
   * @returns {Object}
   */


  var list3FromTile = function list3FromTile(event) {
    if (!event.tile) {
      return undefined;
    }

    return AdobeUtils.getTileInfo(event.tile);
  };
  /**
   * s.list3 - Tiles Report
   * Tile ID and metadata for impression and click-through
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var list3 = function list3(context) {
    var event = context.event;
    var result = list3FromTiles(event) || list3FromTile(event);

    if (!result) {
      return undefined;
    }

    event111(context);
    return asAdobeList(result);
  };

  var _trackQuantityRevenue, _unitEventsMap, _priceEventsMap, _revenueEventsMap, _discountEventsMap, _orderLevelDiscountEv, _walletRevenueEventsM, _pmRevenueEventsMap;

  function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /**
   * Returns the payment method based on transactionType/paymentMethod
   *
   * @param {string} transactionType
   * @param {string} paymentMethod
   * @returns {*}
   */

  var productPaymentMethod = function productPaymentMethod(transactionType, paymentMethod) {
    switch (transactionType) {
      case TRANSACTION_TYPES$1.VOUCHER_PRODUCT:
      case TRANSACTION_TYPES$1.VOUCHER_CASH:
        return 'voucher';

      case TRANSACTION_TYPES$1.FUNDING:
      case TRANSACTION_TYPES$1.FUNDING_3DS:
      case TRANSACTION_TYPES$1.PURCHASE:
      case TRANSACTION_TYPES$1.PURCHASE_3DS:
      case TRANSACTION_TYPES$1.BUY_NOW:
      case TRANSACTION_TYPES$1.BUY_NOW_3DS:
      case TRANSACTION_TYPES$1.PREORDER_PAY_NOW:
      case TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS:
        return paymentMethod;

      default:
        return '';
    }
  };
  /**
   * Generate the Product Name based
   * @param transactionType
   * @param paymentMethod
   * @param product
   * @returns {string}
   */


  var productName = function productName(transactionType, paymentMethod, product) {
    switch (transactionType) {
      case TRANSACTION_TYPES$1.VOUCHER_CASH:
        return "funding:voucher:".concat(product.totalPrice.toFixed(2));

      case TRANSACTION_TYPES$1.FUNDING:
      case TRANSACTION_TYPES$1.FUNDING_3DS:
        {
          var _paymentMethod = productPaymentMethod(transactionType, paymentMethod);

          return "funding:".concat(_paymentMethod, ":").concat(product.totalPrice.toFixed(2));
        }

      default:
        return "".concat(clean(product.name), ":").concat(clean(product.sku));
    }
  };

  var trackQuantityRevenue = (_trackQuantityRevenue = {}, _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PURCHASE, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PURCHASE_3DS, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.BUY_NOW, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.BUY_NOW_3DS, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PREORDER_PAY_NOW, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.VOUCHER_CASH, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.VOUCHER_PRODUCT, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.FUNDING, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.FUNDING_3DS, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PROCESSING_PAYMENT, true), _defineProperty$7(_trackQuantityRevenue, TRANSACTION_TYPES$1.PURCHASE_DETAILS, true), _trackQuantityRevenue);
  /**
   * Returns the quantity of the product, if the transaction type is appropriate.
   * @param transactionType
   * @param product
   * @returns {string}
   */

  var productQuantity = function productQuantity(transactionType, product) {
    return trackQuantityRevenue[transactionType] ? product.quantity : '';
  };
  /**
  * Returns the revenue of the product, if the transaction type is appropriate.
  * @param transactionType
  * @param product
  * @returns {string} total revenue, with exactly 2 decimal places of precision.
  */


  var productRevenue = function productRevenue(transactionType, product) {
    return trackQuantityRevenue[transactionType] ? product.totalRevenue.toFixed(2) : '';
  };
  /**
   * event26 - Cart Units Added
   * event28 - Cart Units Removed
   * @type {{}}
   */


  var unitEventsMap = (_unitEventsMap = {}, _defineProperty$7(_unitEventsMap, TRANSACTION_TYPES$1.ADD_TO_CART, [26]), _defineProperty$7(_unitEventsMap, TRANSACTION_TYPES$1.REMOVE_FROM_CART, [28]), _defineProperty$7(_unitEventsMap, TRANSACTION_TYPES$1.PROCESSING_PAYMENT, [325]), _defineProperty$7(_unitEventsMap, TRANSACTION_TYPES$1.PURCHASE_DETAILS, [323]), _defineProperty$7(_unitEventsMap, TRANSACTION_TYPES$1.CONFIRM_PURCHASE_FPI, [314]), _unitEventsMap);
  /**
   * event9 - Voucher Redemption value
   * event11 - Add Funds Value
   * @type {{}}
   */

  var priceEventsMap = (_priceEventsMap = {}, _defineProperty$7(_priceEventsMap, TRANSACTION_TYPES$1.VOUCHER_CASH, [9, 11]), _defineProperty$7(_priceEventsMap, TRANSACTION_TYPES$1.VOUCHER_PRODUCT, [9]), _defineProperty$7(_priceEventsMap, TRANSACTION_TYPES$1.FUNDING_3DS, [11]), _defineProperty$7(_priceEventsMap, TRANSACTION_TYPES$1.FUNDING, [11]), _priceEventsMap);
  /**
   * event27 - Cart Revenue Added
   * event29 - Cart Revenue Removed
   * @type {{}}
   */

  var revenueEventsMap = (_revenueEventsMap = {}, _defineProperty$7(_revenueEventsMap, TRANSACTION_TYPES$1.REMOVE_FROM_CART, [29]), _defineProperty$7(_revenueEventsMap, TRANSACTION_TYPES$1.ADD_TO_CART, [27]), _defineProperty$7(_revenueEventsMap, TRANSACTION_TYPES$1.PROCESSING_PAYMENT, [326]), _defineProperty$7(_revenueEventsMap, TRANSACTION_TYPES$1.PURCHASE_DETAILS, [324]), _defineProperty$7(_revenueEventsMap, TRANSACTION_TYPES$1.CONFIRM_PURCHASE_FPI, [315]), _revenueEventsMap);
  /**
   * event36 - Product Level Discount
   * @type {{}}
   */

  var discountEventsMap = (_discountEventsMap = {}, _defineProperty$7(_discountEventsMap, TRANSACTION_TYPES$1.PURCHASE, [36]), _defineProperty$7(_discountEventsMap, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, [36]), _defineProperty$7(_discountEventsMap, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, [36]), _discountEventsMap);
  /**
   * event37 - Order Level Discount
   * @type {{}}
   */

  var orderLevelDiscountEventsMap = (_orderLevelDiscountEv = {}, _defineProperty$7(_orderLevelDiscountEv, TRANSACTION_TYPES$1.PURCHASE, [37]), _defineProperty$7(_orderLevelDiscountEv, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, [37]), _orderLevelDiscountEv);
  /**
   * event93 - Wallet Revenue
   * @type {{}}
   */

  var walletRevenueEventsMap = (_walletRevenueEventsM = {}, _defineProperty$7(_walletRevenueEventsM, TRANSACTION_TYPES$1.PURCHASE, [93]), _defineProperty$7(_walletRevenueEventsM, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, [93]), _defineProperty$7(_walletRevenueEventsM, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, [93]), _defineProperty$7(_walletRevenueEventsM, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, [93]), _walletRevenueEventsM);
  /**
   * event94 - Promotional Marketing Revenue
   * @type {{}}
   */

  var pmRevenueEventsMap = (_pmRevenueEventsMap = {}, _defineProperty$7(_pmRevenueEventsMap, TRANSACTION_TYPES$1.PURCHASE, [94]), _defineProperty$7(_pmRevenueEventsMap, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, [94]), _defineProperty$7(_pmRevenueEventsMap, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, [94]), _defineProperty$7(_pmRevenueEventsMap, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, [94]), _pmRevenueEventsMap);
  /**
   * event271 - Voucher Application Value
   * @type {{}}
   */

  var voucherApplicationEventsMap = _defineProperty$7({}, TRANSACTION_TYPES$1.APPLY_VOUCHER, [271]);
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's quantity, or an
   *     empty array if there are no unit events for the transaction type
   */


  var unitEventsString = function unitEventsString(transactionType, product) {
    var unitEvents = unitEventsMap[transactionType] || [];
    return unitEvents.map(function (v) {
      return "event".concat(v, "=").concat(product.quantity);
    });
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's totalPrice, or an
   *     empty array if there are no price events for the transaction type
   */


  var priceEventsString = function priceEventsString(transactionType, product) {
    var priceEvents = priceEventsMap[transactionType] || [];
    return priceEvents.map(function (v) {
      return "event".concat(v, "=").concat(asCurrency(product.totalPrice));
    });
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's totalRevenue, or an
   *     empty array if there are no revenue events for the transaction type
   */


  var revenueEventsString = function revenueEventsString(transactionType, product) {
    var revenueEvents = revenueEventsMap[transactionType] || [];
    return revenueEvents.map(function (v) {
      return "event".concat(v, "=").concat(asCurrency(product.totalRevenue));
    });
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's totalDiscount, or an
   *     empty array if there are no discount events for the transaction type
   */


  var discountEventsString = function discountEventsString(transactionType, product) {
    var discountEvents = discountEventsMap[transactionType] || [];

    if (typeof product.totalDiscount === 'number') {
      return discountEvents.map(function (v) {
        return "event".concat(v, "=").concat(asCurrency(product.totalDiscount || 0));
      });
    }

    return [];
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's totalOrderLevelDiscount, or an
   *     empty array if there are no order level discount events for the transaction type
   */


  var orderLevelDiscountEventsString = function orderLevelDiscountEventsString(transactionType, product) {
    var orderLevelDiscountEvents = orderLevelDiscountEventsMap[transactionType] || [];

    if (typeof product.totalOrderLevelDiscount === 'number') {
      return orderLevelDiscountEvents.map(function (v) {
        return "event".concat(v, "=").concat(asCurrency(product.totalOrderLevelDiscount || 0));
      });
    }

    return [];
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's walletRevenue, or an
   *     empty array if there are no wallet revenue events for the transaction type
   */


  var walletRevenueEventsString = function walletRevenueEventsString(transactionType, product) {
    var walletRevenueEvents = walletRevenueEventsMap[transactionType] || [];

    if (typeof product.walletRevenue === 'number') {
      return walletRevenueEvents.map(function (v) {
        return "event".concat(v, "=").concat(asCurrency(product.walletRevenue || 0));
      });
    }

    return [];
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's promotionalMarketingRevenue, or an
   *     empty array if there are no promotional marketing revenue events for the transaction type
   */


  var pmRevenueEventsString = function pmRevenueEventsString(transactionType, product) {
    var pmRevenueEvents = pmRevenueEventsMap[transactionType] || [];

    if (typeof product.promotionalMarketingRevenue === 'number') {
      return pmRevenueEvents.map(function (v) {
        return "event".concat(v, "=").concat(asCurrency(product.promotionalMarketingRevenue || 0));
      });
    }

    return [];
  };
  /**
   * @param {enum} transactionType one of Constants.TRANSACTION_TYPES
   * @param {Object} product
   * @return An array of strings in the form 'eventX=Y', where each X is an event
   *     number for the transaction type and Y is the product's voucherValue, or an
   *     empty array if there are no voucher application events for the transaction type
   */


  var voucherApplicationEventsString = function voucherApplicationEventsString(transactionType, product) {
    var voucherApplicationEvents = voucherApplicationEventsMap[transactionType] || [];

    if (typeof product.voucherValue === 'number') {
      return voucherApplicationEvents.map(function (v) {
        return "event".concat(v, "=").concat(asCurrency(product.voucherValue || 0));
      });
    }

    return [];
  };
  /**
   * Generate a product event string
   * @param {string} transactionType
   * @param {Object} product
   * @returns {string}
   */


  var productEventString = function productEventString(transactionType, product) {
    return asPipeDelimitedString(unitEventsString(transactionType, product).concat(priceEventsString(transactionType, product)).concat(revenueEventsString(transactionType, product)).concat(discountEventsString(transactionType, product)).concat(orderLevelDiscountEventsString(transactionType, product)).concat(walletRevenueEventsString(transactionType, product)).concat(pmRevenueEventsString(transactionType, product)).concat(voucherApplicationEventsString(transactionType, product)));
  };
  /**
   * Generate the product eVar string
   * SIDE EFFECT: Sets associated prop value on the payload
   *
   * @param {Object} product
   * @param {adobe~BuildPayloadContext} context
   * @returns {string}
   */


  var productEvarString = function productEvarString(product, _ref) {
    var payload = _ref.payload;
    // TODO: move this to a general attributes to evar mapping?
    var vars = {
      merchCategory: 8,
      recAnchor: 29,
      findingMethod: 31,
      pstpCampaign: 32,
      recCampaign: 33
    };
    return asPipeDelimitedString(Object.keys(vars).filter(function (v) {
      return product[v];
    }).map(function (v) {
      var varNum = vars[v]; // eslint-disable-next-line no-param-reassign

      payload["prop".concat(varNum)] = "D=v".concat(varNum);
      return "evar".concat(varNum, "=").concat(asColonDelimitedString(product[v].split(':').map(asProductValue)));
    }));
  };
  /**
   * Generate the product eVar string
   * SIDE EFFECT: Sets associated prop value on the payload
   *
   * @param {Object} transaction
   * @param {Object} product
   * @param {adobe~BuildPayloadContext} context
   * @returns {string}
   */
  // eslint-disable-next-line arrow-body-style


  var extractProductString = function extractProductString(transaction, product, context) {
    //  ; Product ; Quantity ; Total Revenue ; Events ; Evars ,
    return asSemicolonDelimitedString(['', productName(transaction.type, transaction.paymentMethod, product), productQuantity(transaction.type, product), productRevenue(transaction.type, product), productEventString(transaction.type, product), productEvarString(product, context)]);
  };
  /**
   * s.products
   *
   * @param {adobe~BuildPayloadContext} context
   * @returns {?string}
   */


  var products = function products(context) {
    var event = context.event;

    if (!isValidTransaction(context)) {
      return undefined;
    }

    if (!event.transaction.products || !event.transaction.products.length) {
      return undefined;
    }

    if (event.transaction.type === TRANSACTION_TYPES$1.MISC) {
      return undefined;
    }

    if (event.type === 'Impression' && event.transaction.type !== TRANSACTION_TYPES$1.RECOMMENDATION) {
      return undefined;
    }

    var transaction = event.transaction;

    var _extractProductString = function _extractProductString(product) {
      return extractProductString(transaction, product, context);
    };

    return asCommaDelimitedString(transaction.products.map(_extractProductString));
  };

  var PROTOCOL = /^[a-zA-Z]+:/;
  /**
   * Formats a URL parameter for use in PageURL or Referrer
   * @param {string} url  A valid URI, with all required escaping present.
   */

  var asUrl = (function (url) {
    if (!url || !PROTOCOL.exec(url)) {
      return undefined;
    }

    return url;
  });

  /**
   * Global Window Object
   * TODO: Fix this global reference, untestable from Node, React, etc.
   *
   * Options:
   *    Implement default within each plugin (webSdk uses global, xhr/rnps uses ???)
   *
   * @type {undefined}
   * @private
   */
  // eslint-disable-next-line no-undef

  var _window = typeof window !== 'undefined' ? window : undefined;
  /**
   * pageUrl Default Value
   * Logic pulled from AppMeasurement
   */


  var pageUrlDefault = function pageUrlDefault() {
    var windowLocation = _window && _window.location || '';
    return windowLocation.href ? windowLocation.href : windowLocation;
  };
  /**
   * s.pageURL
   * Defaults to window.location.href || window.location
   * @param data
   * @returns {?string}
   */


  var pageUrl = (function (_ref) {
    var event = _ref.event;
    return asUrl(event.pageUrl || pageUrlDefault());
  });

  var _window$1 = typeof window !== 'undefined' ? window : undefined;
  /**
   * Default referrer value
   * Logic pulled from AppMeasurement
   * @returns {*}
   */


  var referrerDefault = function referrerDefault() {
    return _window$1 && _window$1.document && _window$1.document.referrer;
  };
  /**
   * s.referrer
   * Http Referrer
   * Defaults to window.document.referrer
   * @param data
   * @returns {?string}
   */


  var referrer = (function (_ref) {
    var event = _ref.event;
    return asUrl(event.httpReferrer || referrerDefault());
  });

  /**
   * Ad Events
   *
   * event998 - Ad opt-out event
   * Add adobe event(s) that are specific to an advertisement
   *
   * @param context
   * @private
   */
  var adEvents = function adEvents(_ref) {
    var event = _ref.event,
        data = _ref.data;
    var currentSessionId = event && event.sessionId || '';

    if (currentSessionId.startsWith('optout')) {
      data.pushEvent(998);
    }
  };

  /**
   * event6 - Banner Clickthrough
   * see: list1, eVar41
   *
   * @param {adobe~BuildPayloadContext} context
   */

  var event6 = function event6(_ref) {
    var event = _ref.event,
        data = _ref.data;

    // event211 - Banner Hove - When a user is on focus of a tile for XXX ms
    if (!event.banner || data.hasEvent(211)) {
      return;
    }

    data.pushEvent(6);
  };
  /**
   * event15 - Filter category
   * NB: this event will also be set in clickTypeEvent, for:
   * FILTER_BY_MOST_RECENT
   * FILTER_BY_MOST_POPULAR
   * FILTER_CATEGORY
   * FILTER_COMMUNITIES
   */


  var event15 = function event15(_ref2) {
    var event = _ref2.event,
        data = _ref2.data;

    if (isArray_1(event.searchFilter) && event.searchFilter.length) {
      data.pushEvent(15);
    }
  };
  /**
   * event 16 - Sort category
   * NB: this event will also be set in clickTypeEvent, for SORT_CATEGORY
   */


  var event16 = function event16(_ref3) {
    var event = _ref3.event,
        data = _ref3.data;

    if (isArray_1(event.sortOrder) && event.sortOrder.length) {
      data.pushEvent(16);
    }
  };
  /**
   * event 32 - Purchase Intent
   * this is a special property sometimes sent with clickType: CLICK_HEADER
   */


  var event32 = function event32(_ref4) {
    var event = _ref4.event,
        data = _ref4.data;

    if (event.hasPurchaseIntent) {
      data.pushEvent(32);
    }
  };
  /**
   * event112 - Tile Interaction
   * Marks a tile click in Whats New, live Detail, Rich Profile
   * see: list3, eVar99
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event112 = function event112(_ref5) {
    var event = _ref5.event,
        data = _ref5.data;

    if (event.tile || event.tiles) {
      data.pushEvent(112);
    }
  };
  /**
   * event193 - API call succeeded.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event193 = function event193(_ref6) {
    var event = _ref6.event,
        data = _ref6.data;

    if (event.apiStatus === API_STATUSES$1.SUCCESS) {
      data.pushEvent(193);
    }
  };
  /**
   * event194 - API call failed.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event194 = function event194(_ref7) {
    var event = _ref7.event,
        data = _ref7.data;

    if (event.apiStatus === API_STATUSES$1.FAILURE) {
      data.pushEvent(194);
    }
  };
  /**
   * event287 - playtime added event.
   * dispatched when playtime is increased, includes the increased time in minutes.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event287 = function event287(_ref8) {
    var event = _ref8.event,
        data = _ref8.data;
    data.pushEvent({
      id: 287,
      value: event.playtimeDurationChange
    });
  };
  /**
   * event288 - playtime subtracted event.
   * dispatched when playtime is decreased, includes the decreased time in minutes.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event288 = function event288(_ref9) {
    var event = _ref9.event,
        data = _ref9.data;
    data.pushEvent({
      id: 288,
      value: Math.abs(event.playtimeDurationChange)
    });
  };
  /**
   * Add adobe events specific to the GCT Event type "click"
   *
   * NOTE: This must be called after _clickTypeEvents() so that we only set event6 if 211 is not.
   * @param context
   * @private
   */


  var clickEvents = function clickEvents(context) {
    var data = context.data,
        event = context.event; // event66 - User Engagement Event

    data.pushEvent(66);

    if (!event.isPlaytimeUnlimited) {
      if (event.playtimeDurationChange > 0) {
        event287(context);
      } else if (event.playtimeDurationChange < 0) {
        event288(context);
      }
    }

    event6(context);
    event15(context);
    event16(context);
    event32(context);
    event112(context);
    event193(context);
    event194(context);
  };

  var _clickTypeEventMap;

  function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /* eslint-disable camelcase */

  var clickTypeEventMap = (_clickTypeEventMap = {}, _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ACCEPT_FAMILY_INVITE, [254]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ACCEPT_REAL_NAME_REQUEST, [127]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ACCEPT_FRIEND_REQUEST, [126]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ADD_PAYMENT_METHOD, [232]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ADD_TO_CART_UPSELL, [182]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ADD_TO_LIBRARY, [14, 30]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.ADD_TO_WISHLIST, [87]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.APPROVE_SUBACCOUNT, [218]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.BLOCK_USER, [133]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CANCEL_FRIEND_REQUEST, [124]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CANCEL_REAL_NAME_REQUEST, [125]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CHANGE_EVENT_STATUS_NOT_GOING, [47]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLAIM_KID_ACCOUNT, [217]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLAIM_YOUTH_ACCOUNT, [216]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLICK_BANNER, [6]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLICK_QUICK_VIEW_HOVER_BANNER, [211]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLICK_QUICK_VIEW_OPEN, [43, 114]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLICK_RECOMMENDATION, [97]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CLICK_TILE, [112]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_EVENT, [262]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_KID_ACCOUNT, [214]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_MASTER_ACCOUNT, [212]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_OFFLINE_ACCOUNT, [215]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_YOUTH_ACCOUNT, [213]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_TEAM, [248]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CREATE_WISHLIST, [87, 89]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CHANGE_TEAM_DESCRIPTION, [249]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CHANGE_TEAM_LOGO, [250]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.CHANGE_TEAM_NAME, [252]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DECLINE_FAMILY_INVITE, [255]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DECLINE_TEAM_INVITE, [243]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DELETE_FRIEND_REQUEST, [128]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DELETE_REAL_NAME_REQUEST, [129]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DISBAND_TEAM, [247]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DEMOTE_FROM_GUARDIAN, [275]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DOWNLOAD, [14]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FAVORITED, [69]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FILTER_BY_MOST_RECENT, [15]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FILTER_BY_MOST_POPULAR, [15]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FILTER_CATEGORY, [15]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FILTER_COMMUNITIES, [15]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.FOLLOW, [47]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_COMMENT, [186]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_FRIEND_REQUEST, [189]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_GRIEF_REPORT, [190]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_MESSAGE, [188]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_RESHARE, [192]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.INITIATE_SHARE, [187]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.JOIN_COMMUNITY, [150]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.JOIN_EVENT, [149]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.JOIN_PARTY, [148]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.JOIN_TEAM, [242]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.JOIN_SESSION, [135, 136]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.KICK_OUT_TEAM_MEMBER, [246]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.LEAVE_TEAM, [244]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.LEAVE_FAMILY, [256]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.LIKE, [46]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.OPEN_INTRO, [191]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.PSPLUS_UPSELL, [182]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.POST_COMMUNITY_WALL, [260]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.PREORDER_INTRO, [219]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.PROMOTE_TO_GUARDIAN, [258]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.RATE, [34]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REPLY_COMMUNITY_POST, [261]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REQUEST_TO_WATCH, [137]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_BACKGROUND_IMAGE, [208]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_FROM_FRIEND, [272]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_FROM_WISHLIST, [88]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_PAYMENT_METHOD, [233]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_TEAM_LOGO, [251]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REMOVE_USER_FROM_FAMILY, [257]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.REVOKE_FAMILY_INVITE, [269]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEARCH, [17]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEARCH_FRIENDS, [17]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEARCH_COMMUNITIES, [17]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SELECT_BANNER, [211]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEND_MESSAGE, [142]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEND_FAMILY_INVITE, [253]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEND_FRIEND_REQUEST, [122]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEND_GRIEF_REPORT, [132]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SEND_REAL_NAME_REQUEST, [123]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SORT_CATEGORY, [16]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.START_APP, [135]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.START_GAME, [135]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.START_PARTY, [152]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SUBMIT_COMMENT, [145]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SUBMIT_POST_ANYTHING, [204]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SUBMIT_RESHARE, [49]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SUBSCRIBE_EXTEND_INTRO, [220]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.SUBSCRIBE_AUTOFUND, [221]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.UNBLOCK_USER, [134]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.UNFAVORITED, [76]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.UNLIKE, [77]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.UNFOLLOW, [151]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VERSION_UPSELL, [182]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_BROADCAST, [138]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_COMMUNITY, [139]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_ACTIVITY, [191]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_AS_FAMILY_MANAGER, [265]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_AS_GUARDIAN, [266]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.VIEW_SEARCH_RESULT, [18]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.DOWNLOAD_PS_NOW_GAME, [293]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.OSK_SEARCH_TEXT_ENTRY, [309]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.OSK_SEARCH_ZERO_STATE, [17, 310]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.OSK_SEARCH_NO_RESULTS, [17, 19]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.OSK_SEARCH_RESULTS_RETURN, [311]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.LOGIN, [3]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.MULTIVIEW_PROGRAM_ADDED, [331]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.MULTIVIEW_PROGRAM_REMOVED, [332]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.MULTIVIEW_SWITCH_ONFOCUS, [333]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.MULTIVIEW_SWITCH_OFFFOCUS, [334]), _defineProperty$8(_clickTypeEventMap, CLICK_TYPES$1.MULTIVIEW_WATCH, [335]), _clickTypeEventMap);
  /**
   * event33 - Rate Submit Event
   * Submit of a Rating
   *
   * @param {adobe~BuildPayloadContext} context
   */

  var event33 = function event33(_ref) {
    var event = _ref.event,
        data = _ref.data;
    var ratingNumber = event.ratingNumber;

    if (!ratingNumber) {
      return;
    }

    data.pushEvent({
      id: 33,
      value: parseInt(ratingNumber, 10)
    });
  };
  /**
   * event143 - Send Sticker
   * Number of times a suer sends a sticker within a message
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event143 = function event143(_ref2) {
    var event = _ref2.event,
        data = _ref2.data;

    if (event.hasSticker === true) {
      data.pushEvent(143);
    }
  };
  /**
   * event144 - Send Attachment
   * Number of times a user sens an attachment within a message
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event144 = function event144(_ref3) {
    var event = _ref3.event,
        data = _ref3.data;

    if (event.hasAttachment === true) {
      data.pushEvent(144);
    }
  };
  /**
   * event205 - Whats New - Attach Image
   * User attaches image to post in PATWN
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event205 = function event205(_ref4) {
    var event = _ref4.event,
        data = _ref4.data;

    if (event.hasImage === true) {
      data.pushEvent(205);
    }
  };
  /**
   * event206 - whats New Tag Game
   * User tags game to post in PATWN
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event206 = function event206(_ref5) {
    var event = _ref5.event,
        data = _ref5.data;

    if (event.hasGameTagged === true) {
      data.pushEvent(206);
    }
  };
  /**
   * event207 - Whats New Tag Users
   * User tags one or more friends followers to post in PATWN
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event207 = function event207(_ref6) {
    var event = _ref6.event,
        data = _ref6.data;

    if (event.hasPlayersTagged > 0) {
      data.pushEvent({
        id: 207,
        value: parseInt(event.hasPlayersTagged, 10)
      });
    }
  };
  /**
   * event209 - Profile Change Background Image
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event209 = function event209(_ref7) {
    var event = _ref7.event,
        data = _ref7.data;

    if (event.hasImageChanged === true) {
      data.pushEvent(209);
    }
  };
  /**
   * event210 - Profile Change Background Color
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event210 = function event210(_ref8) {
    var event = _ref8.event,
        data = _ref8.data;

    if (event.hasColorChanged === true) {
      data.pushEvent(210);
    }
  };
  /**
   * event245 - Send Team Invitation
   * Tracks total team invitations sent.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event245 = function event245(_ref9) {
    var event = _ref9.event,
        data = _ref9.data;

    if (event.hasPlayersInvited > 0) {
      data.pushEvent({
        id: 245,
        value: parseInt(event.hasPlayersInvited, 10)
      });
    }
  };
  /**
   * event276 - Opt-In to Additional Data
   * event277 - Opt-Out to Additional Data
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event276_277 = function event276_277(_ref10) {
    var event = _ref10.event,
        data = _ref10.data;

    if (event.allowAdditionalData === undefined) {
      return;
    }

    data.pushEvent(event.allowAdditionalData ? 276 : 277);
  };
  /**
   * event278 - Opt-In to Personalization
   * event279 - Opt-Out to Personalization
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event278_279 = function event278_279(_ref11) {
    var event = _ref11.event,
        data = _ref11.data;

    if (event.allowPersonalizedRecs === undefined) {
      return;
    }

    data.pushEvent(event.allowPersonalizedRecs ? 278 : 279);
  };
  /**
   * event280 - Opt-In to Personalization Advertisements
   * event281 - Opt-Out to Personalization Advertisements
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event280_281 = function event280_281(_ref12) {
    var event = _ref12.event,
        data = _ref12.data;

    if (event.allowPersonalizedAds === undefined) {
      return;
    }

    data.pushEvent(event.allowPersonalizedAds ? 280 : 281);
  };
  /**
   * event295 - Number of urls posted
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event295 = function event295(_ref13) {
    var event = _ref13.event,
        data = _ref13.data;
    var hasUrl = parseInt(event.urlsPosted, 10);

    if (hasUrl > 0) {
      data.pushEvent({
        id: 295,
        value: hasUrl
      });
    } else if (hasUrl === 0) {
      data.pushEvent({
        id: 295,
        value: 0
      });
    }
  };
  /**
   * event336 - MultiView Time Spent
   * Multiview Time Viewed in seconds
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event336 = function event336(_ref14) {
    var event = _ref14.event,
        data = _ref14.data;
    var timeSpent = parseInt(event.multiViewTimeSpent, 10);

    if (timeSpent > 0) {
      data.pushEvent({
        id: 336,
        value: timeSpent
      });
    } else if (timeSpent === 0) {
      data.pushEvent({
        id: 336,
        value: 0
      });
    }
  };
  /**
   *
   * Set Events based on the event clickType
   *
   * Checks config.overrideEvents.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var clickTypeEvents = function clickTypeEvents(context) {
    var event = context.event,
        config = context.config,
        data = context.data;

    if (!event.clickType) {
      return;
    } // If the client manually configured event types to override, use them


    if (config.overrideEvents && config.overrideEvents[event.clickType]) {
      data.pushEvents(config.overrideEvents[event.clickType]);
      return;
    } // Push the events for the given click type


    data.pushEvents(clickTypeEventMap[event.clickType] || []); // Other miscellaneous events

    switch (event.clickType) {
      case CLICK_TYPES$1.RATE:
        event33(context);
        break;

      case CLICK_TYPES$1.SEND_MESSAGE:
        event143(context);
        event144(context);
        break;

      case CLICK_TYPES$1.SUBMIT_POST_ANYTHING:
        event205(context);
        event206(context);
        event207(context);
        event295(context);
        break;

      case CLICK_TYPES$1.SEND_TEAM_INVITE:
        event245(context);
        break;

      case CLICK_TYPES$1.CHANGE_BACKGROUND_IMAGE:
      case CLICK_TYPES$1.SET_BACKGROUND_IMAGE:
        event209(context);
        event210(context);
        break;

      case CLICK_TYPES$1.MANAGE_DATA_GATHERING_SETTINGS:
        event276_277(context);
        break;

      case CLICK_TYPES$1.MANAGE_PERSONALIZATION_SETTINGS:
        event278_279(context);
        event280_281(context);
        break;

      case CLICK_TYPES$1.MULTIVIEW_WATCH:
        event336(context);
        break;

      default:
    }
  };

  var _formEventsMap;

  function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /**
   * Form Events
   *
   * event98  - Form Start
   * event99  - Form Complete
   * event101 - Form Flow Start
   * event102 - Form Flow Complete
   * event103 - Form Step
   */

  var formEventsMap = (_formEventsMap = {}, _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.START, [98, 103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.COMPLETE, [99, 103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.NEXT, [103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.BACK, [103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.CANCEL, [103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.SKIP, [104]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.START_NESTED, [101, 103]), _defineProperty$9(_formEventsMap, FORM_ACTIONS$1.COMPLETE_NESTED, [102, 103]), _formEventsMap);

  var formEvents = function formEvents(_ref) {
    var event = _ref.event,
        data = _ref.data;
    data.pushEvents(formEventsMap[event.formAction] || []);
    return undefined;
  };

  /**
   * event78 - EA Access: Vault Download (e78)
   * EA Vault Member downloads from item requiring EA access
   * Spec documentation: https://confluence.sie.sony.com/display/LEAN/Adobe+Analytics+Reporting+Requirements
   *
   * @param {adobe~BuildPayloadContext} context
   */
  var event78 = function event78(_ref) {
    var event = _ref.event,
        data = _ref.data;

    if (event.eaAccessIsVaultPurchase === true) {
      data.pushEvent(78);
    }
  };
  /**
   * event79 - EA Access: Game Trial Download (e79)
   * EA Trial Member downloads item requiring EA trial access
   * Spec documentation: https://confluence.sie.sony.com/display/LEAN/Adobe+Analytics+Reporting+Requirements
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event79 = function event79(_ref2) {
    var event = _ref2.event,
        data = _ref2.data;

    if (event.eaAccessIsPFTPurchase === true) {
      data.pushEvent(79);
    }
  };
  /**
   * event299 - Sign Up for Tournament (e299)
   * Counter for each tournament sign up in competitive gaming console
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event299 = function event299(_ref3) {
    var event = _ref3.event,
        data = _ref3.data;

    if (event.hasCompletedTournamentSignUp === true) {
      data.pushEvent(299);
    }
  };
  /**
   * event322 - Total Strands Presented (e322)
   * Used to collect the total strands presented to the user.
   * Spec documentation: https://confluence.sie.sony.com/display/BWAH/Strands+Re-order
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event322 = function event322(_ref4) {
    var event = _ref4.event,
        data = _ref4.data;

    if (event.totalStrands) {
      data.pushEvent({
        id: 322,
        value: event.totalStrands
      });
    }
  };
  /**
   * event 312 - Search Success event from Zero Search Results
   * Event on PDP for Search Success Event from Zero Results State into OSK Search Results
   * @param {adobe~BuildPayloadContext} context
   */


  var event312 = function event312(_ref5) {
    var event = _ref5.event,
        data = _ref5.data;

    if (event.oskZeroStateResult && event.searchTerm !== '') {
      data.pushEvent(312);
    }
  };
  /**
   * event 313 - Search Success event from Zero State No Text Input
   * Event on PDP for Search Success event from Zero State No Text Input into OSK Search Results
   * @param {adobe~BuildPayloadContext} context
   */


  var event313 = function event313(_ref6) {
    var event = _ref6.event,
        data = _ref6.data;

    if (event.oskZeroStateResult && event.searchTerm === '') {
      data.pushEvent(313);
    }
  };
  /**
   * event1 - Page View
   * @param data
   */


  var pageViewEvents = function pageViewEvents(context) {
    var data = context.data;
    data.pushEvent(1);
    event78(context);
    event79(context);
    event299(context);
    event312(context);
    event313(context);
    event322(context);
  };

  /**
   * event234 - PS Now Membership Status : Free Trial
   *
   * @param {adobe~BuildPayloadContext} context
   */

  var event234 = function event234(_ref) {
    var environment = _ref.environment,
        data = _ref.data;

    if (environment.psnowMembershipType === PSNOW_TYPES$1.TRIAL) {
      data.pushEvent(234);
    }
  };
  /**
   * event235 - PS Now Membership Status : Paid Member
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event235 = function event235(_ref2) {
    var environment = _ref2.environment,
        data = _ref2.data;

    if (environment.psnowMembershipType === PSNOW_TYPES$1.SUBSCRIPTION) {
      data.pushEvent(235);
    }
  };
  /**
   * event236 - PS Now Membership Status : Non Member
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event236 = function event236(_ref3) {
    var environment = _ref3.environment,
        data = _ref3.data;

    if (environment.psnowMembershipType === PSNOW_TYPES$1.NOT_SUBSCRIBED) {
      data.pushEvent(236);
    }
  };

  var psnowEvents = function psnowEvents(context) {
    event234(context);
    event235(context);
    event236(context);
  };

  /**
   * Session Events
   *
   * event66 - User Engagement Event
   * event264 - On Load
   * event999 - the user has opted out for the platform privacy ws1, sent on 'minimal' in privacySettings.
   * Event that signals the on load of an app, page, or link event
   * @param data
   */
  var ADOBE_SESSION_CACHE_KEY = 'lastAdobeReportedSessionId';

  var sessionEvents = function sessionEvents(_ref) {
    var event = _ref.event,
        data = _ref.data,
        cache = _ref.cache;
    var lastAdobeReportedSessionId = cache.get(ADOBE_SESSION_CACHE_KEY) || '';
    var currentSessionId = event && event.sessionId || '';

    if (currentSessionId.startsWith('optout') && currentSessionId !== lastAdobeReportedSessionId && data.hasEvents()) {
      data.pushEvent(999);
    }
  };

  /**
   * Start Up Events
   *
   * event66 - User Engagement Event
   * event264 - On Load
   * Event that signals the on load of an app, page, or link event
   * @param data
   */
  var startUpEvents = function startUpEvents(_ref) {
    var data = _ref.data;
    data.pushEvents([66, 264]);
  };

  var _transactionTypeEvent;

  function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var fundingTypes = [TRANSACTION_TYPES$1.FUNDING, TRANSACTION_TYPES$1.FUNDING_3DS];
  var fundingPaymentTypes = [PAYMENT_METHODS$1.CC_VISA_3DS, PAYMENT_METHODS$1.CC_MASTERCARD_3DS];
  /**
   * event2 - Buy Now - Type of purchase that does not go through cart
   * event8 - Voucher Redemption Event - Use a voucher to buy a product
   * event9 - Voucher Redemption Value - Value of voucher
   * event10 - Add Funds Event - Add Funds to Wallet
   * event11 - Add Funds Value - Value of Funds added
   * event26 - Cart Units Added - How many units of a product added to cart
   * event27 - Cart Revenue Added - How much dollar value added to cart
   * event28 - Cart Units Removed - How many units of a product removed from cart
   * event29 - Cart Revenue Removed - How many units of a product removed from cart
   * event31 - Product View (Custom) - View of a page designated as a product
   * event51 - Preorder - Completing a preorder
   * @type {{}}
   */

  var transactionTypeEventMap = (_transactionTypeEvent = {}, _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VIEW_PRODUCT, ['prodView', 31]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.ADD_TO_CART, ['scOpen', 'scAdd', 26, 27]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.REMOVE_FROM_CART, ['scRemove', 28, 29]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VIEW_CART, ['scView']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.CONFIRM_PURCHASE, ['scCheckout']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PURCHASE, ['purchase']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PURCHASE_3DS, ['purchase', 231]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.BUY_NOW, ['purchase', 2]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.BUY_NOW_3DS, ['purchase', 2, 231]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PREORDER_PAY_NOW, ['purchase', 2, 51]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS, ['purchase', 2, 51, 231]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VOUCHER_CASH, [8, 9, 10, 11]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VOUCHER_PRODUCT, [8, 9]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.FUNDING_3DS, [10, 11, 231]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.BEGIN_3DS, [230]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.COMPLETE_3DS, [231]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.FUNDING, [10, 11]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.APPLY_VOUCHER, [270, 271]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, ['purchase']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, ['purchase']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, ['purchase']), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PURCHASE_DETAILS, [323, 324]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.PROCESSING_PAYMENT, [325, 326]), _defineProperty$a(_transactionTypeEvent, TRANSACTION_TYPES$1.CONFIRM_PURCHASE_FPI, ['scCheckout', 314, 315]), _transactionTypeEvent);
  /**
   * Transaction Type Based Events
   *
   * @param {adobe~BuildPayloadContext} context
   */

  var transactionTypeBasedEvents = function transactionTypeBasedEvents(_ref) {
    var event = _ref.event,
        data = _ref.data;

    if (transactionTypeEventMap[event.transaction.type]) {
      data.pushEvents(transactionTypeEventMap[event.transaction.type]);
    }
  };
  /**
   * Check if product has totalDiscount set
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var hasTotalDiscount = function hasTotalDiscount(product) {
    return product.totalDiscount !== undefined;
  };
  /**
   * Check if product has totalOrderLevelDiscount set
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var hasTotalOrderLevelDiscount = function hasTotalOrderLevelDiscount(product) {
    return product.totalOrderLevelDiscount !== undefined;
  };
  /**
   * Check if product has walletRevenue set
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var hasWalletRevenue = function hasWalletRevenue(product) {
    return product.walletRevenue !== undefined;
  };
  /**
   * Check if product has promotionalMarketingRevenue set
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var hasPromotionalMarketingRevenue = function hasPromotionalMarketingRevenue(product) {
    return product.promotionalMarketingRevenue !== undefined;
  };
  /**
   * products - Function to efficiently iterate over products to check for specific events
   * event36 - Product Level Discount
   * event37 - Order Level Discount
   * event93 - Wallet Revenue
   * event94 - Promotional Marketing Revenue
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var products$1 = function products(_ref2) {
    var event = _ref2.event,
        data = _ref2.data;

    if (event.transaction.type === TRANSACTION_TYPES$1.PURCHASE) {
      // Iterate over products to see if any have promotionalMarketingRevenue set
      var setEvent36 = false;
      var setEvent37 = false;
      var setEvent93 = false;
      var setEvent94 = false;
      var productsLength = event.transaction.products.length;

      for (var i = 0; i < productsLength; i += 1) {
        if (!setEvent36 && hasTotalDiscount(event.transaction.products[i])) {
          setEvent36 = true;
        }

        if (!setEvent37 && hasTotalOrderLevelDiscount(event.transaction.products[i])) {
          setEvent37 = true;
        }

        if (!setEvent93 && hasWalletRevenue(event.transaction.products[i])) {
          setEvent93 = true;
        }

        if (!setEvent94 && hasPromotionalMarketingRevenue(event.transaction.products[i])) {
          setEvent94 = true;
        }
      }

      if (setEvent36) data.pushEvent(36);
      if (setEvent37) data.pushEvent(37);
      if (setEvent93) data.pushEvent(93);
      if (setEvent94) data.pushEvent(94);
    }
  };
  /**
   * event231 - Use Secure Transaction Service
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event231 = function event231(_ref3) {
    var event = _ref3.event,
        data = _ref3.data;

    if (arrayIncludes(fundingTypes, event.transaction.type) && arrayIncludes(fundingPaymentTypes, event.transaction.paymentMethod)) {
      data.pushEvent(231);
    }
  };
  /**
   * Transaction Events
   * @param {adobe~BuildPayloadContext} context
   */


  var transactionEvents = function transactionEvents(context) {
    if (!isValidTransaction(context)) {
      return;
    }

    transactionTypeBasedEvents(context);
    products$1(context);
    event231(context);
  };

  /**
   * event25 - Error Event
   * @param data
   */
  var userFacingErrorEvents = function userFacingErrorEvents(_ref) {
    var data = _ref.data;
    data.pushEvent(25);
  };

  var _liveStreamEventMap, _nonLiveStreamEventMa;

  function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  var TEN_MINUTES = 10 * 60;
  /**
   * Event Ids for Live Streams
   * event81 - Media Pause
   * event82 - Media Resume
   * event83 - Media Live Start
   * event86 - Media Auto Play
   * event201 - Media On Focus Play
   *
   * @type {Object}
   * @private
   */

  var liveStreamEventMap = (_liveStreamEventMap = {}, _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.AUTO_START, [83, 86]), _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.ON_FOCUS_AUTO_START, [83, 86, 201]), _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.ON_FOCUS_START, [83, 201]), _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.PAUSE, [81]), _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.RESUME, [82]), _defineProperty$b(_liveStreamEventMap, VIDEO_ACTIONS$1.START, [83]), _liveStreamEventMap);
  /**
   * Event Ids for Non Live Streams
   * event20 - Media Start
   * event24 - Media Complete
   * event81 - Media Pause
   * event82 - Media Resume
   * event86 - Media Auto Play
   * event201 - Media On Focus Play
   * @type {Object}
   * @private
   */

  var nonLiveStreamEventMap = (_nonLiveStreamEventMa = {}, _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.AUTO_START, [20, 86]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.COMPLETE, [24]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.ON_FOCUS_AUTO_START, [20, 86, 201]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.ON_FOCUS_START, [20, 201]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.PAUSE, [81]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.RESUME, [82]), _defineProperty$b(_nonLiveStreamEventMa, VIDEO_ACTIONS$1.START, [20]), _nonLiveStreamEventMa);
  /**
   * Event Ids for which Event65 is included
   * @type {Object}
   * @return {boolean}
   * @private
   */
  // eslint-disable-next-line arrow-body-style

  var videoActionHasEvent65 = function videoActionHasEvent65(videoAction) {
    return !arrayIncludes([VIDEO_ACTIONS$1.AUTO_START, VIDEO_ACTIONS$1.START, VIDEO_ACTIONS$1.ON_FOCUS_START, VIDEO_ACTIONS$1.ON_FOCUS_AUTO_START], videoAction);
  };
  /**
   * Video Progress Events for non live content
   *
   * event21 - Media 25% milestone
   * event22 - Media 50% milestone
   * event23 - Media 75% milestone
   *
   * @param {adobe~BuildPayloadContext} context
   * @private
   */


  var progressEvent = function progressEvent(_ref) {
    var event = _ref.event,
        data = _ref.data;

    if (event.streamType === STREAM_TYPES$1.LIVE) {
      return;
    }

    if (event.videoAction !== VIDEO_ACTIONS$1.PROGRESS) {
      return;
    }

    if (!event.elapsedTime || !event.videoDuration) {
      return;
    }

    var elapsedTime = event.elapsedTime,
        videoDuration = event.videoDuration; // Elapsed Time is past 25, 50, or 75% mark.

    var currentBoundary;
    var previousBoundary;
    var FOUR_MINUTES = 4 * 60;

    if (videoDuration > FOUR_MINUTES) {
      currentBoundary = elapsedTime - elapsedTime % 60;
      previousBoundary = currentBoundary - 60;
    } else {
      // Video is less than four minutes, need to use per-second tracking.
      currentBoundary = elapsedTime + 1;
      previousBoundary = elapsedTime - 1;
    } // We need to detect if the elapsed time as passed the
    // 25% or 50% or 75% mark. We check if each milestone is
    // between the elapsed time (rounded down to the minute)
    // and the previous minute boundary. If it is, that means
    // we've just passed the milestone


    var p25 = videoDuration * 0.25;
    var p50 = videoDuration * 0.50;
    var p75 = videoDuration * 0.75;

    if (previousBoundary < p25 && currentBoundary >= p25 && elapsedTime >= p25 && elapsedTime < p50) {
      data.pushEvent(21);
    } else if (previousBoundary < p50 && currentBoundary >= p50 && elapsedTime >= p50 && elapsedTime < p75) {
      data.pushEvent(22);
    } else if (previousBoundary < p75 && currentBoundary >= p75 && elapsedTime >= p75) {
      data.pushEvent(23);
    }
  };
  /**
   * event84 - Media Live 1 Minute
   * One minute heartbeat triggered for the first 9 minutes of playback
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event84 = function event84(_ref2) {
    var event = _ref2.event,
        data = _ref2.data;

    // This only applies to LIVE streams
    if (event.streamType !== STREAM_TYPES$1.LIVE) {
      return;
    } // This only applies to PROGRESS event


    if (event.videoAction !== VIDEO_ACTIONS$1.PROGRESS) {
      return;
    } // This is also only for when elapsedTime is less than 10 minutes


    if (!event.elapsedTime || event.elapsedTime >= TEN_MINUTES) {
      return;
    } // Finally, only if the elapsedTime is at the minute boundary


    if (event.elapsedTime % 60 !== 0) {
      return;
    }

    data.pushEvent(84);
  };
  /**
   * event85 - Media Live 10 Minute
   * Ten minutes heartbeat triggered after 10 minutes of playback
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event85 = function event85(_ref3) {
    var event = _ref3.event,
        data = _ref3.data;

    // This only applies to LIVE streams
    if (event.streamType !== STREAM_TYPES$1.LIVE) {
      return;
    } // This only applies to PROGRESS event


    if (event.videoAction !== VIDEO_ACTIONS$1.PROGRESS) {
      return;
    } // This is also only for when elapsedTime is greater than 10 minutes


    if (!event.elapsedTime || event.elapsedTime < TEN_MINUTES) {
      return;
    } // Finally, only if the elapsedTime is at the 10 minute boundary


    if (event.elapsedTime % TEN_MINUTES !== 0) {
      return;
    }

    data.pushEvent(85);
  };
  /**
   * event65 - Video Time Viewed
   * Total time eyeballs on the content.
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var event65 = function event65(_ref4) {
    var event = _ref4.event,
        data = _ref4.data;

    if (!videoActionHasEvent65(event.videoAction)) {
      return;
    }

    var value = event.currentViewedTime;

    if (!isUndefined_1(value)) {
      data.pushEvent({
        id: 65,
        value: value
      });
    }
  };
  /**
   * Set Events for a live stream
   * @param {adobe~BuildPayloadContext} context
   */


  var liveStreamEvents = function liveStreamEvents(context) {
    var event = context.event,
        data = context.data;

    if (liveStreamEventMap[event.videoAction]) {
      data.pushEvents(liveStreamEventMap[event.videoAction]);
      return;
    } // Progress Events


    event84(context);
    event85(context);
  };
  /**
   * Set Events for a non-live stream
   *
   * @param {adobe~BuildPayloadContext} context
   */


  var nonLiveStreamEvents = function nonLiveStreamEvents(context) {
    var event = context.event,
        data = context.data;

    if (nonLiveStreamEventMap[event.videoAction]) {
      data.pushEvents(nonLiveStreamEventMap[event.videoAction]);
      return;
    }

    progressEvent(context);
  };
  /**
   * Returns Events for a VideoStream Event
   *
   * @param {adobe~BuildPayloadContext} context
   * @private
   */


  var videoStreamEvents = function videoStreamEvents(context) {
    var event = context.event,
        data = context.data;

    if (!isValidVideoAction(event.videoAction)) {
      return;
    }

    if (event.streamType === STREAM_TYPES$1.LIVE) {
      liveStreamEvents(context);
    } else {
      nonLiveStreamEvents(context);
    } // Effective Condition:
    //   videoAction == PROGRESS
    //   not an eventable elapsedTime


    if (!data.hasEvents()) {
      return;
    } // Event66 - User Engagement Event - See eVar49


    data.pushEvent(66);
    event65(context);
  };

  /**
   * Checks if `value` is an integer.
   *
   * **Note:** This method is based on
   * [`Number.isInteger`](https://mdn.io/Number/isInteger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
   * @example
   *
   * _.isInteger(3);
   * // => true
   *
   * _.isInteger(Number.MIN_VALUE);
   * // => false
   *
   * _.isInteger(Infinity);
   * // => false
   *
   * _.isInteger('3');
   * // => false
   */

  function isInteger(value) {
    return typeof value == 'number' && value == toInteger_1(value);
  }

  var isInteger_1 = isInteger;

  /**
   * Converts an event item ({int} or {object}) to an appropriate event string
   * @param {int|Object} v              Event Item
   * @param {Object}     addedIdHash    [MODIFIED] Hash to track added Ids
   * @returns {?string}
   * @private
   */

  var _eventItemToString = function _eventItemToString(v, addedIdHash) {
    var id;
    var value;

    if (isInteger_1(v) || isString_1(v)) {
      id = v;
    } else if (isObject_1(v)) {
      id = v.id;
      value = v.value;
    } else {
      return undefined;
    }

    id = isInteger_1(id) ? "event".concat(id) : id;

    if (addedIdHash[id]) {
      return undefined;
    } // eslint-disable-next-line no-param-reassign


    addedIdHash[id] = true;
    return value !== undefined ? "".concat(id, "=").concat(value) : id;
  };
  /**
   * s.events
   *
   * Builds the events array by cycling through data.events value as built through data.pushEvent
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var events = (function (_ref) {
    var data = _ref.data;

    if (!data.events) {
      return undefined;
    }

    var added = {};

    var castEventItemToString = function castEventItemToString(value) {
      return _eventItemToString(value, added);
    };

    return data.events.map(castEventItemToString).filter(function (v) {
      return v;
    }).join(',');
  });

  var _bannerTypeEventMap2, _serverMap2, _eVar14Map2, _eVar15Map2, _eVar22Map2, _eVar35Map2, _eVar36Map2, _eVar58Map2;

  function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }

  function _typeof$d(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$d = function _typeof(obj) { return typeof obj; }; } else { _typeof$d = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$d(obj); }

  function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
  /**
   *  This extraction is the first step in migration towards a configuration based DSL.
   *
   *  The goals for this extraction of logic from the adobePlugin.js file is to provide a clear
   *  understanding of how each parameter built is created, and the scenarios for creating events.
   *
   *  In addition, by consolodating the generating of each eVar into a single function, discrepencies
   *  between disparate implementations have been discovered.
   *
   */

  /**
   * event5 - Banner Impression - Fired whenever a banner type is displayed
   * event181 - Viewable Impression - Fire after initial impression (5)
   * event195 - Video Viewable View Impression
   * event200 - Add Supply Viewable Impression
   * event227 - Paid Advertisement Banner Refresh Load - Banner Refresh Events per net Ads
   * event228 - Banner Refresh View  - Banner Refresh Events per net Ads
   * @type {{}}
   * @private
   */

  var _bannerTypeEventMap = (_bannerTypeEventMap2 = {}, _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.PAID_AD_VIEWED, [200]), _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.DEFAULT, [181]), _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.PAID_AD_LOADED, [5]), _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.VIDEO_AD_PLAYED, [195]), _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.REFRESH_IMAGE_VIEWED, [181, 228]), _defineProperty$c(_bannerTypeEventMap2, BANNER_TYPES$1.REFRESH_VIDEO_VIEWED, [195, 228]), _bannerTypeEventMap2);
  /**
   * A list of transaction types that are used during a purchase page view event
   *
   * @type {string[]}
   * @private
   */


  var _purchaseTransactionTypes = [TRANSACTION_TYPES$1.PURCHASE, TRANSACTION_TYPES$1.PURCHASE_3DS, TRANSACTION_TYPES$1.BUY_NOW, TRANSACTION_TYPES$1.BUY_NOW_3DS, TRANSACTION_TYPES$1.PREORDER_PAY_NOW, TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, TRANSACTION_TYPES$1.PROCESSING_PAYMENT];
  /**
   * s.account
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */

  var account = function account(_ref) {
    var config = _ref.config;
    return config.reportSuite.join(',');
  };
  /**
   * s.campaign - External Tracking Code
   * External Tracking code - Collects the EMCID value
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var campaign = function campaign(_ref2) {
    var event = _ref2.event;
    return cleanOrUndefined(event.marketingCampaign);
  };
  /**
   * s.charset
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var charset = function charset(_ref3) {
    var environment = _ref3.environment;
    return environment.charset;
  };
  /**
   * s.channel
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var channel = function channel(_ref4) {
    var data = _ref4.data;
    return data.locationSegments.slice(0, 3).join(':');
  };
  /**
   * s.currencyCode - Currency Code
   * Currency code of page that you are in, or of the instance
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var currencyCode = function currencyCode(_ref5) {
    var event = _ref5.event;

    if (!event.transaction) {
      return undefined;
    }

    return cleanNoCasing(event.transaction.currencyCode);
  };
  /**
   * s.pageName
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var pageName = function pageName(_ref6) {
    var data = _ref6.data;
    return data.locationSegments.join(':');
  };
  /**
   * s.purchaseID - Purchase ID
   * Transaction ID of the order
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var purchaseID = function purchaseID(_ref7) {
    var event = _ref7.event;
    var transactionType = event.transaction ? event.transaction.type : undefined;

    if (arrayIncludes(_purchaseTransactionTypes, transactionType)) {
      return clean(event.transaction.transactionID);
    }

    return undefined;
  };
  /**
   * s.transactionID - Transaction ID
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var transactionID = function transactionID(_ref8) {
    var event = _ref8.event;
    var transactionType = event.transaction ? event.transaction.type : undefined;

    if (arrayIncludes(_purchaseTransactionTypes, transactionType)) {
      return "pur:".concat(clean(event.transaction.transactionID));
    }

    return undefined;
  };

  var _serverMap = (_serverMap2 = {}, _defineProperty$c(_serverMap2, DEVICES$1.ANDROID, 'mobile app'), _defineProperty$c(_serverMap2, DEVICES$1.APPLE_TV, 'table top'), _defineProperty$c(_serverMap2, DEVICES$1.CHROMECAST, 'cast device'), _defineProperty$c(_serverMap2, DEVICES$1.IOS, 'mobile app'), _defineProperty$c(_serverMap2, DEVICES$1.MWEB, 'mweb'), _defineProperty$c(_serverMap2, DEVICES$1.PS3, 'console'), _defineProperty$c(_serverMap2, DEVICES$1.PS4, 'console'), _defineProperty$c(_serverMap2, DEVICES$1.PS4K, 'console'), _defineProperty$c(_serverMap2, DEVICES$1.TV, 'tv'), _defineProperty$c(_serverMap2, DEVICES$1.FIRE_TV, 'table top'), _defineProperty$c(_serverMap2, DEVICES$1.ROKU, 'table top'), _defineProperty$c(_serverMap2, DEVICES$1.WEB, 'web'), _serverMap2);
  /**
   * s.server
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var server = function server(_ref9) {
    var environment = _ref9.environment;
    return _serverMap[environment.deviceType] || 'unknown';
  };
  /**
   * s.ssl
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {boolean}
   */


  var ssl = function ssl(_ref10) {
    var config = _ref10.config;
    return config.useSSL !== false;
  };
  /**
   * s.timestamp
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var timestamp = function timestamp(_ref11) {
    var event = _ref11.event;
    return new Date(event.time - event.time % 1000).toISOString().replace('.000', '');
  };
  /**
   * s.trackingServer
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var trackingServer = function trackingServer(_ref12) {
    var config = _ref12.config;
    return config.trackingServer || AdobeConstants.DEFAULT_TRACKING_SERVER;
  };
  /**
   * s.trackingServerSecure
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var trackingServerSecure = function trackingServerSecure(_ref13) {
    var config = _ref13.config;
    return config.trackingServerSecure || AdobeConstants.DEFAULT_TRACKING_SERVER_SECURE;
  };
  /**
   * s.marketingCloudServer
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var marketingCloudServer = function marketingCloudServer(_ref14) {
    var config = _ref14.config;
    return config.marketingCloudServer || AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER;
  };
  /**
   * s.marketingCloudServerSecure
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {string}
   */


  var marketingCloudServerSecure = function marketingCloudServerSecure(_ref15) {
    var config = _ref15.config;
    return config.marketingCloudServerSecure || AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER_SECURE;
  };
  /**
   * s.visitorID
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var visitorId = function visitorId(_ref16) {
    var environment = _ref16.environment,
        event = _ref16.event;
    return environment.signedIn === true && environment.visitorId ? clean(environment.visitorId) : event.sessionId;
  };
  /**
   * s.list1 - Banners Report
   * Banner ID and metadata for impression and click-through
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var list1 = function list1(_ref17) {
    var event = _ref17.event,
        data = _ref17.data,
        logger = _ref17.logger;

    if (!(event.banners || event.banner)) {
      return undefined;
    }

    var banners = event.banners ? AdobeUtils.getBannersInfo(event) : AdobeUtils.getBannerInfo(event.banner);

    if (!banners) {
      return undefined;
    }

    if (event.bannerType && !_bannerTypeEventMap[event.bannerType]) {
      // Invalid Banner Type
      logger.warn('unknown banner type');
      return undefined;
    }

    if (event.type === 'PageView' || event.type === 'Impression' || event.type === 'VideoStream' || event.type === 'AdClick' || event.type === 'AdImpression' || event.type === 'AdVideoStream') {
      data.pushEvents(_bannerTypeEventMap[event.bannerType] || [5]);
    }

    return asAdobeList(banners);
  };
  /**
   * s.list2 - Recommendations Report
   * Recommendation ID and metadata for impressions and clickthrough
   *
   * @see jira:GHOST-485
   * @see slack:#valkyrie-telemetry 2017-10-20 https://snei.slack.com/archives/C1ZQLST5Y/p1508527085000135
   * @TODO: 2017-10-20
   *    Kevin Haslett: I know there is code today in GCT that allows us to pass in multiple recommendations and list2 is
   *      a comma separated strings of those recs
   *    Brian Au: Recommendation Impressions differ in handling and are always triggered per product
   *    Carlos Koch: [...] list2 takes an array of recommendations.  Is this spec we implemented in GCT 0.6.6 in error?
   *    Brian Au: Yes that is in error as recommendations should only apply to 1 product for recommendation impressions
   *       (as well as click). Its not set as an array today.
   *     https://docs.google.com/a/snei.sony.com/spreadsheets/d/174lATLspvc_EtdUygCe_kxxQft-J9HR82vvJW1qA5ts/edit?usp=sharing
   *     To explain further with Recommendations they apply to a specific product
   *       so we set the products variable which in terms of allocation would only work alongside a single value set
   *       within ListVariable2 (edited)
   *     Since Banners and Tiles exist as dimensional elements within the List Var1 or List Var 3 they do not have
   *       the same product dependency in terms of the tracking design
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var list2 = function list2(_ref18) {
    var event = _ref18.event,
        data = _ref18.data;

    if (!(event.recommendations || event.recommendation)) {
      return undefined;
    }

    var recs = event.recommendations ? AdobeUtils.getRecommendationsInfo(event) : AdobeUtils.getRecommendationInfo(event.recommendation);

    if (!recs) {
      return undefined;
    }

    if (event.type === 'PageView' || event.type === 'Impression') {
      // event96 - Recommendation Impression
      data.pushEvent(96);
    }

    return asAdobeList(recs);
  };
  /**
   * s.eVar1 - Page Name Conversion
   *
   * @return {?string}
   */


  var eVar1 = function eVar1() {
    return 'D=pageName';
  };
  /**
   * s.eVar2 - Account Locale - Territory - Country - Language Code - Zip
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar2 = function eVar2(context) {
    return evar2LocaleInformation(context);
  };
  /**
   * s.eVar3 - Authentication State
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar3 = function eVar3(_ref19) {
    var environment = _ref19.environment;
    return asEvar(environment.signedIn === true ? 'signed_in' : 'guest');
  };
  /**
   * A mapping of PS Plus types, to the plus user status they are valid for
   * (true means the type is valid for a plus user, false for a non-plus user).
   *
   * @type {{{plus: array.<string>, nonPlus: array.<string>}}}
   * @private
   */


  var _eVar4Map = {
    plus: [PSPLUS_TYPES$1.FREE_TRIAL, PSPLUS_TYPES$1.SUBSCRIPTION],
    nonplus: [PSPLUS_TYPES$1.LAPSED, PSPLUS_TYPES$1.NEVER_SUBSCRIBED]
  };
  /**
   * s.eVar4 - PS Plus Member Status (Visitor Segment)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  var eVar4 = function eVar4(_ref20) {
    var environment = _ref20.environment;
    var plus = environment.isPlusUser;
    var validatedPlusType = arrayIncludes(plus ? _eVar4Map.plus : _eVar4Map.nonplus, environment.plusUserType) ? environment.plusUserType : undefined; // If the user is not plus and has no type, the status is unknown.

    if (!plus && !validatedPlusType) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([plus ? 'plus member' : 'non plus member', validatedPlusType].filter(function (v) {
      return v;
    })));
  };
  /**
   * s.eVar5 - Demographic: Age
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar5 = function eVar5(_ref21) {
    var environment = _ref21.environment;
    return asEvar(environment && environment.userAge > 0 ? environment.userAge : undefined);
  };
  /**
   * s.eVar6 - Demographic: Gender
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var _eVar7OptinPrefixes = ['signin', 'sgnout', 'dnrhid'];
  /**
   * s.eVar7 - User privacy optout/optin status.
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  var eVar7 = function eVar7(_ref22) {
    var event = _ref22.event;
    var sessionId = event && event.sessionId || '';
    var status = 'optout';

    if (some_1(_eVar7OptinPrefixes, function (prefix) {
      return sessionId.startsWith(prefix);
    })) {
      status = 'optin';
    }

    return asEvar(status);
  };
  /**
   * s.eVar8 - Merchandising Category
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar8 = function eVar8(_ref23) {
    var event = _ref23.event;
    return asEvar(event.merchCategory);
  };
  /**
   *
   * @type {string[]}
   * @private
   */


  var _eVar9Types = [CLICK_TYPES$1.COMPLETE_STEP1_GRIEF_REPORT, CLICK_TYPES$1.COMPLETE_STEP2_GRIEF_REPORT, CLICK_TYPES$1.SEND_GRIEF_REPORT];
  /**
   * s.eVar9 - Grief Report Item:Reason
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  var eVar9 = function eVar9(_ref24) {
    var event = _ref24.event;

    if (!arrayIncludes(_eVar9Types, event.clickType)) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.griefReportItem, event.griefReportReason]));
  };
  /**
   * s.eVar10 - Page Type
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar10 = function eVar10(_ref25) {
    var event = _ref25.event;
    return asEvar(event.locationType);
  };
  /**
   * s.eVar11 - Name of Download:SKU
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar12 - Search Filter String
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar12 = function eVar12(_ref26) {
    var event = _ref26.event;

    if (!event.searchFilter) {
      return undefined;
    } // TODO: @carlos this need to be fixed at schema, we expect an array
    //       but the actual search can be either string or an array.


    return asEvar(asPipeDelimitedString(event.searchFilter));
  };
  /**
   * s.eVar13 - Sort String ([asc|desc] [price|name|release_date] : 'desc price')
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar13 = function eVar13(_ref27) {
    var event = _ref27.event;
    return asEvar(asPipeDelimitedString(event.sortOrder));
  };
  /**
   * Payment Method Map
   * TRUE: Use transaction.paymentMethod
   * string: Use the value given
   */


  var _eVar14Map = (_eVar14Map2 = {}, _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.FUNDING, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.FUNDING_3DS, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.PURCHASE, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.PURCHASE_3DS, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.BUY_NOW, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.BUY_NOW_3DS, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.PREORDER_PAY_NOW, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.MISC, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.VOUCHER_CASH, 'voucher'), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT, 'voucher'), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, true), _defineProperty$c(_eVar14Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, true), _eVar14Map2);
  /**
   * s.eVar14 - Payment Method
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar14 = function eVar14(_ref28) {
    var event = _ref28.event,
        data = _ref28.data;

    if (!isValidTransaction({
      event: event,
      data: data
    })) {
      return undefined;
    }

    var transaction = event.transaction;
    var paymentMethod = _eVar14Map[transaction.type];

    if (paymentMethod === true) {
      // eslint-disable-next-line prefer-destructuring
      paymentMethod = transaction.paymentMethod;

      if (!isValidPaymentMethod(paymentMethod)) {
        return undefined;
      }

      if (transaction.type === TRANSACTION_TYPES$1.MISC && transaction.useWallet === true) {
        paymentMethod = "wallet-".concat(paymentMethod);
      }
    }

    return asEvar(paymentMethod);
  };
  /**
   * Transaction Type Map
   * TRUE: Use transaction.type
   * string: Use value provided.
   * @private
   */


  var _eVar15Map = (_eVar15Map2 = {}, _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.FUNDING, true), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.FUNDING_3DS, true), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.PURCHASE, 'purchase'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.PURCHASE_3DS, 'purchase'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.BUY_NOW, 'buy now'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.BUY_NOW_3DS, 'buy now'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.PREORDER_PAY_NOW, 'preorder pay now'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.PREORDER_PAY_NOW_3DS, 'preorder pay now'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.VOUCHER_CASH, 'voucher:cash'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT, 'voucher:product'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_PERCENT_OFF, 'voucher:product percent off'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.VOUCHER_ORDER_PERCENT_OFF, 'voucher:order percent off'), _defineProperty$c(_eVar15Map2, TRANSACTION_TYPES$1.VOUCHER_PRODUCT_FIXED_AMOUNT_OFF, 'voucher:product fixed amount off'), _eVar15Map2);
  /**
   * s.eVar15 - Transaction Type [voucher:product, cash, pre-order, ...]
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar15 = function eVar15(_ref29) {
    var event = _ref29.event,
        data = _ref29.data;

    if (!isValidTransaction({
      event: event,
      data: data
    })) {
      return undefined;
    }

    var transactionType = _eVar15Map[event.transaction.type];

    if (transactionType === true) {
      transactionType = event.transaction.type.replace(' ', ':');
    }

    return asEvar(transactionType);
  };
  /**
   * s.eVar16 - Error Report:  [Error Type, Severity, Code, Description]
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar16 = function eVar16(_ref30) {
    var event = _ref30.event;
    return asEvar(asColonDelimitedString([event.error || '', event.severity || '', event.code || '', event.description || 'no description']));
  };
  /**
   * s.eVar17 - Search Term - User Entered Search Query
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar17 = function eVar17(_ref31) {
    var event = _ref31.event;
    return asEvar(event.searchTerm || undefined);
  };
  /**
   * s.eVar18 - Search Result : Selected Position : Search Count
   * Selected Item from a Search
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar18 = function eVar18(_ref32) {
    var event = _ref32.event;

    if (event.searchResult && event.searchPosition) {
      var searchData = [event.searchResult, event.searchPosition];

      if (event.searchCount) {
        searchData.push(event.searchCount);
      }

      return asEvar(asColonDelimitedString(searchData));
    }

    return undefined;
  };
  /**
   * s.eVar19 - Deprecated
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar20 - Product Engagement -  Name : Sku
   * Product View outside the purchasing flow, which includes name and SKU
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar20 = function eVar20(_ref33) {
    var event = _ref33.event;

    if (!event.productName) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.productName, event.productSku || 'no sku']));
  };
  /**
   * s.eVar21 - Univex Id
   *
   * Pulls univexId from the first experimentData object.
   * There is no support for multiple univexIds. Adding it would be a good idea if
   * we ever have a scenario where multiple univexIds are sent with a single event.
   * In the meantime, multiple univexIds (or a single univexId, in a non-first
   * experimentData slot) will trigger a warning.
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar21 = function eVar21(_ref34) {
    var event = _ref34.event;

    if (!event.experimentData || !isArray$1(event.experimentData)) {
      return undefined;
    }

    var univexIds = event.experimentData.map(function (_ref35) {
      var univexId = _ref35.univexId;
      return univexId;
    }).filter(function (value) {
      return !!value;
    }); // Send a maximum of 3 univexIds. Use '...' to show there were more.

    if (univexIds.length > 3) {
      univexIds.length = 3;
      univexIds[3] = '...';
    }

    return asEvar(asColonDelimitedString(univexIds));
  };
  /**
   * Map for eVar22
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var _eVar22Map = (_eVar22Map2 = {}, _defineProperty$c(_eVar22Map2, PRODUCT_TYPES$1.GAME_DIGITAL, 'game:digital'), _defineProperty$c(_eVar22Map2, PRODUCT_TYPES$1.GAME_DISC, 'game:disc'), _defineProperty$c(_eVar22Map2, PRODUCT_TYPES$1.GAME_PSNOW_PS3, 'game:psnowps3'), _defineProperty$c(_eVar22Map2, PRODUCT_TYPES$1.GAME_PSNOW_PS4, 'game:psnowps4'), _defineProperty$c(_eVar22Map2, PRODUCT_TYPES$1.APP, 'app:app'), _eVar22Map2);
  /**
   * s.eVar22 -- Product Classification 1
   * Set on Product Detail cover pages is available to the PC1 from the Product Catalog of the product
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar22 = function eVar22(_ref36) {
    var event = _ref36.event,
        logger = _ref36.logger;

    if (!event.productClassification1 && !event.productType) {
      return undefined;
    }

    if (!event.productClassification1 && event.productType && !_eVar22Map[event.productType]) {
      logger.warning("Unsupported product type value \"".concat(event.productType, "\""));
      return undefined;
    }

    return asEvar(event.productClassification1 || _eVar22Map[event.productType]);
  };
  /**
   * s.eVar23 - Product Classification 2
   * Set on Product Detail cover pages is available to the PC2 from the Product Catalog of the product
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar23 = function eVar23(_ref37) {
    var event = _ref37.event;
    return asEvar(event.productClassification2 || (_eVar22Map[event.productType] ? 'not configured' : undefined));
  };
  /**
   * s.eVar24 - Product Classification 3
   * Set on Product Detail cover pages is available to the PC3 from the Product Catalog of the product
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar24 = function eVar24(_ref38) {
    var event = _ref38.event;
    return asEvar(event.productClassification3 || (_eVar22Map[event.productType] ? 'not configured' : undefined));
  };
  /**
   * s.eVar25 - Product: Type
   * Set on the Product Detail Pages to designation on Product Type
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar25 = function eVar25(_ref39) {
    var event = _ref39.event;
    return asEvar(event.productType);
  };
  /**
   * s.eVar26 - Genre
   * Genre of the product or the media interacted with
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar26 = function eVar26(_ref40) {
    var event = _ref40.event;

    if (!event.genre || !event.maturity) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.genre, event.maturity]));
  };
  /**
   * s.eVar27 - Release Date
   * This is the date that the content was released
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar27 = function eVar27(_ref41) {
    var event = _ref41.event;

    // What non-string, non-falsy values are we getting here? Why don't we have
    // a test for that behavior? Same for displayPrice below.
    if (!event.releaseDate || !isString$4(event.releaseDate)) {
      return undefined;
    }

    return asEvar(event.releaseDate);
  };
  /**
   * s.eVar28 - Product: Display Price
   * Display price merchandised no the store front
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar28 = function eVar28(_ref42) {
    var event = _ref42.event;

    if (!event.displayPrice || !isString$4(event.displayPrice)) {
      return undefined;
    }

    return asEvar(event.displayPrice, {
      cleaner: cleanEvarAllowingCurrency
    });
  };
  /**
   * s.eVar29 - Recommendation: Anchor Product Name
   * Recommendation Anchor Product from which recommendations are given
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar29 = function eVar29(_ref43) {
    var event = _ref43.event;
    return asEvar(event.recAnchor);
  };
  /**
   * s.eVar30 - Media: Publisher
   * The publisher or distributor of the content
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar30 = function eVar30(_ref44) {
    var event = _ref44.event;
    return asEvar(event.publisher);
  };
  /**
   * s.eVar31 - Merch: Finding Method
   * Mehtod used to find a product (search, browse, grid, ...)
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar31 = function eVar31(_ref45) {
    var event = _ref45.event;
    return asEvar(event.findingMethod);
  };
  /**
   * s.eVar32 - PSTP Campaign: Reward
   * Promotional Strike-Through Pricing (campaign, spring sale, reward, amount off, ...)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar32 = function eVar32(_ref46) {
    var event = _ref46.event;
    return asEvar(event.pstpCampaign);
  };
  /**
   * s.eVar33 - Recommendation: Campaign ID
   * Recommendation Campaign ID (context:algorithm)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar33 = function eVar33(_ref47) {
    var event = _ref47.event;
    return asEvar(cleanColonDelimitedList(event.recCampaign));
  };
  /**
   * s.eVar34 - Deprecated
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var _eVar35Map = (_eVar35Map2 = {}, _defineProperty$c(_eVar35Map2, VIDEO_TYPES$1.OTHER, 'other video type'), _defineProperty$c(_eVar35Map2, VIDEO_TYPES$1.NONE, 'no video type'), _eVar35Map2);
  /**
   * s.eVar35 - Video: Show Type
   * Type of Show (Sport, TV Show, News, ...)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar35 = function eVar35(_ref48) {
    var event = _ref48.event;

    if (!isValidVideoType(event.videoType)) {
      return undefined;
    }

    var videoType = _eVar35Map[event.videoType] || event.videoType;
    return asEvar(videoType.replace(/_/g, ' '));
  };

  var _eVar36Map = (_eVar36Map2 = {}, _defineProperty$c(_eVar36Map2, VIDEO_FORMATS$1.TRAILER, 'short form'), _defineProperty$c(_eVar36Map2, VIDEO_FORMATS$1.PREVIEW, 'short form'), _defineProperty$c(_eVar36Map2, VIDEO_FORMATS$1.FULL, 'long form'), _defineProperty$c(_eVar36Map2, VIDEO_FORMATS$1.LIVE, 'live'), _eVar36Map2);
  /**
   * s.eVar36 - Video Format
   * Short  Form, Long Form Video Designation
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar36 = function eVar36(_ref49) {
    var event = _ref49.event;
    return asEvar(_eVar36Map[event.videoFormat]);
  };
  /**
   * s.eVar37 - Error: API URL
   * API URL Associated with the error
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar37 = function eVar37(_ref50) {
    var event = _ref50.event;
    return asEvar((event.apiUrl || 'no url').replace(/[:/]/g, '_'));
  };
  /**
   * s.eVar38 - Video Network
   * Collects name of the network of the video being viewed.
   * Takes all the channels we consume and franchise them.
   * Vue Only
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar38 = function eVar38(_ref51) {
    var event = _ref51.event;
    return asEvar(event.networkName);
  };
  /**
   * s.eVar39 - Load Time
   * Content or page load time in ms
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar39 = function eVar39(_ref52) {
    var event = _ref52.event,
        logger = _ref52.logger,
        data = _ref52.data;

    if (!event.loadTime) {
      return undefined;
    }

    if (event.loadTime < 0) {
      logger.warning('Load time cannot be negative or zero');
      return undefined;
    }

    var loadTimeBucket; // group time into buckets

    if (event.loadTime >= 10000) {
      loadTimeBucket = '10000+';
    } else {
      var roundedLoadTime = Math.floor(event.loadTime / 100);
      loadTimeBucket = "".concat(roundedLoadTime.toString(), "00-").concat(roundedLoadTime.toString(), "99");
    } // event119 - Time Spent Page Load


    data.pushEvent({
      id: 119,
      value: event.loadTime
    }); // event180 - Page Loaded

    data.pushEvent(180);
    return asEvar(loadTimeBucket);
  };
  /**
   * s.eVar40 - Sony Internal Tracking Code (SMCID)
   * Tracking code used to tie one internal property to another
   * Track internal PSN movements
   * Entry point in Japan
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar40 = function eVar40(_ref53) {
    var data = _ref53.data;
    return asEvar(cleanColonDelimitedListStripEmpty(data.referrerLocation));
  };
  /**
   * s.eVar41 - Banner Selected
   * Click and downstream attribution for a bonner that has been selected with visit expiration
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar41 = function eVar41(context) {
    return list1(context);
  };
  /**
   * s.eVar42 - Marketing Recommendation Selected
   * Set upon click of a recommendation
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar43 - Marketing Suggested Campaign
   * Set after click of a search results campaign
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar43 = function eVar43(_ref54) {
    var event = _ref54.event;
    return event.searchCampaign ? eVar18({
      event: event
    }) : undefined;
  };
  /**
   * s.eVar44 - Marketing Promoted Campaign
   * Under deprecation Review
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar45 - Sony Internal Tracking Code (SMCID)
   * Tracking code used to tie one internal property to another
   * Track internal PSN movements
   * Entry point in Japan
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar45 = function eVar45(_ref55) {
    var data = _ref55.data;
    return asEvar(data.referrerLocation ? 'D=v40' : undefined, {
      allowUppercase: true
    });
  };
  /**
   * s.eVar46 - Social Media Name
   * Collects the social media network and teh thing being socialized
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar46 = function eVar46(_ref56) {
    var event = _ref56.event;
    return asEvar(event.recommendationSrc || undefined);
  };
  /**
   * s.eVar47 - Device ID / Type
   * The ID of the box (PS4, PS3, ...) that you are on
   * Use eVar47 to capture Device ID and Type
   * PDC uses this to capture the type of device that is accessing PDC
   * Stores, Big 3, Mobile Apps, and Vue do not use this currently
   * This will allow SIE to have UserAgent (eVar71) and Device Type/ID (eVar47) captured in to their own variables
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar47 = function eVar47(_ref57) {
    var environment = _ref57.environment,
        event = _ref57.event;
    return asEvar(environment.deviceId || event.sessionId);
  };
  /**
   * s.eVar48 - Error Location
   * The location that the error actually occurred
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar48 = function eVar48(_ref58) {
    var data = _ref58.data;
    return asEvar(asColonDelimitedString(data.locationSegments));
  };

  var _eVar49StartUp = function _eVar49StartUp(context) {
    var event = context.event,
        environment = context.environment,
        data = context.data;
    var message;

    switch (event.startupType) {
      case STARTUP_TYPES$1.APP:
        message = "startup app ".concat(asColonDelimitedString([environment.appName, event.startupContext]));
        break;

      case STARTUP_TYPES$1.PAGE:
        message = "startup page ".concat(asColonDelimitedString(data.locationSegments));
        break;

      default:
        message = '';
    }

    return asEvar(message.replace(/_/g, ' '));
  };

  var _playtimeString = function _playtimeString(event) {
    if (event.isPlaytimeUnlimited) {
      return 'playtime unlimited';
    }

    if (event.playtimeDurationChange > 0) {
      return 'playtime increased';
    }

    if (event.playtimeDurationChange < 0) {
      return 'playtime decreased';
    }

    return 'playtime not changed';
  };

  var _eVar49Click = function _eVar49Click(_ref59) {
    var event = _ref59.event;

    if (event.clickType === 'change playtime limit') {
      return [event.clickType, event.playtimeAgeGroup, _playtimeString(event)].join(':');
    }

    var clickMetadataArray = event.clickMetadata ? event.clickMetadata.split(':') : [];
    return asEvar(asColonDelimitedString([event.clickType].concat(clickMetadataArray)));
  }; // eslint-disable-next-line arrow-body-style


  var _eVar49VideoStream = function _eVar49VideoStream(_ref60) {
    var event = _ref60.event;
    return asEvar("".concat(event.streamType, " ").concat(event.videoAction).replace(/_/g, ' '));
  };
  /**
   * s.eVar49 - User Engagement or Action
   * User Engagements with the Environment.
   * Contents will vary between reports.
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar49 = function eVar49(context) {
    var event = context.event;

    switch (event.type) {
      case 'Startup':
        return _eVar49StartUp(context);

      case 'VideoStream':
        return _eVar49VideoStream(context);

      case 'Click':
        return _eVar49Click(context);

      default:
        return undefined;
    }
  };
  /**
   * s.eVar50 - Sub Section 1
   * Under Deprecation Review
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar50 = function eVar50(_ref61) {
    var data = _ref61.data;
    return asEvar(asColonDelimitedString(data.locationSegments.slice(0, 4)));
  };
  /**
   * s.eVar51 - Sub Section 2
   * Under Deprecation Review
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar51 = function eVar51(_ref62) {
    var data = _ref62.data;
    return asEvar(asColonDelimitedString(data.locationSegments.slice(0, 5)));
  };
  /**
   * s.eVar52 - PDC: Sub Section 3 | SNE: Business Category
   * Under Deprecation Review
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar52 = function eVar52(_ref63) {
    var data = _ref63.data;
    return asEvar(asColonDelimitedString(data.locationSegments.slice(0, 6)));
  };
  /**
   * s.eVar53 - PDC: Sub Section 4 | SNE: Display Name
   * Under Deprecation Review
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar53 = function eVar53(_ref64) {
    var data = _ref64.data;
    return asEvar(asColonDelimitedString(data.locationSegments.slice(0, 7)));
  };
  /**
   * s.eVar54 - Deprecated
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar55 - Constellation ID
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar55 = function eVar55(_ref65) {
    var environment = _ref65.environment;
    return asEvar(environment.constellationId);
  };
  /**
   * s.eVar56 - Content: Detail Name
   * Identifies the detailed product or content when a user is on a PDP
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar56 = function eVar56(_ref66) {
    var event = _ref66.event;
    return asEvar(event.contentDetail);
  };
  /**
   * s.eVar57 - Purchase Order ID
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * Map for eVar58
   *
   * @type {Object.<string, number>}
   * @return {?string}
   */


  var _eVar58Map = (_eVar58Map2 = {}, _defineProperty$c(_eVar58Map2, PSNOW_TYPES$1.TRIAL, 'trial subscriber'), _defineProperty$c(_eVar58Map2, PSNOW_TYPES$1.SUBSCRIPTION, 'subscriber'), _defineProperty$c(_eVar58Map2, PSNOW_TYPES$1.NOT_SUBSCRIBED, 'non-subscriber'), _eVar58Map2);
  /**
   * s.eVar58 - PS Now Membership Type will have 3 parts
   * Subscription Status: Subscriber, trial user, nonsubscriber.
   * Subscription Sku: Sku purchased for PS Now subscription
   * isHomeShare: tracks if the user is using HomeShare to connect to PS Now
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar58 = function eVar58(_ref67) {
    var environment = _ref67.environment,
        logger = _ref67.logger,
        event = _ref67.event;
    var value = _eVar58Map[environment.psnowMembershipType]; // undefined is OK, but defined types should be in the map.

    if (!value && typeof environment.psnowMembershipType !== 'undefined') {
      logger.warning('unknown PS Now membership type', environment.psnowMembershipType);
      return undefined;
    }

    if (!value) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([value, event.subscriptionSku ? "".concat(event.subscriptionSku) : 'empty', event.isHomeshare ? 'is homeshare' : 'not homeshare'].filter(function (v) {
      return v;
    })));
  };
  /**
   * s.eVar59 - Deprecated
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar60 - EA Access Member Status (v60)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar60 = function eVar60(_ref68) {
    var event = _ref68.event;
    return asEvar(event.eaMemberAccess);
  };
  /**
   * s.eVar61 - Video Type
   * Video Stream Type
   * Currently used by Vue
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar61 = function eVar61(_ref69) {
    var event = _ref69.event;

    if (!isValidStreamType(event.streamType)) {
      return undefined;
    }

    if (event.streamType === STREAM_TYPES$1.NONE) {
      return 'no stream type';
    }

    return asEvar("".concat(event.streamType, " video"));
  };
  /**
   * s.eVar62 - Video Id
   * Unique ID for Video
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar62 = function eVar62(_ref70) {
    var event = _ref70.event;
    return asEvar(event.videoId);
  };
  /**
   * s.eVar63 - Video Title, Episode Name, Season Number, Episode Number, Format
   * Specific Show being Played
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar63 = function eVar63(_ref71) {
    var event = _ref71.event;

    if (!event.videoTitle) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.videoTitle, event.videoEpisodeName || 'no title', event.videoSeasonNum || 'no season', event.videoEpisodeNum || 'no episode', eVar36({
      event: event
    }) || 'no format']));
  };
  /**
   * s.eVar64 - Player ID
   * Id of the player playing the content.
   * Format will always be '[playerId]:[windowMode]:[playerPosition]:[playerSoundEnabled]'
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar64 = function eVar64(_ref72) {
    var event = _ref72.event;

    if (!event.playerId) {
      return undefined;
    }

    var soundEnabled;

    if (event.playerSoundEnabled) {
      soundEnabled = 'on';
    } else {
      soundEnabled = 'off';
    }

    return asEvar(asColonDelimitedString([event.playerId, isValidWindowMode(event.windowMode) ? event.windowMode : 'empty', !isUndefined_1(event.playerPosition) ? "".concat(event.playerPosition) : 'empty', !isUndefined_1(event.playerSoundEnabled) ? soundEnabled : 'empty'].filter(function (v) {
      return v;
    })));
  };
  /**
   * s.eVar66 - Form : Name : Step
   * Tracks progress through forms or flows
   *
   * - Requires Valid Form Action
   * - Requires Form Location
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar66 = function eVar66(_ref73) {
    var event = _ref73.event;

    if (!event.formAction || !isValidFormAction(event.formAction)) {
      return undefined;
    }

    return asEvar(cleanColonDelimitedList(event.formLocation));
  };
  /**
   * s.eVar67 - Community
   * Community Meta data for community creation
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar67 = function eVar67(_ref74) {
    var event = _ref74.event;

    if (!event.community) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.community.id, event.community.name, event.community.permissions, event.community.titleId, event.community.productTitle, event.community.timeZone, event.community.language]));
  };
  /**
   * s.eVar68 - Page URL
   * URI of the Page or Screen
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar68 = function eVar68(_ref75) {
    var event = _ref75.event;
    return asEvar(event.url, {
      allowUppercase: true,
      cleaner: cleanEvarAllowingUrlChars
    });
  };
  /**
   * s.eVar69 - Email Recipient ID
   * Email Campaigns - is the exact target recipient ID (ET_RID)
   * This allows us to back into the exact target data (LIC Emails; who opened)
   *
   * Requires emailCampaign - see eVar76
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar69 = function eVar69(_ref76) {
    var event = _ref76.event;

    if (!event.emailCampaign) {
      return undefined;
    }

    return asEvar(event.emailRecipient);
  };
  /**
   * s.eVar70 - Promo Video URL
   * The URL representing the Stream or File being played
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar70 = function eVar70(_ref77) {
    var event = _ref77.event;

    if (!event.videoUrl) {
      return undefined;
    }

    return asEvar(event.videoUrl, {
      allowUppercase: true,
      cleaner: cleanEvarAllowingUrlChars
    });
  };
  /**
   * s.eVar71 - Technical: User Agent
   * User agent string provided by the web browser
   *
   * @return {?string}
   */


  var eVar71 = function eVar71() {
    // this value can be undefined, thus it cannot be passed into an is* function
    // eslint-disable-next-line no-undef
    if ((typeof navigator === "undefined" ? "undefined" : _typeof$d(navigator)) !== 'object' || !navigator.userAgent) {
      return undefined;
    } // eslint-disable-next-line no-undef


    return asEvar(navigator.userAgent, {
      allowUppercase: true
    });
  };
  /**
   * s.eVar72 - Storefront Flag
   * PSN Location Flag
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar72 = function eVar72(_ref78) {
    var environment = _ref78.environment,
        data = _ref78.data;
    var locationParts = data.locationSegments.slice(0, 2);

    if (locationParts[0] === 'ps4' && environment.deviceType === DEVICES$1.PS4K) {
      locationParts[0] = 'ps4k';
    }

    return asEvar(asColonDelimitedString(locationParts));
  };
  /**
   * s.eVar73 - Store App Version
   * Release Version of the application
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   *
   * @return {?string}
   */


  var _eVar74Override = function _eVar74Override(event) {
    return Boolean(event.type === 'UserFacingError' && event.overrideAppName && event.overrideBuildVersion);
  };

  var _eVar74AppName = function _eVar74AppName(_ref79) {
    var event = _ref79.event,
        environment = _ref79.environment;
    return _eVar74Override(event) ? event.overrideAppName : environment.appName;
  };

  var _eVar74BuildVersion = function _eVar74BuildVersion(_ref80) {
    var event = _ref80.event,
        environment = _ref80.environment;
    return _eVar74Override(event) ? event.overrideBuildVersion : environment.buildVersion;
  };
  /**
   * s.eVar74 - Build ID
   * Internal build number of the application
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar74 = function eVar74(context) {
    var event = context.event,
        sdkVersion = context.sdkVersion,
        gctVersion = context.gctVersion; // TODO: Why is UserFacingError not have GCTV or SDKV? -- It's a bug.

    var versionPieces = _eVar74Override(event) ? [] : ["gct_v".concat(gctVersion), sdkVersion];
    return asEvar(asColonDelimitedString([_eVar74AppName(context), _eVar74BuildVersion(context)].concat(versionPieces)));
  };
  /**
   * s.eVar75 - Sony Visitor ID
   * Hashed PSN Visitor ID
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar75 = function eVar75(_ref81) {
    var environment = _ref81.environment,
        event = _ref81.event;

    if (environment.signedIn !== true) {
      return undefined;
    }

    return asEvar(environment.visitorId || event.sessionId);
  };
  /**
   * s.eVar76 - Mail Client Campaign ID
   * Email Campaigns - is the exact target campaign id (ET_CID)
   *
   * Requires email recipient to be set
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar76 = function eVar76(_ref82) {
    var event = _ref82.event;

    if (!event.emailCampaign || !event.emailRecipient) {
      return undefined;
    }

    return asEvar(event.emailCampaign);
  };
  /**
   * s.eVar77 - 30-day External Tracking Code
   * Tracking code to be used to measure external marketing campaigns based on a 30 day expiration
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar77 = function eVar77(_ref83) {
    var event = _ref83.event;
    return asEvar(event.marketingCampaign);
  };
  /**
   * s.eVar78 - User Ad Personalization Setting
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar78 = function eVar78(_ref84) {
    var event = _ref84.event;

    // ClickType = ManagePersonalizationSettings && both allowTracking and allowPersonalization is defined:
    if (event.clickType !== CLICK_TYPES$1.MANAGE_PERSONALIZATION_SETTINGS) {
      return undefined;
    }

    if (event.allowPersonalizedRecs === undefined || event.allowPersonalizedAds === undefined) {
      return undefined;
    }

    return asEvar(asColonDelimitedString([event.allowPersonalizedRecs ? PURCHASE_REC$1.ALLOW : PURCHASE_REC$1.DISALLOW, event.allowPersonalizedAds ? PERSONALIZED_ADS$1.ALLOW : PERSONALIZED_ADS$1.DISALLOW]));
  };
  /**
   * s.eVar79 - VSH 3.5 Nav
   * Hashed open PSID sent by console
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar80 - PS+ user gene
   * Gene:PS+ Status:Data Science Propensity:Source
   * Source: Actual = Provided by Genome
   *         Derived = Kamaji created based on entitlement
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar80 = function eVar80(_ref85) {
    var event = _ref85.event;
    return asEvar(event.userGenes);
  };
  /**
   * s.eVar81 - VSH 3.5 Nav - Log Format Version (fv)
   * s.eVar82 - VSH 3.5 Nav - System Software Version (c)
   * s.eVar83 - VSH 3.5 Nav - Product Code, Sub Code, CEX F lag (p)
   * s.eVar84 - VSH 3.5 Nav - Config File Version (cv)
   * s.eVar85 - VSH 3.5 Nav - QA Flag (q)
   * s.eVar86 - VSH 3.5 Nav - Hashed PSN ID sent by user
   * s.eVar87 - VSH 3.5 Nav - Type of event sent by system logger
   * s.eVar88 - VSH 3.5 Nav - Event Sub-type sent by system logger
   * s.eVar89 - VSH 3.5 Nav - Scene ID used in transition events
   * s.eVar90 - VSH 3.5 Nav - Title ID of transitioned scene
   * s.eVar91 - VSH 3.5 Nav - Widget ID, Key ID, or Popup ID for scene action events
   * s.eVar92 - VSH 3.5 Nav - Reserved for system logger
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar93 - Page Name of Banner Location
   * New Custom Conversion dimension for Page name of banner loctation that will be set upon every
   * AA tracking call where upon banner metrics are set in conjunction
   * with list variable 1: ad supply view, paid banner loaded, banner viewable impression
   * banner video viewable impression, banner click
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar93 = function eVar93(_ref86) {
    var event = _ref86.event,
        data = _ref86.data;

    if (!(event.banners && event.banners.length) && !event.banner) {
      return undefined;
    }

    if (event.bannerType && !_bannerTypeEventMap[event.bannerType]) {
      return undefined;
    }

    return asEvar(asColonDelimitedString(data.locationSegments));
  };
  /**
   * s.eVar94 - Page Deep Link
   * Page deep link passed within console, for pages tracked by GCT.
   * This will be separate from eVar68 which only tracks the HTML style URL (g)
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar94 = function eVar94(_ref87) {
    var event = _ref87.event;
    return asEvar(event.deeplink, {
      allowUppercase: true,
      cleaner: cleanEvarAllowingUrlChars
    });
  };
  /**
   * s.eVar95 - Page Load
   * Page load metadata for page load performance evaluation
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar95 = function eVar95(_ref88) {
    var data = _ref88.data,
        event = _ref88.event,
        environment = _ref88.environment;
    return asEvar(asColonDelimitedString([environment.networkType || 'no conn type', event.bootInfo || 'no boot type', event.dataSizeGroup || 'no data size', environment.platformVersion || 'no platform'].concat(data.locationSegments)));
  };
  /**
   * s.eVar96 - Developer Telemetry
   * Developer defined measurement of timers such as load time
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */

  /**
   * s.eVar97 - Custom Conversion indicator
   * Consists of:
   * [viewId1]-[viewId2]-[viewIdX]:[viewCollectionId]:[experienceId]
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar97 = function eVar97(_ref89) {
    var event = _ref89.event;

    // EMS page views are required to have an experienceId, and at least one
    // entry in viewIds. However, other clients (i.e. Macross) might not set
    // these fields. viewCollectionId is always optional.
    if (!event.viewIds || !event.viewIds.length || typeof event.experienceId === 'undefined') {
      return undefined;
    }

    return asEvar(asColonDelimitedString([asHyphenDelimitedString(event.viewIds), event.viewCollectionId || 'empty', event.experienceId]), {
      delimiters: [':', '-']
    });
  };
  /**
   * s.eVar99 - Tiles Selected
   * Click and downstream attribution for a tile that has been selected with visit expiration
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar99 = function eVar99(_ref90) {
    var event = _ref90.event;

    if (event.tile) {
      return AdobeUtils.getTileInfo(event.tile);
    }

    return AdobeUtils.getTilesInfo(event) || undefined;
  };
  /**
   * s.eVar100 - Experiment Data
   * Experiment data for A/B testing. This is an array, each element of the array is an object with 2 properties
   *   {
   *     experimentId "<string>", this is a string representing the name or ID of the experiment (such as "super_checkout_flow")
   *     variantId "<string>" this is a string representing the variant ID within the experiment (such as "A" or "1")
   *   }
   * Experiment data objects could also include a "univexId" instead (see eVar21).
   * Behavior when experimentId is present, but not variantId, or vice-versa, has
   * not been formally defined and the current behavior is a best-effort guess.
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar100 = function eVar100(_ref91) {
    var event = _ref91.event;

    if (!event.experimentData || !isArray$1(event.experimentData) || !event.experimentData.some(function (exp) {
      return exp.experimentId || exp.variantId;
    })) {
      return undefined;
    } // Objects in experimentData might not have experimentId or variantId (e.g.,
    // because they are relaying univexId instead). Filter the list before doing
    // the string construction.


    return event.experimentData.filter(function (exp) {
      return exp && (!!exp.experimentId || !!exp.variantId);
    }).map(function (exp) {
      return "".concat(exp.experimentId, ":").concat(exp.variantId);
    }).join(',');
  };
  /**
   * s.eVar101 - Tournament Detail
   * Tournament details from competitive gaming platform
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar101 = function eVar101(_ref92) {
    var event = _ref92.event,
        data = _ref92.data;

    if (!event.tournamentName) {
      return undefined;
    }

    var cleanStr = function cleanStr(str) {
      return Utils$1.cleanUpString(str, AdobeConstants.INVALID_COMMA_REGEX);
    }; // event346 - Tournament Players Signed Up


    data.pushEvent({
      id: 346,
      value: event.tournamentPlayersSignedUp
    });
    return asEvar(asColonDelimitedString([cleanStr(event.tournamentName).substr(0, 50), event.tournamentFormat || 'no format', event.tournamentStageInfo || 'no stage info', event.tournamentPrizeInfo || 'no prize info', event.tournamentStartTime ? event.tournamentStartTime.toISOString().substr(0, 10) : 'no start time', event.tournamentVideoType || 'no video', event.tournamentType || 'no type', event.tournamentSponsors ? cleanStr(asPipeDelimitedString(event.tournamentSponsors)).substr(0, 50) : 'no sponsors']));
  };
  /**
   * s.eVar102 - Maturity Rating
   * Rating system - rating
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var eVar102 = function eVar102(_ref93) {
    var event = _ref93.event;
    return asEvar(event.maturityRating);
  };
  /**
   * s.hier1 - Alias to Page Name
   *
   * @return {?string}
   */


  var hier1 = function hier1() {
    return 'D=pageName';
  };

  var extractField = function extractField(delimiter, index) {
    return function (value) {
      return typeof value === 'string' ? value.split(delimiter)[index] : undefined;
    };
  };
  /**
   * s.prop5 - filter value only, as a colon-delimited list. This prop
   * has special processing on the Adobe side, which is why we use this seemingly-
   * redundant field to capture almost the same data which is already populated in eVar12.
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var prop5 = function prop5(_ref94) {
    var event = _ref94.event;

    if (!event.searchFilter) {
      return undefined;
    }

    return asEvar(asColonDelimitedString(event.searchFilter.map(extractField(':', 1))));
  };
  /**
   * s.prop8 - URL/Domain in primary url preview display
   * @param {adobe~BuildPayloadContext} context
   * @return {?integer}
   */


  var prop8 = function prop8(_ref95) {
    var event = _ref95.event;

    if (!event.textPostUrlDomain) {
      return undefined;
    }

    return asEvar(event.textPostUrlDomain);
  };
  /**
   * s.prop6 - sort direction only, as a colon-delimited list. This prop
   * has special processing on the Adobe side, which is why we use this seemingly-
   * redundant field to capture almost same data which is already populated in eVar13.
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var prop6 = function prop6(_ref96) {
    var event = _ref96.event;

    if (!event.sortOrder) {
      return undefined;
    }

    return asEvar(asColonDelimitedString(event.sortOrder.map(extractField(':', 1))));
  };
  /**
   * s.prop45 - Alias to Referrer Location
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var prop45 = function prop45(_ref97) {
    var data = _ref97.data;
    return data.referrerLocation ? 'D=v40' : undefined;
  };
  /**
   * s.prop69 - Timestamp
   *
   * @param {adobe~BuildPayloadContext} context
   * @return {?string}
   */


  var prop69 = function prop69(_ref98) {
    var event = _ref98.event;
    return event.time.toISOString();
  };
  /**
   * Default Property Set
   * These are set for all Event Types
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */


  var defaultProperties$1 = {
    account: account,
    charset: charset,
    pageURL: pageUrl,
    referrer: referrer,
    trackingServer: trackingServer,
    trackingServerSecure: trackingServerSecure,
    marketingCloudServer: marketingCloudServer,
    marketingCloudServerSecure: marketingCloudServerSecure,
    ssl: ssl,
    timestamp: timestamp,
    visitorID: visitorId,
    eVar7: eVar7,
    // Privacy opt-in or opt-out status
    eVar21: eVar21,
    // Univex Id (projectId.outcomeName.experimentName.experimentSeq.variantName.status)
    eVar47: eVar47,
    // Device ID
    eVar55: eVar55,
    // Constellation ID
    eVar68: eVar68,
    // Page URL
    eVar71: eVar71,
    // User Agent
    eVar72: eVar72,
    // PSN Location
    eVar74: eVar74,
    // Build ID
    eVar75: eVar75,
    // Hashed PSN Visitor ID
    eVar94: eVar94,
    // Page Deep Link,
    eVar100: eVar100,
    // Experiment Data
    prop69: prop69 // Timestamp

  };
  var Properties = {};
  /**
   * Property Set for Event.type="Click"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.Click = {
    currencyCode: currencyCode,
    products: products,
    purchaseID: purchaseID,
    transactionID: transactionID,
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar8: eVar8,
    // Merch Category
    eVar9: eVar9,
    // Grief Report Item : Reason
    eVar12: eVar12,
    // Search Filter(s)
    eVar13: eVar13,
    // Sort Order
    eVar14: eVar14,
    // Transaction Payment Method
    eVar15: eVar15,
    // Transaction Type
    eVar17: eVar17,
    // Search Term
    eVar18: eVar18,
    // Search Result : Search Position : Search Count
    eVar20: eVar20,
    // Product Name : Product Sku
    eVar22: eVar22,
    // Product Classification 1 || Product Type
    eVar23: eVar23,
    // Product Classification 2
    eVar24: eVar24,
    // Product Classification 3
    eVar25: eVar25,
    // Product Type
    eVar26: eVar26,
    // Genre : Maturity
    eVar27: eVar27,
    // Release Date
    eVar28: eVar28,
    // Display Price
    eVar29: eVar29,
    // Recommendation Anchor
    eVar30: eVar30,
    // Publisher
    eVar31: eVar31,
    // Finding Method
    eVar32: eVar32,
    // PSTP Campaign Category
    eVar33: eVar33,
    // Recommendation Campaign
    eVar35: eVar35,
    // Video Type
    eVar36: eVar36,
    // Video Format
    eVar38: eVar38,
    // Network Name
    eVar41: eVar41,
    // = list1 (banners)
    eVar43: eVar43,
    // = eVar18 if Search Campaign
    eVar46: eVar46,
    // Recommendation Source
    eVar49: eVar49,
    // Startup Type | VideoStreamType + VideoAction | Click Type
    eVar56: eVar56,
    // Content Detail
    eVar58: eVar58,
    // PS Now Membership Type
    eVar60: eVar60,
    // EA Access Member Status
    eVar61: eVar61,
    // Stream Type
    eVar62: eVar62,
    // Video Id
    eVar63: eVar63,
    // Video Title : Episode Name : Season Num : Episode Num : Video Format
    eVar64: eVar64,
    // Player Id
    eVar66: eVar66,
    // Form Location
    eVar78: eVar78,
    // Privacy Settings = Tracking : Personalization
    eVar93: eVar93,
    // == Location (If Banners)
    eVar99: eVar99,
    // Tiles (~= list3; no fallback to related content)
    list1: list1,
    // Banners
    list2: list2,
    // Recommendations
    list3: list3,
    // Tiles
    prop5: prop5,
    prop6: prop6,
    prop8: prop8,
    // Events
    clickTypeEvents: clickTypeEvents,
    // Populate Events based on click type
    clickEvents: clickEvents,
    // Populate Events for Click
    formEvents: formEvents,
    // Populate Form Events
    transactionEvents: transactionEvents,
    // Populate Transaction Events
    psnowEvents: psnowEvents,
    // Populate PS Now membership events
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="PageView"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.PageView = {
    campaign: campaign,
    channel: channel,
    currencyCode: currencyCode,
    pageName: pageName,
    products: products,
    purchaseID: purchaseID,
    server: server,
    transactionID: transactionID,
    eVar1: eVar1,
    // alias: Page Name
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar8: eVar8,
    // Merch Category
    eVar10: eVar10,
    // Page Type
    eVar14: eVar14,
    // Transaction Payment Method
    eVar15: eVar15,
    // Transaction Type
    eVar17: eVar17,
    // Search Term
    eVar18: eVar18,
    // Search Result : Search Position : Search Count
    eVar20: eVar20,
    // Product Name : Product Sku
    eVar22: eVar22,
    // Product Classification 1 || Product Type
    eVar23: eVar23,
    // Product Classification 2
    eVar24: eVar24,
    // Product Classification 3
    eVar25: eVar25,
    // Product Type
    eVar26: eVar26,
    // Genre : Maturity
    eVar27: eVar27,
    // Release Date
    eVar28: eVar28,
    // Display Price
    eVar29: eVar29,
    // Recommendation Anchor
    eVar30: eVar30,
    // Publisher
    eVar31: eVar31,
    // Finding Method
    eVar32: eVar32,
    // PSTP Campaign Category
    eVar33: eVar33,
    // Recommendation Campaign
    eVar39: eVar39,
    // Load Time
    eVar40: eVar40,
    // Referrer Location
    eVar43: eVar43,
    // = eVar18 if searchCampaign
    eVar45: eVar45,
    // alias: Referrer Location
    eVar50: eVar50,
    // Location max 4
    eVar51: eVar51,
    // Location max 5
    eVar52: eVar52,
    // Location max 6
    eVar53: eVar53,
    // Location max 7
    eVar56: eVar56,
    // Content Detail
    eVar58: eVar58,
    // PS Now Membership Type
    eVar60: eVar60,
    // EA Access Member Status
    eVar66: eVar66,
    // Form Location
    eVar67: eVar67,
    // Community
    eVar69: eVar69,
    // Email Campaign Recipient
    eVar76: eVar76,
    // Email Campaign
    eVar77: eVar77,
    // Marketing Campaign
    eVar80: eVar80,
    // Genome Id
    eVar93: eVar93,
    // == Location (if banners)
    eVar95: eVar95,
    // Network Type : Boot Info : Data Size Group : Platform Version
    eVar97: eVar97,
    // Custom Conversion indicator
    eVar101: eVar101,
    // Tournament Detail
    eVar102: eVar102,
    // Maturity Rating
    hier1: hier1,
    // alias: Page Name
    list1: list1,
    // Banners
    list2: list2,
    // Recommendations
    list3: list3,
    // Tiles
    prop45: prop45,
    // Events
    pageViewEvents: pageViewEvents,
    // Page View event
    formEvents: formEvents,
    // Form Events can send without any custom properties
    clickTypeEvents: clickTypeEvents,
    // Click Type Event
    transactionEvents: transactionEvents,
    // Transaction Events
    psnowEvents: psnowEvents,
    // Populate PS Now membership events
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="Impression"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.Impression = {
    products: products,
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar30: eVar30,
    // Publisher
    eVar33: eVar33,
    // Recommendation Campaign
    eVar60: eVar60,
    // EA Access Member Status
    eVar93: eVar93,
    // Location (if Banners)
    list1: list1,
    // Banners
    list2: list2,
    // Recommendations
    list3: list3,
    // Tiles
    // Events
    sessionEvents: sessionEvents,
    // Populate session events
    events: events
  };
  /**
   * Property Set for Event.type="startup"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.Startup = {
    eVar49: eVar49,
    // Startup Type | VideoStreamType + VideoAction | Click Type
    eVar95: eVar95,
    // Connection Type : Boot Type : Data Size Group : Platform version
    // Events
    startupEvents: startUpEvents,
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="UserFacingError"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.UserFacingError = {
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar16: eVar16,
    // Error : Severity : Error Code : Description
    eVar37: eVar37,
    // Api Url
    eVar48: eVar48,
    // Location
    eVar74: eVar74,
    // Versions
    // Events
    userFacingErrorEvents: userFacingErrorEvents,
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="LoadTime"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.LoadTime = {
    eVar39: eVar39,
    // Load Time
    eVar95: eVar95,
    // Network Type : Boot Info : Data Size Group : Platform Version
    // Events
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="VideoStream"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.VideoStream = {
    eVar8: eVar8,
    // Merch Category
    eVar20: eVar20,
    // Product Name : Product Sku
    eVar22: eVar22,
    // Product Classification 1 || Product TYpe
    eVar23: eVar23,
    // Product Classification 2
    eVar24: eVar24,
    // Product Classification 3
    eVar25: eVar25,
    // Product Type
    eVar26: eVar26,
    // Genre : Maturity
    eVar27: eVar27,
    // Release Date
    eVar28: eVar28,
    // Display Price
    eVar30: eVar30,
    // Publisher
    eVar35: eVar35,
    // Video Type,
    eVar36: eVar36,
    // Video Format,
    eVar38: eVar38,
    // Network Name,
    eVar49: eVar49,
    // Startup Type | VideoStreamType + VideoAction | Click Type
    eVar56: eVar56,
    // Content Detail,
    eVar60: eVar60,
    // EA Access Member Status
    eVar61: eVar61,
    // Stream Type
    eVar62: eVar62,
    // Video ID,
    eVar63: eVar63,
    // Show : Title : Season : Episode : Format
    eVar64: eVar64,
    // Player ID
    eVar70: eVar70,
    // Promo Video Url
    list3: list3,
    // Tile
    list1: list1,
    // Banners
    // Events
    videoStreamEvents: videoStreamEvents,
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="AdClick"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.AdClick = {
    currencyCode: currencyCode,
    products: products,
    purchaseID: purchaseID,
    transactionID: transactionID,
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar8: eVar8,
    // Merch Category
    eVar9: eVar9,
    // Grief Report Item : Reason
    eVar12: eVar12,
    // Search Filter(s)
    eVar13: eVar13,
    // Sort Order
    eVar14: eVar14,
    // Transaction Payment Method
    eVar15: eVar15,
    // Transaction Type
    eVar17: eVar17,
    // Search Term
    eVar18: eVar18,
    // Search Result : Search Position : Search Count
    eVar20: eVar20,
    // Product Name : Product Sku
    eVar22: eVar22,
    // Product Classification 1 || Product Type
    eVar23: eVar23,
    // Product Classification 2
    eVar24: eVar24,
    // Product Classification 3
    eVar25: eVar25,
    // Product Type
    eVar26: eVar26,
    // Genre : Maturity
    eVar27: eVar27,
    // Release Date
    eVar28: eVar28,
    // Display Price
    eVar29: eVar29,
    // Recommendation Anchor
    eVar30: eVar30,
    // Publisher
    eVar31: eVar31,
    // Finding Method
    eVar32: eVar32,
    // PSTP Campaign Category
    eVar33: eVar33,
    // Recommendation Campaign
    eVar35: eVar35,
    // Video Type
    eVar36: eVar36,
    // Video Format
    eVar38: eVar38,
    // Network Name
    eVar41: eVar41,
    // = list1 (banners)
    eVar43: eVar43,
    // = eVar18 if Search Campaign
    eVar46: eVar46,
    // Recommendation Source
    eVar49: eVar49,
    // Startup Type | VideoStreamType + VideoAction | Click Type
    eVar56: eVar56,
    // Content Detail
    eVar58: eVar58,
    // PS Now Membership Type
    eVar60: eVar60,
    // EA Access Member Status
    eVar61: eVar61,
    // Stream Type
    eVar62: eVar62,
    // Video Id
    eVar63: eVar63,
    // Video Title : Episode Name : Season Num : Episode Num : Video Format
    eVar64: eVar64,
    // Player Id
    eVar66: eVar66,
    // Form Location
    eVar78: eVar78,
    // Privacy Settings = Tracking : Personalization
    eVar93: eVar93,
    // == Location (If Banners)
    eVar99: eVar99,
    // Tiles (~= list3; no fallback to related content)
    list1: list1,
    // Banners
    list2: list2,
    // Recommendations
    list3: list3,
    // Tiles
    prop5: prop5,
    prop6: prop6,
    prop8: prop8,
    // Events
    adEvents: adEvents,
    // Populate Event(s) for Ads
    clickTypeEvents: clickTypeEvents,
    // Populate Events based on click type
    clickEvents: clickEvents,
    // Populate Events for Click
    formEvents: formEvents,
    // Populate Form Events
    transactionEvents: transactionEvents,
    // Populate Transaction Events
    psnowEvents: psnowEvents,
    // Populate PS Now membership events
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Property Set for Event.type="AdImpression"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.AdImpression = {
    products: products,
    eVar2: eVar2,
    // User Account Locale
    eVar3: eVar3,
    // Signed In Status
    eVar4: eVar4,
    // Plus Member Status
    eVar5: eVar5,
    // User Age
    eVar30: eVar30,
    // Publisher
    eVar33: eVar33,
    // Recommendation Campaign
    eVar60: eVar60,
    // EA Access Member Status
    eVar93: eVar93,
    // Location (if Banners)
    // eVar98, // AB PDB (ads) // TODO want to ad Event98 to payload
    list1: list1,
    // Banners
    list2: list2,
    // Recommendations
    list3: list3,
    // Tiles
    // Events
    adEvents: adEvents,
    // Populate Event(s) for Ads
    sessionEvents: sessionEvents,
    // Populate session events
    events: events
  };
  /**
   * Property Set for Event.type="AdVideoStream"
   *
   * Format is : [propertyName] : [Value Callback]
   * Return {undefined} to not set the given property
   */

  Properties.AdVideoStream = {
    eVar8: eVar8,
    // Merch Category
    eVar20: eVar20,
    // Product Name : Product Sku
    eVar22: eVar22,
    // Product Classification 1 || Product TYpe
    eVar23: eVar23,
    // Product Classification 2
    eVar24: eVar24,
    // Product Classification 3
    eVar25: eVar25,
    // Product Type
    eVar26: eVar26,
    // Genre : Maturity
    eVar27: eVar27,
    // Release Date
    eVar28: eVar28,
    // Display Price
    eVar30: eVar30,
    // Publisher
    eVar35: eVar35,
    // Video Type,
    eVar36: eVar36,
    // Video Format,
    eVar38: eVar38,
    // Network Name,
    eVar49: eVar49,
    // Startup Type | VideoStreamType + VideoAction | Click Type
    eVar56: eVar56,
    // Content Detail,
    eVar60: eVar60,
    // EA Access Member Status
    eVar61: eVar61,
    // Stream Type
    eVar62: eVar62,
    // Video ID,
    eVar63: eVar63,
    // Show : Title : Season : Episode : Format
    eVar64: eVar64,
    // Player ID
    eVar70: eVar70,
    // Promo Video Url
    // eVar98, // AB PDB (ads) // TODO want to ad Event98 to payload
    list3: list3,
    // Tile
    list1: list1,
    // Banners
    // Events
    adEvents: adEvents,
    // Populate Event(s) for Ads
    videoStreamEvents: videoStreamEvents,
    sessionEvents: sessionEvents,
    // Populate session events
    events: events // Generate Events, must come after all events have been registered

  };
  /**
   * Builds the adobe payload using the provided callbacks-object
   *
   * @param {Object} callbacks   Hash of callbacks
   * @param {adobe~BuildPayloadContext}  context
   *
   * @returns {Object} Final Payload
   * @private
   */

  var _buildPayload$1 = function _buildPayload(callbacks) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var reducer = function reducer(result, key) {
      var response = callbacks[key](context);

      if (response !== undefined) {
        // eslint-disable-next-line no-param-reassign
        result[key] = response;
      }

      return result;
    };

    return Object.keys(callbacks).reduce(reducer, {});
  };
  /**
   * Build the Adobe Event Payload
   *
   * @param {adobe~BuildPayloadContext}  context   Context Information Object
   * @return {Object} payload
   */


  var buildPayload$2 = function buildPayload() {
    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var event = context.event,
        payload = context.payload;
    var eventProperties = Properties[String(event.type)];

    if (!eventProperties) {
      context.logger.warn("Not sending ".concat(event.type, " event to ").concat(context.pluginName, " (unsupported)"));
      return false;
    }

    _extends$4(payload, _buildPayload$1(defaultProperties$1, context));

    _extends$4(payload, _buildPayload$1(eventProperties, context));

    if (!payload.events) {
      context.logger.debug("Not sending ".concat(event.type, " event to ").concat(context.pluginName, " (no event property)"));
      return null;
    }

    return payload;
  };

  function _defineProperties$o(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$o(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$o(Constructor.prototype, protoProps); if (staticProps) _defineProperties$o(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$b(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * This plugin implements various event types for Adobe Analytics
   *
   * @class AdobePlugin
   * @extends BasePlugin
   */

  var AdobePlugin =
  /*#__PURE__*/
  function (_BasePlugin) {
    _inheritsLoose$b(AdobePlugin, _BasePlugin);

    function AdobePlugin(environment, config, pluginName, serviceLocator) {
      var _this;

      _this = _BasePlugin.call(this, environment, config, pluginName, serviceLocator) || this;

      _this._requireValidConfig(config);

      _this.abortOnWs1 = isUndefined_1(config.abortOnWs1) ? abortAdobeOnWs1ByDefault : config.abortOnWs1;
      _this._urlPrivacyFilter = serviceLocator.get('/privacy/uriCensor'); // Getter is called by the base class, which causes an undefined error.
      // The only clean way around this is to not extend BasePlugin directly.

      _this._superCalled = true;
      _this._environment = environment;

      _this.__resolveDispatcher(config, config.dispatcher, serviceLocator); // Grab the cache to track sessionId.


      _this._cache = serviceLocator.get('/cache/cacheInterface');

      _this._initMcidVisitor();

      return _this;
    }

    var _proto = AdobePlugin.prototype;

    _proto._isValidConfig = function _isValidConfig(config) {
      if (!config.reportSuite || !config.reportSuite.length) {
        return false;
      }

      return true;
    };

    _proto._requireValidConfig = function _requireValidConfig(config) {
      if (!this._isValidConfig(config)) {
        throw new Error('Invalid Adobe Configuration');
      }
    };

    /**
     * Initialize s.visitor integration
     * @private
     */
    _proto._initMcidVisitor = function _initMcidVisitor() {
      // The base class triggers an environment change.
      // We have to actively defend against pre-emptively initializing.
      if (!this._superCalled) {
        return;
      }

      this.dispatcher.initMcidVisitor(this.shouldRestrictData, this.environment, this.config, this.logger);
    };

    _proto.buildPayload = function buildPayload(event) {
      /**
       * @typedef {Object} adobe~BuildPayloadData
       * @property {function} pushEvents
       * @property {function} pushEvent
       * @property {function} hasEvent
       */

      /**
       * @typedef {Object} adobe~BuildPayloadContext
       * @property {Object}                 cache      Instance of cacheInterface
       * @property {Object}                 config     Plugin Configuration
       * @property {adobe~BuildPayloadData} data       Common data storage space for building events.
       * @property {Object}                 event      Event Object
       * @property {string}                 gctVersion GCT Version
       * @property {Logger}                 logger     Logger
       * @property {Object}                 payload    Current state of the payload
       * @property {string}                 pluginName Plugin Name
       * @property {string}                 sdkVersion SDK Version
       * @property {Object}                 payload    Current Payload
       */

      /**
       * @type {adobe~BuildPayloadContext}
       */
      var context = {
        cache: this._cache,
        config: this.config,
        data: {
          pushEvents: function pushEvents(eventIds) {
            context.data.events = context.data.events.concat(eventIds);
          },
          pushEvent: function pushEvent(eventId) {
            context.data.events.push(eventId);
          },
          hasEvent: function hasEvent(eventId) {
            return arrayIncludes(context.data.events, eventId);
          },
          hasEvents: function hasEvents() {
            return Boolean(context.data.events.length);
          }
        },
        environment: this.environment,
        event: event,
        gctVersion: GctVersion,
        logger: this.logger,
        payload: {},
        pluginName: this.pluginName,
        // Version of the SDK will actually come from the dispatcher
        sdkVersion: this.dispatcher.version
      };
      context.data.events = [];
      context.data.locationSegments = (event.location || '').split(':').map(function (v) {
        return Utils$1.cleanUpString(v);
      }).filter(function (v) {
        return v;
      }); // "Referrer is deprecated", transform internally.

      context.data.referrerLocation = event.referrerLocation || event.referrer || '';

      var adobePayload = buildPayload$2(context);

      if (!adobePayload) {
        return adobePayload;
      } // Populate props from eVars


      AdobeUtils.populateProps(adobePayload);

      if (this.shouldRestrictData && this.config.abortOnWs1) {
        adobePayload.abort = true;
      }

      return adobePayload;
    };

    _proto.sendPayload = function sendPayload(payload, event) {
      // Could actually trigger the payload with s.abort = true, but just not making the sdk call is probably better.
      if (this.shouldRestrictData && this.abortOnWs1) {
        this.logger.info('Not sending payload, abortOnWs1 is configured.');
        return;
      }

      if (event.sessionId && payload.events && payload.events.split(',').indexOf('event999') !== -1) {
        this._cache.set(ADOBE_SESSION_CACHE_KEY, event.sessionId);
      } // Send payload via the proper dispatcher


      this.dispatcher.dispatchPayload(this.shouldRestrictData, payload, event);
    };

    _proto.__resolveDispatcher = function __resolveDispatcher(config, dispatcherKey, serviceLocator) {
      // Create our dispatcher instance which will in turn set up the proper SDK
      // TODO: Inject concrete instance
      // TODO: Use fully qualified name
      var dispatcherServiceKey = isString_1(dispatcherKey) ? dispatcherKey : 'webSdk';
      var dispatcherClassOrInstance = serviceLocator.get("/adobe/".concat(dispatcherServiceKey));

      if (isFunction_1(dispatcherClassOrInstance.dispatchPayload)) {
        this._dispatcher = dispatcherClassOrInstance;
        return;
      } // TODO: Add deprecation notice -- factory should return an instance
      // eslint-disable-next-line new-cap


      this._dispatcher = new dispatcherClassOrInstance(config, serviceLocator);
    };

    _createClass$o(AdobePlugin, [{
      key: "dispatcher",
      get: function get() {
        return this._dispatcher;
      }
    }, {
      key: "environment",
      get: function get() {
        return this._environment;
      },
      set: function set(environment) {
        var isChanged = environment !== this._environment;
        this._environment = environment;

        if (isChanged) {
          // Dispatcher: Init visitor ID on env refresh
          this._initMcidVisitor();
        }
      }
    }, {
      key: "shouldRestrictData",
      get: function get() {
        return this.environment.platformPrivacyWs1 === UserPermissionLevel.MINIMAL;
      }
    }]);

    return AdobePlugin;
  }(BasePlugin$2); // Expose constants to outside


  Object.defineProperty(AdobePlugin, 'CONSTANTS', {
    enumerable: true,
    writable: false,
    configurable: false,
    value: AdobeConstants
  }); // Expose utils to outside

  Object.defineProperty(AdobePlugin, 'Utils', {
    enumerable: true,
    writable: false,
    configurable: false,
    value: AdobeUtils
  });

  function _defineProperties$p(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$p(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$p(Constructor.prototype, protoProps); if (staticProps) _defineProperties$p(Constructor, staticProps); return Constructor; }

  var _deprecationManager;

  var _dispatch;
  /**
   * Abstract class that all Grand Central Telemetry events must extend
   * @abstract
   */


  var BaseEvent =
  /*#__PURE__*/
  function () {
    /**
     * Allow events to dispatch themselves
     *
     * @todo assumes Telemetry is a singleton
     * @param {function} telemetry.dispatcher
     */
    BaseEvent.setDispatcher = function setDispatcher(dispatcher) {
      _dispatch = dispatcher;
    };

    _createClass$p(BaseEvent, [{
      key: "deprecationManager",
      get: function get() {
        if (!_deprecationManager) {
          _deprecationManager = new StaticDeprecationManager();
        }

        return _deprecationManager;
      } // TODO: @deprecated#classCleanup - remove attributes.

      /**
       * @param {Object}   data         Event Data
       * @param {string}   type         Event Type
       * @param {string}   [nameSuffix]   Event Name Suffix
       */

    }]);

    function BaseEvent(data, type) {
      var _this = this;

      var nameSuffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      // We will use the event class name as its type
      Object.defineProperty(this, 'type', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: type
      }); // This is a human friendly representation of the event type

      var name = type.replace(/([a-z](?=[A-Z]))/g, '$1 ');
      Object.defineProperty(this, 'name', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: (nameSuffix ? "".concat(name, " ").concat(nameSuffix) : name).toLowerCase()
      }); // These are generic attributes common between all events

      this.time = data.time || new Date();
      this.location = data.location;
      this.locationType = data.locationType;
      this.url = data.url; // Allow custom attributes unless already set

      var currentKeys = keys_1(this);
      keys_1(data).filter(function (k) {
        return !includes_1(currentKeys, k);
      }).forEach(function (attr) {
        _this[attr] = data[attr];
      });
    }
    /**
     * Convenience wrapper for telemetry.dispatch()
     *
     * @note must call BaseEvent.setDispatcher() to enable
     */


    var _proto = BaseEvent.prototype;

    _proto.dispatch = function dispatch() {
      return _dispatch(this);
    };

    return BaseEvent;
  }();

  function _defineProperties$q(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$q(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$q(Constructor.prototype, protoProps); if (staticProps) _defineProperties$q(Constructor, staticProps); return Constructor; }

  var TelemetryServices =
  /*#__PURE__*/
  function () {
    function TelemetryServices(containerInterface) {
      this._serviceContainer = containerInterface;
    }
    /**
     * Logger instance
     * @returns {LogInterface}
     */


    _createClass$q(TelemetryServices, [{
      key: "logger",
      get: function get() {
        if (!this._logger) {
          this._logger = this._serviceContainer.get('Logger');
        }

        return this._logger;
      }
      /**
       * Throttler instance
       * @returns {ThrottlerInterface}
       */

    }, {
      key: "throttler",
      get: function get() {
        if (!this._throttler) {
          this._throttler = this._serviceContainer.get('/throttler/GctThrottler');
        }

        return this._throttler;
      }
      /**
       * Schema Configuration Options
       * TODO: Merge all configuration options into a coherent options framework
       * TODO: THis is not a service, move it to other configuration
       * @returns {SchemaOptions}
       */

    }, {
      key: "schemaOptions",
      get: function get() {
        if (this._schemaOptions === undefined) {
          this._schemaOptions = this._serviceContainer.get('SchemaOptions');
        }

        return this._schemaOptions;
      }
      /**
       *
       * @returns {DeprecationManager}
       */

    }, {
      key: "deprecationManager",
      get: function get() {
        if (!this._deprecationManager) {
          this._deprecationManager = this._serviceContainer.get('/deprecation/deprecationManager');
        }

        return this._deprecationManager;
      }
      /**
       * @returns {IdentifierProvider}
       */

    }, {
      key: "identifiers",
      get: function get() {
        if (!this._identifiers) {
          this._identifiers = this._serviceContainer.get('/identifier/identifierProvider');
        }

        return this._identifiers;
      }
      /**
       * Event Manager
       * @returns {EventManager}
       */

    }, {
      key: "eventManager",
      get: function get() {
        if (!this._eventManager) {
          this._eventManager = this._serviceContainer.get('/event/eventManager');
        }

        return this._eventManager;
      }
      /**
       *
       * @returns {EventInspector}
       */

    }, {
      key: "eventInspector",
      get: function get() {
        if (!this._eventInspector) {
          this._eventInspector = this._serviceContainer.get('EventInspector');
        }

        return this._eventInspector;
      }
    }]);

    return TelemetryServices;
  }();

  function _inheritsLoose$c(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for click event.
   * @class ClickEvent
   * @extends BaseEvent
   */

  var ClickEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$c(ClickEvent, _BaseEvent);

    /**
     * Create a click event
     *
     * @param {object}          data - Properties of the click event
     * @param {boolean}         [data.allowAdditionalData] - Optional boolean to indicate if additional data gathering is allowed, usable only with MANAGE_DATA_GATHERING_SETTINGS
     * @param {boolean}         [data.allowPersonalizedRecs] - Optional boolean to indicate if tracking personalized purchase recommendations is allowed, usable only with MANAGE_PERSONALIZATION_SETTINGS
     * @param {boolean}         [data.allowPersonalizedAds] - Optional boolean to indicate if tracking personalized advertising is allowed, usable only with MANAGE_PERSONALIZATION_SETTINGS
     * @param {enum}            [data.apiStatus] - Optional indicates API call success/failure
     * @param {array}           [data.banner] - Optional banner id to capture banner information with the click
     * @param {enum}            data.clickType - [MODIFIED] Indicate the type of clicks (see Constants.CLICK_TYPES enum)
     * @param {string}          [data.clickLocation] - Optional location of the click if multiple locations are possible on screen
     * @param {string}          [data.clickMetadata] - Optional metadata information about the click event
     * @param {string}          [data.contentDetail] - Optional content detail
     * @param {string}          [data.displayPrice] - Optional product display price if the click is related to a product
     * @param {string}          [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {boolean}         [data.exitClick] - Optional boolean to indicate if click is exit click or not
     * @param {string}          [data.findingMethod] - Optional string which method was used to find the content clicked
     * @param {enum}            [data.formAction] - Optional form action if the click includes a form event (see Constants.FORM_ACTIONS enum)
     * @param {string}          [data.formLocation] - Optional form location if the click includes a form event to indicate the form name/step
     * @param {string}          [data.genre] - Optional product genre if the click is related to a product
     * @param {boolean}         [data.isPlaytimeUnlimited] - Optional indicate if the playtime is set to unlimited.
     * @param {string}          data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}          data.locationType - Location type
     * @param {string}          [data.maturity] - Optional product maturity if the click is related to a product
     * @param {enum}            [data.playtimeAgeGroup] - Optional indicate to which group this click playtime information belongs to.
     * @param {number}          [data.playtimeDurationChange] - Optional settings for the number of minutes change for playtime, it should be a valid negative or positive integer.
     * @param {string}          [data.productName] - Optional product name if the click is related to a product
     * @param {string}          [data.productSku] - Optional product sku if the click is related to a product
     * @param {string}          [data.publisher] - Optional product publisher if the click is related to a product
     * @param {string}          [data.releaseDate] - Optional product release date if the click is related to a product
     * @param {string}          [data.recommendation] - Optional recommendation object to capture recommendation information with the click (single recommendation)
     * @param {string}          [data.searchTerm] - Optional search term if the click triggered a search and to capture associated search term
     * @param {string|string[]} [data.searchFilter] - Optional search filter if the click triggered a search and to capture associated search filter
     * @param {string}          [data.sortOrder] - Optional sort order if the click triggered a sort and to capture the associater sort order
     * @param {object}          [data.tile] - Optional tile object to capture tile information with the click (single tile)
     * @param {array}           [data.tiles] - Optional array of tile object to capture tile information with the click (multiple tiles)
     * @param {object}          [data.transaction] - Optional transaction object if the click includes a transaction
     * @param {string}          data.url - URL to the location of the event or app (location.href)
     */
    function ClickEvent(data) {
      var nameSuffix = '';

      if (data.clickLocation) {
        nameSuffix += "".concat(data.clickLocation, " ");
      } // Why is this cast to string here?
      // eslint-disable-next-line no-param-reassign


      data.clickType = String(data.clickType);
      nameSuffix += data.clickType.replace('click ', '');
      return _BaseEvent.call(this, data, 'Click', nameSuffix.replace('_', ' ')) || this;
    }

    return ClickEvent;
  }(BaseEvent);

  function _inheritsLoose$d(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for dwell event.
   * @class DwellEvent
   * @extends BaseEvent
   */

  var DwellEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$d(DwellEvent, _BaseEvent);

    /**
     * Create a dwell event.
     *
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {int}     dwellDurationTime - Time elapsed between dwellStartTime and dwellEndTime in ms (calculated by GCT).
     * @param {date}    dwellEndTime - Time at which users focus changes from item (or item disappeared in non-highlight based UX)
     * @param {date}    dwellStartTime - Time at which user focused on item for dwell (or item became fully visible in non-highlight based UX)
     * @param {string}  dwellTargetId - Unique ID of item that the user dwells on
     * @param {string}  dwellTargetType - Type of Item that the user dwells on
     * @param {array}   [data.experimentData] - Indicate which experiments (A/B tests) the user is grouped in
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  data.pageUrl - Override for window.location.href.
     * @param {array}   [data.tile] - Contain information of the captured tile
     * @param {date}    data.time - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function DwellEvent(data) {
      return _BaseEvent.call(this, data, 'Dwell') || this;
    }

    return DwellEvent;
  }(BaseEvent);

  function _inheritsLoose$e(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for ad click event.
   * @class AdClickEvent
   * @extends BaseEvent
   */

  var AdClickEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$e(AdClickEvent, _BaseEvent);

    /**
     * Create an ad click event.
     *
     * @param {object}  data - Properties of the page view event
     * @param {array}   [data.banner] - Banner id to capture banner information with the click
     * @param {enum}    data.clickType - Indicate the type of clicks (see Constants.CLICK_TYPES enum)
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {boolean} [data.exitClick] - Boolean to indicate if click is exit click or not
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {object}  [data.tile] - Ttile object to capture tile information with the click (single tile)
     * @param {date}    [data.time] - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function AdClickEvent(data) {
      return _BaseEvent.call(this, data, 'AdClick') || this;
    }

    return AdClickEvent;
  }(BaseEvent);

  function _inheritsLoose$f(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for ad impression event.
   * @class AdImpressionEvent
   * @extends BaseEvent
   */

  var AdImpressionEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$f(AdImpressionEvent, _BaseEvent);

    /**
     * Create an ad impression event.
     *
     * @param {object}  data - Properties of the page view event
     * @param {array}   [data.banners] - Array of banner ids to capture banner impressions with the page view
     * @param {string}  [data.bannerType] - Capture BANNER_TYPES.
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {array}   [data.tiles] - Optional array of tiles to capture tile impressions with the page view
     * @param {date}    [data.time] - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function AdImpressionEvent(data) {
      return _BaseEvent.call(this, data, 'AdImpression') || this;
    }

    return AdImpressionEvent;
  }(BaseEvent);

  function _inheritsLoose$g(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for ad video stream event.
   * @class AdVideoStreamEvent
   * @extends BaseEvent
   */

  var AdVideoStreamEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$g(AdVideoStreamEvent, _BaseEvent);

    /**
     * Create an ad video stream event.
     *
     * @param {object}  data - Properties of the page view event
     * @param {array}   [data.banners] - Array of banner ids to capture banner impressions with the page view
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  [data.elapsedTime] - Capture the current video playback position in seconds
     * @param {string}  [data.currentViewedTime] - Capture the current viewed time in seconds since the most recent play or resume event
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  [data.playerId] - Capture the video player ID or name
     * @param {enum}    data.streamType - Indicate the type of video stream (see Constants.STREAM_TYPES enum)
     * @param {array}   [data.tile] - Tile object to capture tile information with the click
     * @param {date}    [data.time] - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     * @param {enum}    [data.videoAction] - Indicate video stream action (see Constants.VIDEO_ACTIONS enum)
     * @param {enum}    data.videoDuration - Indicate total length of video
     * @param {enum}    data.videoFormat - Indicate the video format (see Constants.VIDEO_FORMATS enum)
     * @param {enum}    data.videoType - Indicate the type of video content (see Constants.VIDEO_TYPES enum)
     * @param {string}  [data.videoUrl] - Optional URL representing the Stream or File being played
     * @param {string}  [data.windowMode] - Optional window mode such as fullscreen or not
     */
    function AdVideoStreamEvent(data) {
      return _BaseEvent.call(this, data, 'AdVideoStream') || this;
    }

    return AdVideoStreamEvent;
  }(BaseEvent);

  function _inheritsLoose$h(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for impression event.
   * @class ImpressionEvent
   * @extends BaseEvent
   */

  var ImpressionEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$h(ImpressionEvent, _BaseEvent);

    /**
     * @param {object}  data - Properties of the impression event
     * @param {string}  [data.bannerType] - Optional capture BANNER_TYPES.
     * @param {array}   [data.banners] - Optional array of banner ids to capture banner impressions with the page view
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {array}   [data.recommendations] - Optional array of recommendations to capture impressions recommendation with the page view
     * @param {date}    [data.time] - Optional time of the event
     * @param {array}   [data.tiles] - Optional array of tiles to capture tile impressions with the page view
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function ImpressionEvent(data) {
      var suffix;

      if (data.banners) {
        suffix = 'banners';

        if (data.bannerType) {
          switch (data.bannerType) {
            case BANNER_TYPES$1.PAID_AD_VIEWED:
              suffix += ' paid ad viewed';
              break;

            case BANNER_TYPES$1.PAID_AD_LOADED:
              suffix += ' paid ad loaded';
              break;

            case BANNER_TYPES$1.VIDEO_AD_PLAYED:
              suffix += ' video ad played';
              break;

            default:
              break;
          }
        }
      } else if (data.tiles) {
        suffix = 'tiles';
      } else if (data.recommendations) {
        suffix = 'recommendations';
      }

      return _BaseEvent.call(this, data, 'Impression', suffix) || this;
    }

    return ImpressionEvent;
  }(BaseEvent);

  function _inheritsLoose$i(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for load time event.
   * @class LoadTimeEvent
   * @extends BaseEvent
   */

  var LoadTimeEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$i(LoadTimeEvent, _BaseEvent);

    /**
     * Create a load time event to capture the UI load time (via loadTime property) or any
     * given timings (via the timings array). loadTime or/and timings must be set.
     *
     * @param {object}  data - Properties of the page view event
     * @param {string}  [data.bootInfo] - Optional string to track the boot context (warm/cold, cached/uncached)
     * @param {string}  [data.dataSizeGroup] - Optional string to track the size of data loaded
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {integer} [data.loadTime] - Load time for the location (UI load time)
     * @param {date}    [data.time] - Optional time of the event
     * @param {array}   [data.timings] - Optional array of sub timings
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function LoadTimeEvent(data) {
      return _BaseEvent.call(this, data, 'LoadTime') || this;
    }

    return LoadTimeEvent;
  }(BaseEvent);

  function _inheritsLoose$j(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for page view event.
   * @class PageViewEvent
   * @extends BaseEvent
   */

  var PageViewEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$j(PageViewEvent, _BaseEvent);

    /**
     * Create a page view event
     *
     * @param {object}  data - Properties of the page view event
     * @param {string}  [data.bannerType] - Optional capture BANNER_TYPES.
     * @param {array}   [data.banners] - Optional array of banner ids to capture banner impressions with the page view
     * @param {string}  [data.clickType] - Optional click type which triggered this page view
     * @param {object}  [data.community] - Optional community information
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  [data.emailCampaign] - Optional string to identify a email marketing campaign for revenue/visit attribution
     * @param {string}  [data.emailRecipient] - Optional string to identify a email marketing recipient for revenue/visit attribution
     * @param {string}  [data.experienceId] - Optional id of the current experience
     * @param {enum}    [data.formAction] - Optional form action if the page view includes a form event (see Constants.FORM_ACTIONS enum)
     * @param {string}  [data.formLocation] - Optional form location if the page view includes a form event to indicate the form name/step
     * @param {object}  [data.loadTime] - Optional load time of the application used to calculate load time of a page.
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  [data.marketingCampaign] - Optional string to identify a web marketing campaign for revenue/visit attribution
     * @param {enum}    [data.productType] - Optional type of product related to this page view - see PRODUCT_TYPES enum
     * @param {string}  [data.publisher] - Optional publisher related to this page view (typically if a product is involved)
     * @param {string}  [data.referrer] - DEPRECATED - Optional referrer to indicate where did we came from?
     * @param {string}  [data.referrerLocation] - Optional location string that represents the referrer page or app or website
     * @param {array}   [data.recommedations] - Optional array of recommendations to capture impressions recommendation with the page view
     * @param {array}   [data.tiles] - Optional array of tiles to capture tile impressions with the page view
     * @param {date}    [data.time] - Optional time of the event
     * @param {object}  [data.transaction] - Optional transaction object if the page view includes a transaction
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     * @param {string}  [data.viewCollectionId] - Optional id of the current view collection
     * @param {Array.<string>}  [data.viewIds] - Optional list of ids of views that are on screen
     * @param {string}  data.httpReferrer - Overrides the document referrer
     */
    function PageViewEvent(data) {
      return _BaseEvent.call(this, data, 'PageView') || this;
    }

    return PageViewEvent;
  }(BaseEvent);

  function _inheritsLoose$k(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for search event.
   * @class SearchEvent
   * @extends BaseEvent
   */

  var SearchEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$k(SearchEvent, _BaseEvent);

    /**
     * Create a search event.
     *
     * @param {object}  data - Properties of the page view event
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {array}   data.experimentData - Indicate which experiments (A/B tests) the user is grouped in
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  data.pageUrl - Override for window.location.href.
     * @param {date}    data.time - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     * @param {string}  data.searchTerm - when click trigger a search capture associated search term
     * @param {string}  data.searchType - Type of community search
     * @param {int}     data.retryCount - number of search retry, zero based.
     * @param {int}     data.resultCount - number of returned results
     * @param {string}  data.itemIdNamespace - namespace in which itemIds are valid
     * @param {array}   data.itemIds - array of item ids
     * @param {string}  data.contentType - Field to denote the type of the content
     * @param {string}  data.storeRegion - Store region in use
     * @param {string}  data.storeLanguage - Store langauge in use
     */
    function SearchEvent(data) {
      return _BaseEvent.call(this, data, 'Search') || this;
    }

    return SearchEvent;
  }(BaseEvent);

  function _inheritsLoose$l(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for startup event.
   * @class StartupEvent
   * @extends BaseEvent
   */

  var StartupEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$l(StartupEvent, _BaseEvent);

    /**
     * Create a startup time event to denote start up of application or page load, then capture a page view with the load time.
     *
     * @param {object}  data - Properties of the page view event
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  [data.privacySettings] - readonly optional that will contain the platform privacy ws1 information after dispatch.
     * @param {string}  data.startupType - the type of startup we are capturing STARTUP_TYPES
     * @param {array}   [data.startupContext] - Optional indicates where we are starting up from it is used with STARTUP_TYPES.APP
     * @param {date}    [data.time] - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function StartupEvent(data) {
      return _BaseEvent.call(this, data, 'Startup', data.startupType) || this;
    }

    return StartupEvent;
  }(BaseEvent);

  function _inheritsLoose$m(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   * Class for user facing error event.
   * @class UserFacingErrorEvent
   * @extends BaseEvent
   */

  var UserFacingErrorEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$m(UserFacingErrorEvent, _BaseEvent);

    /**
     * @param {object}  data - Properties of the user facing error event
     * @param {string}  [data.apiUrl] - Optinal API endpoint which caused the error if applicable -
     * @param {integer} data.code - Error code is typically an HTTP status error code or similar
     * @param {string}  [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {mixed}   [data.description] - Optional error description is some additional description for the given error
     * @param {string}  data.error - Error type is a short name describing the error
     * @param {mixed}   [data.errorMetadata] - Optional, a JSON of key/value pairs for additional context related to the error
     * @param {string}  data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}  data.locationType - Location type
     * @param {string}  [data.overrideAppName] - Optional, use this app name instead of config to send error in case of delegating from one to another
     * @param {string}  [data.overrideBuildVersion] - Optional, use this build version instead of config to send error in case of delegating from one to another
     * @param {enum}    data.severity - Error severity is one of Constants.SEVERITIES
     * @param {mixed}   [data.stack] - Optional, the stack trace for the error
     * @param {date}    [data.time] - Optional time of the event
     * @param {string}  data.url - URL to the location of the event or app (location.href)
     */
    function UserFacingErrorEvent(data) {
      if (!isValidSeverity(data.severity)) {
        throw new Error("Invalid value for SEVERITIES: ".concat(data.severity, "!"));
      }

      var nameSuffix = Utils$1.cleanUpString(data.error);
      return _BaseEvent.call(this, data, 'UserFacingError', nameSuffix) || this;
    }

    return UserFacingErrorEvent;
  }(BaseEvent);

  function _inheritsLoose$n(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  /**
   *
   * @param {string} message
   * @param {function(string):boolean} validator
   * @param {string} value
   */

  var throwErrorOnInvalidValue = function throwErrorOnInvalidValue(message, validator, value) {
    if (!validator(value)) {
      throw new Error(message.replace('{value}', value));
    }
  };
  /**
   * Class for video stream event.
   * @class VideoStreamEvent
   * @extends BaseEvent
   *
   * Bundles and assists with dispatching events around Video Actions (play/pause)
   *
   * @example
   *   const videoStream = new VideoStreamEvent({
   *     videoTitle: 'Tom Goes to the Mayor',
   *     videoId: 'abc123'
   *   });
   *
   *   videoStream.dispatch(VideoStreamEvent.VIDEO_ACTIONS.PLAY);
   *   videoStream.dispatch(VideoStreamEvent.VIDEO_ACTIONS.PAUSE);
   *   videoStream.dispatch(VideoStreamEvent.VIDEO_ACTIONS.STOP);
   */


  var VideoStreamEvent =
  /*#__PURE__*/
  function (_BaseEvent) {
    _inheritsLoose$n(VideoStreamEvent, _BaseEvent);

    /**
     * Create a video stream event
     *
     * @param {object}   data - Properties of the video stream event
     * @param {string}   [data.deeplink] - Optional deeplink to the location of the event (deeplink or app route)
     * @param {string}   [data.currentViewedTime] - Optional capture the current time in seconds user watched video since the most recent play or resume event
     * @param {string}   [data.displayPrice] - Optional video display price
     * @param {string}   [data.elapsedTime] - Optional capture the current video playback position in seconds
     * @param {string}   [data.genre] - Optional video genre
     * @param {string}   data.location - Location of the event in format PLATFORM:APP:PAGE:SECTION:SUBSECTION:...:...
     * @param {string}   data.locationType - Location type
     * @param {string}   [data.maturity] - Optional video maturity rating
     * @param {string}   [data.networkName] - Optional capture the network or channel name which streams the video
     * @param {string}   [data.playerId] - Optional capture the video player ID or name
     * @param {string}   [data.publisher] - Optional video publisher
     * @param {string}   [data.releaseDate] - Optional video release date
     * @param {enum}     data.streamType - Indicate the type of video stream (see Constants.STREAM_TYPES enum)
     * @param {array}    [data.tile] - Optional tile object to capture tile information with the click
     * @param {date}     [data.time] - Optional time of the event
     * @param {string}   [data.totalViewedTime] - Optional capture the total time in seconds user watched video including replays, rewinds, fast forwards
     * @param {string}   data.url - URL to the location of the event or app (location.href)
     * @param {enum}     [data.videoAction] - Optional indicate video stream action (see Constants.VIDEO_ACTIONS enum)
     * @param {string}   [data.videoId] - Optional capture a unique identifier of the video
     * @param {string}   [data.videoTitle] - Optional capture the title of the video
     * @param {enum}     data.videoType - Indicate the type of video content (see Constants.VIDEO_TYPES enum)
     * @param {enum}     data.videoFormat - Indicate the video format (see Constants.VIDEO_FORMATS enum)
     * @param {string}   [data.videoEpisodeName] - Optional capture the episode name for the video if applicable
     * @param {string}   [data.videoSeasonNum] - Optional capture the season number for the video if applicable
     * @param {string}   [data.videoEpisodeNum] - Optional capture the episode number for the video if applicable
     * @param {string}   [data.videoDuration] - Optional capture the duration of the video if applicable
     * @param {string}   [data.videoUrl] - Optional URL representing the Stream or File being played
     * @param {string}   [data.windowMode] - Optional window mode such as fullscreen or not
     * @param {array}    [data.banners] - Optional banner id to capture banner information with the view
     */
    function VideoStreamEvent(data) {
      // videoAction is optional
      if (data.videoAction) {
        throwErrorOnInvalidValue('Invalid value for VIDEO_ACTIONS: {value}!', isValidVideoAction, data.videoAction);
      }

      throwErrorOnInvalidValue('Invalid value for STREAM_TYPES: {value}!', isValidStreamType, data.streamType);
      throwErrorOnInvalidValue('Invalid value for VIDEO_FORMATS: {value}!', isValidVideoFormat, data.videoFormat);
      throwErrorOnInvalidValue('Invalid value for VIDEO_TYPES: {value}!', isValidVideoType, data.videoType);
      var nameSuffix = "".concat(data.streamType, " ").concat(data.videoAction);
      return _BaseEvent.call(this, data, 'VideoStream', nameSuffix.replace(/(_)/g, ' ')) || this;
    }
    /**
     * Dispatches specific videoActions for the videoStream. If no action is passed, dispatches normally
     * @param  {string} [videoAction] Must be an action from Constants.VIDEO_ACTIONS
     */


    var _proto = VideoStreamEvent.prototype;

    _proto.dispatch = function dispatch(videoAction) {
      if (videoAction) {
        this.videoAction = videoAction;
        this.time = new Date();
      }

      return _BaseEvent.prototype.dispatch.call(this);
    };

    return VideoStreamEvent;
  }(BaseEvent);

  function _extends$5() { _extends$5 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$5.apply(this, arguments); }

  /**
   * Default factory for Legacy "RegisterPlugins" desigend plugins
   *
   * This replaces the "registerPlugin" call, and instantiation by TelemetryService.
   *
   * The initial design is to replace the constructor call out-right, but not convert
   * the class to support dependency injection.  That is, the class will be building
   * it's dependencies and options itself, rather than have any variable behaviour injected.
   *
   * The plan is to convert the plugins individually at a later date to a more modern
   * architecture.  This is to minimize the amount of change on any given PR.
   *
   * Later plans to sever the plugins from `BasePlugin` will be done to ensure that
   * Plugins merely implement appropriate interfaces for behaviour:
   * `dispatch(Event)` IDispatchable
   *
   * @param {ContainerInterface} container
   * @param {string} pluginName Registered Plugin Id
   * @param {Object} PluginConstructor  Plugin Constructor Function / Class Object
   */
  var legacyPluginFactory = function legacyPluginFactory(container, pluginName, PluginConstructor) {
    var globalConfig = container.get('config');

    var pluginConfig = _extends$5({}, (globalConfig.plugins || {})[pluginName] || {}); // Support global dryRun setting


    if (globalConfig.dryRun === true) {
      pluginConfig.dryRun = true;
    } // Filtered Environment

    /** @var {TelemetryService} telemetryService */


    var telemetryService = container.get('telemetryService');
    var globalEnv = telemetryService.filteredEnvironment; // TODO: Do not pass in the service locator to the plugin
    // TODO: This MUST go.

    pluginConfig.__logger = container.get('Logger');
    return new PluginConstructor(globalEnv, pluginConfig, pluginName, container);
  };

  var createTransitionPluginFactory = (function (pluginName, pluginConstructor) {
    return function (container) {
      return legacyPluginFactory(container, pluginName, pluginConstructor);
    };
  });

  var PLUGINS = {};
  /**
   * Internal method to derive a class name from a name
   *
   * @private
   * @param      {string}  name    The name of the plugin or event
   * @param      {string}  type    The type either 'plugin' or 'event'
   * @return     {string}  The class name.
   */

  var _getClassName = function _getClassName(name, type) {
    // Note that the class name is derived from the name string
    // as the class may be minified in production, causing the className
    // to change from a readable string to a single letter or symbol
    // examples: adobe => AdobePlugin, pageView => PageViewEvent
    var className = name[0].toUpperCase() + name.substr(1);
    var classSuffix = type[0].toUpperCase() + type.substr(1);
    return className + classSuffix;
  };
  /**
   * Internal method to register a plugin or event
   *
   * @private
   * @param      {function}   TelemetryService   [MODIFIED] The object where we will expose the registered plugin or event
   * @param      {string}     name               The name of the plugin or event
   * @param      {function}   classDef           The class implementation of the plugin or vent
   * @param      {string}     type               The type either 'plugin' or 'event'
   */


  var register = function register(TelemetryService, name, classDef, type) {
    var className = _getClassName(name, type); // Prevent this from triggering a deprecation warning, by delegating the logic to TelemetryService


    PLUGINS[name] = classDef;

    TelemetryService.__createTransitionPluginReference(className, classDef);
  };
  /**
   * Internal method to unregister a plugin or event
   *
   * @private
   * @param      {class}   TelemetryService   [MODIFIED] The object where we will expose the registered plugin or event
   * @param      {string}  name               The name of the plugin or event
   * @param      {string}  type               The type either 'plugin' or 'event'
   */


  var unregister = function unregister(TelemetryService, name, type) {
    // Only delete items that were registered by Registry (i.e. not the get * properties)
    if (PLUGINS[name]) {
      delete PLUGINS[name]; // Remove outside reference

      var className = _getClassName(name, type);
      /* eslint-disable no-param-reassign */


      delete TelemetryService[className]; // TODO: This triggers a deprecation warning, however, no client seems to unregister* so, this seems to
      //       only be an issue in Unit Tests.

      if (TelemetryService.PLUGINS) {
        delete TelemetryService.PLUGINS[className];
      }
    }
  };

  var Registry = {
    PLUGINS: PLUGINS,
    register: register,
    unregister: unregister
  };

  /* eslint-disable no-undef */
  /**
   * Returns Permission Setting
   *
   * Extracts the Query Parameter "PlatformPrivacyWs1"
   *
   * Expected Values:
   *     'minimal'
   *     'all'
   *     'exempt'
   *     undefined
   *
   * Undefined:
   *       A web application is loaded on Non-PS4 device like PC
   *       VSH falls into an unexpected state (A defect on VSH) --> please create a bugzilla ticket.
   *       You are using old PS4 system software (before May 2017)
   *
   * @see https://confluence.sie.sony.com/display/AIART/How+web+applications+gets+a+result+of+user%27s+consent
   * @returns {string}
   */

  var permissionFromUrl = function permissionFromUrl() {
    if (typeof window === 'undefined' || typeof window.location === 'undefined' || typeof window.location.search === 'undefined') {
      return '';
    } // location.search includes the leading '?'


    var queryString = window.location.search.substr(1);
    var queryParams = queryStringAsObject(queryString);
    return queryParams.PlatformPrivacyWs1 || '';
  };

  /**
   * Returns Permission Setting
   *
   * Extracts the environment parameter "platformPrivacyWs1"
   *
   * No external specifications
   * @param {object} env  GCT Environment
   * @returns {string}
   */
  var fromEnvironment = function fromEnvironment(env) {
    return env.platformPrivacyWs1 || '';
  };

  /**
   * Is the value a valid user permission level.
   *
   * @param {string} value
   * @return {boolean}
   */

  var isValid = (function (value) {
    return arrayIncludes(UserPermissionLevel.ALL, value);
  });

  var strategyReducer = function strategyReducer(result, callback) {
    if (result) {
      return result;
    }

    var returnedValue = callback(); // Empty value means unable to determine, or not applicable.

    if (!returnedValue) {
      return undefined;
    } // Value was set!


    return returnedValue;
  };
  /**
   * Extract the effective user permission level.
   *
   * This value must be one of the constants listed in [./userPermissionLevels], which
   * represents the user preference for data sharing.
   *
   *   PS4  -- Query Parameter
   *   Mobile -- Query Parameter on Web View
   *   Tessaract -- Query Parameter on Web View
   *
   * Invalid Value Case: MINIMAL
   *
   * @see https://confluence.sie.sony.com/display/AIART/How+web+applications+gets+a+result+of+user%27s+consent
   * @param {object} env   GCT Env
   * @returns {schema~UserPermissionLevel}
   */


  var resolveUserPermissionLevel = function resolveUserPermissionLevel(_ref) {
    var env = _ref.env;
    var strategy = [function () {
      return fromEnvironment(env);
    }, function () {
      return permissionFromUrl();
    }];
    var result = strategy.reduce(strategyReducer, null); // If the returned value is value, use it, otherwise MINIMAL.
    // TODO: Ensure that we have some means of detecting the failure case, this simply hides it.

    return isValid(result) ? result : UserPermissionLevel.MINIMAL;
  };

  /**
   * Convenience Map for importing multiple modules.
   * WS1 : Data Gathering
   */

  /**
   * Merge two objects, recursively.
   * Object Keys are merged.
   * Array Keys append.
   * Scalar Keys overwrite.
   * @param {Object} [MODIFIED] objA
   * @param {Object} objB
   * @returns {Object}
   */

  var merge = function merge(objA, objB) {
    var recursionMap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

    /* eslint-disable no-param-reassign */
    Object.keys(objB).forEach(function (key) {
      // Recurse
      if (isPlainObject$1(objB[key])) {
        // Circular Dependency Stop
        if (recursionMap.has(objB[key])) {
          objA[key] = recursionMap.get(objB[key]);
          return;
        }

        if (!isPlainObject$1(objA[key])) {
          objA[key] = {};
        } // Prevent recursion in the same tree, break links otherwise


        recursionMap.set(objB[key], objA[key]);
        objA[key] = merge(objA[key], objB[key], recursionMap);
        recursionMap["delete"](objB[key]);
      } // Overwrite


      if (isScalar(objB[key]) || isFunction$1(objB[key])) {
        objA[key] = objB[key];
        return;
      } // Append


      if (isArray$1(objB[key])) {
        if (!isArray$1(objA[key])) {
          objA[key] = [];
        }

        objA[key] = objA[key].concat(objB[key]);
      }
    });
    return objA;
    /* eslint-enable no-param-reassign */
  };

  function _slicedToArray$5(arr, i) { return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _nonIterableRest$5(); }

  function _nonIterableRest$5() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

  function _iterableToArrayLimit$5(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles$5(arr) { if (Array.isArray(arr)) return arr; }

  function _typeof$e(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$e = function _typeof(obj) { return typeof obj; }; } else { _typeof$e = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$e(obj); }
  /**
   * Visitor AuthState Constants
   * @enum
   */

  var AuthState = {
    UNKNOWN: 0,
    SIGNED_IN: 1,
    SIGNED_OUT: 2
  };
  /**
   * @typedef {Object} CustomerState
   * @property {boolean} isSignedIn
   * @property {string} hashedPsnAccountId
   * @property {string} deviceId
   * @property {string} deviceAgent
   */

  /**
   * Return null if value is undefined, or value.
   * @param {*} Value
   * @returns {?*}
   */

  var definedValueOrNull = function definedValueOrNull(value) {
    return typeof value === 'undefined' ? null : value;
  };
  /**
   * Extract the user state from the environment
   *
   * isSignedIn will default to False ***
   *   This is different than the default logic in telemetry, as that will
   *   explictly define the variable accordingly upon instantiation.
   *
   * @param {Object}   environment    GCT Telemetry Service Environment
   * @returns CustomerState
   */


  var getCustomerState = function getCustomerState() {
    var environment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var isSignedIn = Boolean(environment.signedIn);
    var hashedPsnAccountId = definedValueOrNull(environment.visitorId);
    var deviceId = definedValueOrNull(environment.deviceId); // TODO: Move this value to "environment"
    // eslint-disable-next-line no-undef

    var deviceAgent = (typeof navigator === "undefined" ? "undefined" : _typeof$e(navigator)) === 'object' ? definedValueOrNull(navigator.userAgent) : null;
    return {
      isSignedIn: isSignedIn,
      hashedPsnAccountId: hashedPsnAccountId,
      deviceId: deviceId,
      deviceAgent: deviceAgent
    };
  };
  /**
   *
   * @param customerState
   * @returns {int}
   */


  var extractAuthStateFromCustomerState = function extractAuthStateFromCustomerState(customerState) {
    return customerState.isSignedIn ? AuthState.SIGNED_IN : AuthState.SIGNED_OUT;
  };
  /**
   * Omniture Id representing the PSN Account Id
   *
   * @param {CustomerState} customerState
   * @returns {Object}    Omniture Customer Id for PSN Account Id Hash;
   */


  var getCustomerUserId = function getCustomerUserId(customerState) {
    // Signed Out
    if (!customerState.isSignedIn) {
      return {
        authState: AuthState.SIGNED_OUT
      };
    } // @see https://github.snei.sony.com/SIE/grand-central-telemetry/issues/163
    //   : What do we do if we are signed in but not have a visitorID? Example: fetch to failed, we currently set to a string of zeros
    //   :: (BB) We should continue to do this for now.


    return {
      id: customerState.hashedPsnAccountId || AdobeConstants.MISSING_VISITOR_ID,
      authState: AuthState.SIGNED_IN
    };
  };
  /**
   * Omniture Id representing the Device Id
   *
   * @param {CustomerState} customerState
   * @returns {Object}    Omniture Customer Id for PSN Device Id; null if invalid
   */


  var getCustomerDeviceId = function getCustomerDeviceId(customerState) {
    // No Device ID.  Don't sync anything.
    if (!customerState.deviceId) {
      return null;
    }

    return {
      id: customerState.deviceId,
      authState: extractAuthStateFromCustomerState(customerState)
    };
  };
  /**
   * Omniture Id representing the Device Agent
   **
   * @param {CustomerState} customerState
   * @returns {Object}    Omniture Customer Id for Device Agent; null if invalid
   */


  var getCustomerDeviceAgent = function getCustomerDeviceAgent(customerState) {
    // No Device ID.  Don't sync anything.
    if (!customerState.deviceAgent) {
      return null;
    }

    return {
      id: customerState.deviceAgent,
      authState: extractAuthStateFromCustomerState(customerState)
    };
  };
  /**
   * Return an object representing the client customer ids for the active user.
   *
   * @param {CustomerState}   customerState    customer state abstraction
   * @returns {Object}        values that can be passed into setCustomerIds
   */


  var getCustomerIdsForOmniture = function getCustomerIdsForOmniture(customerState) {
    var ids = {};
    var userId = getCustomerUserId(customerState);

    if (userId) {
      // Question: macross syncs this as userid, GH#163 uses psn_Member
      ids.psn_Member = userId;
    }

    var deviceId = getCustomerDeviceId(customerState);

    if (deviceId) {
      ids.psn_Device = deviceId;
    }

    var deviceAgent = getCustomerDeviceAgent(customerState);

    if (deviceAgent) {
      ids.psn_DeviceAgent = deviceAgent;
    }

    return ids;
  };
  /**
   * Apply customer ids
   * @param {Object}      visitor       Adobe Visitor instance
   * @param {Object}      environment   GCT TelemetryService environment
   */


  var applyCustomerIds = function applyCustomerIds(visitor, environment) {
    var customerState = getCustomerState(environment);
    var omnitureIds = getCustomerIdsForOmniture(customerState);

    if (Object.keys(omnitureIds).length > 0) {
      visitor.setCustomerIDs(omnitureIds);
    }
  };
  /**
   * Returns options suitable for inclusion in a getCurrentVisitor() omniture call.
   * @param mcidConfig
   */
  // eslint-disable-next-line arrow-body-style


  var buildVisitorOptions = function buildVisitorOptions(mcidConfig) {
    return [['trackingServer', mcidConfig.trackingServer], ['trackingServerSecure', mcidConfig.trackingServerSecure], ['marketingCloudServer', mcidConfig.marketingCloudServer], ['marketingCloudServerSecure', mcidConfig.marketingCloudServerSecure], ['audienceManagerServer', mcidConfig.audienceManagerServer], ['audienceManagerServerSecure', mcidConfig.audienceManagerServerSecure]].reduce(function (result, _ref) {
      var _ref2 = _slicedToArray$5(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];

      if (value) {
        // eslint-disable-next-line no-param-reassign
        result[key] = value;
      }

      return result;
    }, {});
  };
  /**
   * Return the current visitor instance.
   *
   * @param {McidConfig} mcidConfig
   * @param {Object}     gctEnvironment
   * @returns {Object}   Adobe Visitor instance
   */


  var getCurrentVisitor = function getCurrentVisitor(mcidConfig, gctEnvironment) {
    var visitorApi = mcidConfig.visitorApi;

    if (!visitorApi) {
      return null;
    }

    var visitorOptions = buildVisitorOptions(mcidConfig);
    var currentVisitor = visitorApi.getInstance(mcidConfig.organizationId, visitorOptions); // This should never happen

    if (!currentVisitor) {
      return null;
    }

    applyCustomerIds(currentVisitor, gctEnvironment);
    return currentVisitor;
  };

  var requireKnownKeys = function requireKnownKeys(object, keys) {
    var invalidKeys = Object.keys(object).filter(function (value) {
      return !arrayIncludes(keys, value);
    });

    if (invalidKeys.length > 0) {
      throw Error("Unknown keys in object: ".concat(invalidKeys.join(', '), "."));
    }
  };

  var McidUtil = {
    getCurrentVisitor: getCurrentVisitor,
    requireKnownKeys: requireKnownKeys,
    // Exposed for unit testing
    _authState: AuthState,
    _buildVisitorOptions: buildVisitorOptions,
    _getCustomerState: getCustomerState,
    _getCustomerUserId: getCustomerUserId,
    _getCustomerIdsForOmniture: getCustomerIdsForOmniture,
    _applyCustomerIds: applyCustomerIds
  };

  function _defineProperties$r(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$r(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$r(Constructor.prototype, protoProps); if (staticProps) _defineProperties$r(Constructor, staticProps); return Constructor; }

  function _typeof$f(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$f = function _typeof(obj) { return typeof obj; }; } else { _typeof$f = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$f(obj); }
  /**
   * MCID Configuration Container Functionality.
   *
   * This file encompasses the processing of the plugin options, and creates
   * a convenient abstraction over the specific details of the configuration
   * object.
   */

  var isDefined = function isDefined(value) {
    return Boolean(typeof value !== 'undefined' && value !== null);
  };
  /**
   * Is there a global instance of the Adobe Visitor API.
   * @returns {Boolean}
   * @private
   */
  // eslint-disable-next-line no-undef


  var hasGlobalVisitorApi = function hasGlobalVisitorApi() {
    return Boolean((typeof window === "undefined" ? "undefined" : _typeof$f(window)) === 'object' && window.Visitor);
  };
  /**
   * Returns the global instance of the Adobe Visitor API.
   *
   * @returns {Object}
   * @private
   */
  // eslint-disable-next-line no-undef


  var getGlobalVisitorApi = function getGlobalVisitorApi() {
    return (typeof window === "undefined" ? "undefined" : _typeof$f(window)) === 'object' ? window.Visitor : null;
  };
  /**
   * Is there a Visitor API override provided in the configuration.
   *
   * @param {Object} adobePluginConfig
   * @returns {Boolean}
   * @private
   */


  var hasConfiguredVisitorApi = function hasConfiguredVisitorApi(adobePluginConfig) {
    return Boolean(isDefined(adobePluginConfig.visitorApi));
  };
  /**
   * Returns the Visitor API override provided in the configuration.
   *
   * @param adobePluginConfig
   * @returns {Object}
   * @private
   */


  var getConfiguredVisitorApi = function getConfiguredVisitorApi(adobePluginConfig) {
    return adobePluginConfig.visitorApi;
  };
  /**
   * Is a Visitor API instance defined in a known location.
   *
   * @private
   * @param {Object} adobePluginConfig
   */


  var hasVisitorApi = function hasVisitorApi(adobePluginConfig) {
    return hasConfiguredVisitorApi(adobePluginConfig) || hasGlobalVisitorApi();
  };
  /**
   * Return an object that abstracts away configuration values from the plugin config.
   *
   * @private
   * @param adobePluginConfig
   * @return McidConfig
   */


  var McidConfig =
  /*#__PURE__*/
  function () {
    function McidConfig() {
      var adobePluginConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!isObject$1(adobePluginConfig)) {
        throw new Error('McidConfig requires the parameter adobe plugin config object.');
      }

      this.adobePluginConfig = adobePluginConfig;
    }
    /**
     * Is the Visitor Api available.
     * @return {boolean}
     */


    _createClass$r(McidConfig, [{
      key: "isVisitorApiAvailable",
      get: function get() {
        return hasVisitorApi(this.adobePluginConfig);
      }
    }, {
      key: "isDryRun",
      get: function get() {
        return this.adobePluginConfig.dryRun === true;
      }
      /**
       * Is the MCID functionality available.
       * @returns {boolean}
       */

    }, {
      key: "isEnabled",
      get: function get() {
        return this.adobePluginConfig.enableMcid === true;
      }
    }, {
      key: "audienceManagerServer",
      get: function get() {
        return this.adobePluginConfig.audienceManagerServer || AdobeConstants.DEFAULT_AUDIENCE_MANAGER_SERVER;
      }
    }, {
      key: "audienceManagerServerSecure",
      get: function get() {
        return this.adobePluginConfig.audienceManagerServerSecure || AdobeConstants.DEFAULT_AUDIENCE_MANAGER_SERVER_SECURE;
      }
      /**
       * Organization Id.
       * @returns {string}
       */

    }, {
      key: "organizationId",
      get: function get() {
        return this.adobePluginConfig.organizationId || AdobeConstants.DEFAULT_ORGANIZATION_ID;
      }
      /**
       * Tracking Server.
       * @returns {string}
       */

    }, {
      key: "trackingServer",
      get: function get() {
        return this.adobePluginConfig.trackingServer || AdobeConstants.DEFAULT_TRACKING_SERVER;
      }
      /**
       * Tracking Server for Secure requests.
       * @returns {string}
       */

    }, {
      key: "trackingServerSecure",
      get: function get() {
        return this.adobePluginConfig.trackingServerSecure || AdobeConstants.DEFAULT_TRACKING_SERVER_SECURE;
      }
      /**
       * Marketing Cloud Server.
       * @returns {string}
       */

    }, {
      key: "marketingCloudServer",
      get: function get() {
        return this.adobePluginConfig.marketingCloudServer || AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER;
      }
      /**
       * Marketing Cloud Server for Secure requests.
       * @returns {string}
       */

    }, {
      key: "marketingCloudServerSecure",
      get: function get() {
        return this.adobePluginConfig.marketingCloudServerSecure || AdobeConstants.DEFAULT_MARKETING_CLOUD_SERVER_SECURE;
      }
      /**
       * Visitor API Instance
       *
       * Attempts to find the Visitor API in the following order
       *   - Explicitly provided in the plugin configuration
       *   - Object defined on global "window"
       *
       * @returns {Object}
       *     The Visitor API instance, Null if not found.
       *
       */

    }, {
      key: "visitorApi",
      get: function get() {
        return getConfiguredVisitorApi(this.adobePluginConfig) || getGlobalVisitorApi() || null;
      }
    }]);

    return McidConfig;
  }();

  var KNOWN_CONFIGURATION_KEYS = ['config', 'environment', 'logger'];
  /**
   * Implementation Integration point for Adobe Marketing Cloud Visitor Id (MCID, MID, MCVD).
   *
   * This function encompasses the functionaly that is required for the plugin instance
   * to integrate with the MCID service.
   *
   */

  /**
   * Configure the AppMeasurement instance.
   *
   * This function will obtain the currentVisitor from the VisitorAPI sdk,
   * apply customer ids as defined by the environment state passed in,
   * and then set the visitor object on the passed in AppMeasurement object.
   *
   *
   * @see https://github.snei.sony.com/SIE/grand-central-telemetry/issues/163
   * @param {Object} sdk           [MODIFIED] AppMeasurement Instance
   * @param {Object} options       Configuration Options
   * @param {Object} options.config        Adobe Plugin configuratino
   * @param {Object} options.environment   GCT Environment
   * @param {Object} options.logger        Logger
   * @returns {?Object} Visitor instance.  Null if not created.
   */

  var configureAppMeasurement = function configureAppMeasurement(sdk, options) {
    McidUtil.requireKnownKeys(options, KNOWN_CONFIGURATION_KEYS);
    var pluginConfig = options.config,
        environment = options.environment,
        logger = options.logger;
    var mcidConfig = new McidConfig(pluginConfig); // If not enabled, do nothing

    if (!mcidConfig.isEnabled) {
      return null;
    }

    if (!mcidConfig.isVisitorApiAvailable) {
      // eslint-disable-next-line no-unused-expressions
      logger && logger.warn('Adobe VisitorAPI is not loaded.' + ' Ensure that VisitorAPI.js is loaded, or pass in a reference via "adobeConfig.visitorApi".');
      return null;
    }

    if (mcidConfig.isDryRun) {
      // eslint-disable-next-line no-unused-expressions
      logger && logger.warn('DryRun configuration detected. Cancelling MCID Initialization.');
      return null;
    }

    var currentVisitor = McidUtil.getCurrentVisitor(mcidConfig, environment);

    if (!currentVisitor) {
      // eslint-disable-next-line no-unused-expressions
      logger && logger.warn('Unable to obtain Omniture visitor instance from VisitorAPI.');
      return null;
    } // eslint-disable-next-line no-param-reassign


    sdk.visitor = currentVisitor;
    return currentVisitor;
  };

  var AdobeMcid = {
    configureAppMeasurement: configureAppMeasurement
  };

  function _extends$6() { _extends$6 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$6.apply(this, arguments); }

  function _defineProperties$s(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$s(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$s(Constructor.prototype, protoProps); if (staticProps) _defineProperties$s(Constructor, staticProps); return Constructor; }
  /**
   * Properties that are cleared by clearVars
   * @see https://marketing.adobe.com/resources/help/en_US/sc/implement/function_clearVars.html
   * @type {RegExp}
   */

  var CUSTOM_LINK_VARS_REGEX = /^(?:prop|eVar|hier|list)[1-9][0-9]*$/;
  /**
   * Properties that are cleared by clearVars
   * @see https://marketing.adobe.com/resources/help/en_US/sc/implement/function_clearVars.html
   * @type {string[]}
   */

  var CUSTOM_LINK_VARS_LIST = ['campaign', 'channel', 'eventList', 'events', 'productList', 'products', 'purchaseID', 'state', 'transactionID', 'zip'];

  var isCustomLinkProperty = function isCustomLinkProperty(property) {
    // These are properties that are reset by clearVars();
    // propN, eVarN, hierN, listN
    if (property.match(CUSTOM_LINK_VARS_REGEX)) {
      return true;
    }

    if (CUSTOM_LINK_VARS_LIST.indexOf(property) >= 0) {
      return true;
    } // Otherwise


    return false;
  };
  /**
   * Configuration Options
   *   config.sdk = SDK Instance
   *   config.urlPrivacyFilter = Filter to use against URLs
   *
   */


  var WebSdkDispatcher =
  /*#__PURE__*/
  function () {
    function WebSdkDispatcher(config) {
      this.sdk = config.sdk;
      this.urlPrivacyFilter = config.urlPrivacyFilter; // TODO: Capture original sdk bound callback

      this.boundPluginCallback = this.sdkPluginCallback.bind(this);
    }
    /**
     * TODO: Separate out MCID integration from the dispatcher
     *
     * @param shouldRestrictData
     * @param environment
     * @param config
     * @param logger
     */


    var _proto = WebSdkDispatcher.prototype;

    _proto.initMcidVisitor = function initMcidVisitor(shouldRestrictData, environment, config, logger) {
      if (shouldRestrictData) {
        delete this.sdk.visitor;
        return;
      }

      this.mcidVisitor = AdobeMcid.configureAppMeasurement(this.sdk, {
        environment: environment,
        config: config,
        logger: logger
      });
    };

    _proto.dispatchPayload = function dispatchPayload(shouldRestrictData, payload, event) {
      var isPageViewEvent = event.type === 'PageView';

      this._configureSdkPluginFilter(shouldRestrictData);

      if (isPageViewEvent) {
        this._clearSdkVars();
      } // Assign all variables to the SDK


      _extends$6(this.sdk, payload); // For page view event we call the page tracking method t()
      // otherwise we call tl() for custom link tracking


      if (isPageViewEvent) {
        this._dispatchPageView();
      } else {
        this._dispatchPageLink(payload, event);
      }
    }
    /**
     * Use adobe's usePlugins and doPlugin attribute to override fid and mcid when user permission level is minimal.
     *
     * TODO: This does not work when a client wishes to use doPlugins themselves, e.g. Integrating with AAM.
     *
     * @param {bool} shouldRestrictData
     * @private
     */
    ;

    _proto._configureSdkPluginFilter = function _configureSdkPluginFilter(shouldRestrictData) {
      // TODO: Ensure original bound function is captured
      // TODO: Call original bound function with correct "this" context
      // TODO: GDPR Compliance Rules for AAM/Integration (current use case for client doPlugin code)
      if (shouldRestrictData) {
        this.sdk.usePlugins = true;
        this.sdk.doPlugins = this.boundPluginCallback;
      } else {
        this.sdk.usePlugins = false;
        this.sdk.doPlugins = undefined;
      }
    };

    _proto._clearSdkVars = function _clearSdkVars() {
      this.sdk.clearVars();
    };

    _proto._dispatchPageView = function _dispatchPageView() {
      this.sdk.t();
    };

    _proto._dispatchPageLink = function _dispatchPageLink(payload, event) {
      // TODO: linkName and linkType should be generated by the builder, as it needs to be calculated for each
      //       dispatcher

      /** aka: pev2 */
      var linkName = Utils$1.cleanUpString(event.name);
      /** aka: pev1, pe */

      var linkType = AdobeUtils.getLinkType(event); // Variables to transmit

      this.sdk.linkTrackVars = Object.keys(payload).filter(isCustomLinkProperty).join(','); // Events to transmit

      this.sdk.linkTrackEvents = this.sdk.events.replace(/=[0-9]+/g, ''); // TODO: Expose pev, pev2 to eventInspector somehow

      this.sdk.tl(true, linkType, linkName);
    }
    /**
     * Filters a URL
     * @param {string} url   Url to filter
     * @returns {string}
     */
    ;

    _proto.filterUrl = function filterUrl(url) {
      return this.urlPrivacyFilter(url);
    } // Set fid and mcid to empty strings so that we dont capture any unique user information for PPI.
    // eslint-disable-next-line camelcase
    ;

    _proto.sdkPluginCallback = function sdkPluginCallback(s) {
      /*eslint-disable */
      // If pageURL or referrer is blank, or invalid, the SDK will populate it with valid defaults.
      // If we unset pageURL or referrer here, it will be re-generated.
      // pageURL and referrer MUST contain a scheme (http:, https:, etc)
      // pageURL = window.location.href || window.location
      s.pageURL = this.filterUrl(s.pageURL); // s.referrer = window.document.referrer || undefined

      s.referrer = this.filterUrl(s.referrer);
      s.fid = '';
      s.mcid = '';
      /*eslint-disable */
    };

    _createClass$s(WebSdkDispatcher, [{
      key: "version",
      get: function get() {
        return "sdk_v".concat(this.sdk.version);
      }
    }]);

    return WebSdkDispatcher;
  }();

  function _extends$7() { _extends$7 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$7.apply(this, arguments); }
  var DEFAULT_SDK_SERVICE = '/adobe/appMeasurement';

  var getSdkInstance = function getSdkInstance(container, nameOrInstance) {
    // 1: String Reference
    if (isString_1(nameOrInstance)) {
      return container.get(nameOrInstance);
    } // 2: Object Instantiation


    if (nameOrInstance) {
      return nameOrInstance;
    } // 3: Default Fallback


    return container.get(DEFAULT_SDK_SERVICE);
  };

  var webSdkDispatcherFactory = (function (container) {
    var globalConfig = container.get('config'); // TODO: migrate to top level configuration config.adobe, instead of config.plugins.adobe

    var pluginConfig = _extends$7({}, (globalConfig.plugins || {}).adobe || {});

    var privacyFilter = container.get('/privacy/uriCensor');
    var sdkInstance = getSdkInstance(container, pluginConfig.sdkInstance);
    return new WebSdkDispatcher({
      sdk: sdkInstance,
      urlPrivacyFilter: privacyFilter
    });
  });

  function _defineProperties$t(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$t(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$t(Constructor.prototype, protoProps); if (staticProps) _defineProperties$t(Constructor, staticProps); return Constructor; }
  /**
   * Generates a URL query parameter string with URI encoded value
   * and trailing ampersand
   *
   * @param      {string}  key    Name of query parameter
   * @param      {mixed}   value  Value of the query parameter
   * @return     {string}  Returns the query parameter ready to append in URL
   */

  var _queryParam = function _queryParam(key, value) {
    return "".concat(key, "=").concat(encodeURIComponent(value), "&");
  };
  /**
   * Configuration Options
   *   config.xhr  Service Key representing a concrete XhrInterface implentation
   */


  var XhrDispatcher =
  /*#__PURE__*/
  function () {
    function XhrDispatcher(config) {
      this._xhr = config.xhr;
    }

    var _proto = XhrDispatcher.prototype;

    _proto.initMcidVisitor = function initMcidVisitor() {// Do nothing, this is not supported with XHR
      // API calls: https://confluence.sie.sony.com/display/GHOST/GCT+-+MCID
      // TODO: see https://jira.sie.sony.com/browse/GHOST-848
    };

    _proto.dispatchPayload = function dispatchPayload(shouldRestrictData, payload, event) {
      // Specs:
      // https://confluence.sie.sony.com/display/BWAH/Direct+POST+calls
      // https://marketing.adobe.com/resources/help/en_US/sc/implement/query_parameters.html
      var now = new Date(); // Start by building the base URL

      var adobeUrl = [// Always https
      'https://', // URL endpoint from config (should always be "smetrics.aem.playstation.com")
      payload.trackingServerSecure, // Fixed part of URL
      '/b/ss/', // Comma separated list of report suites
      payload.account, // Protocol version: "1" for Adobe JS SDK and "5" for mobile SDK, per Adobe team we should use "1"
      '/1/', // Name of the SDK, we are making our own to represent custom XHR via GCT
      // TODO: Do not rely on 4.15.0 string replacement
      'gctxhr-4.15.0/', // Finally s with a cache buster random and question mark to start query parameters list
      "s".concat(Math.floor(now.getTime() / 108E5) % 10 + Math.floor(1E13 * Math.random()), "?"), // First query param AQB=1 indicates beginning of beacon
      'AQB=1&', // Second query param NDH=1 indicates URL generates from JS (0 otherwise)
      'ndh=1&', // Third query param pf=1 is internal Adobe Use only, do not alter value on calls
      'pf=1&', // Charset is always unicode
      'ce=UTF-8&'];

      if (event.type === 'PageView') {
        // For page views only, we'll track pageName, channel and server
        adobeUrl.push(_queryParam('pageName', payload.pageName));
        adobeUrl.push(_queryParam('ch', payload.channel));
        adobeUrl.push(_queryParam('server', payload.server));
      } else {
        // For link events only (e.g. not page views):
        // pe=lnk_o <=== this is the linkType (o, d or e based on downloadLink)
        // pev2=load%20time <=== URI encoded of event name
        adobeUrl.push("pe=lnk_".concat(AdobeUtils.getLinkType(event), "&"));
        adobeUrl.push("pev2=".concat(encodeURIComponent(Utils$1.cleanUpString(event.name)), "&"));
      } // For all event types, we need to map event ids string


      adobeUrl.push(_queryParam('events', payload.events)); // For all event types, we'll map the hashed PSN account to "vid"

      adobeUrl.push(_queryParam('vid', payload.visitorID)); // For all event types, we'll include the timestamp as "ts"

      adobeUrl.push(_queryParam('ts', payload.timestamp)); // For all event types, we'll include the current time as "t"
      // Format is mm/dd/yyyy hh:mm:ss D OFS
      // D = 0 - 6 Day of Weeek (not sure which day is day 1, or whether it's consistent based on user's locale)
      // OFS is reverse timezone offset ( GMT-7 = -420, use +420)
      // t=27%2F3%2F2018%2015%3A37%3A19%205%20420

      var year = now.getYear();
      var t = ["".concat(now.getDate(), "/").concat(now.getMonth(), "/").concat(year < 1900 ? year + 1900 : year), ' ', "".concat(now.getHours(), ":").concat(now.getMinutes(), ":").concat(now.getSeconds()), ' ', now.getDay(), ' ', now.getTimezoneOffset()];
      adobeUrl.push(_queryParam('t', t.join(''))); // Serialize all eVars, props, lists and hiers
      // TODO: optimize code

      var key;

      for (var i = 1; i <= 255; i += 1) {
        // For each eVar/props (each should be given by buildPayload, so we should not
        // have to worry about generating corresponding props). Max eVar number is 255.
        // vXX=<VALUE> <=== where XX is the number of the eVar; VALUE is URI encoded
        key = "eVar".concat(i);

        if (payload[key]) {
          adobeUrl.push(_queryParam("v".concat(i), payload[key]));
        } // Props are mapped to cXX. Max number of props is 75.
        // cXX=<VALUE> <=== where XX is the number of the eVar; VALUE is D%3DvXX which is encoded of D=vXX


        key = "prop".concat(i);

        if (i <= 75 && payload[key]) {
          adobeUrl.push(_queryParam("c".concat(i), payload[key]));
        } // Hier are mapped to hXX. Max number is 5.
        // hXX=<VALUE> <=== where XX is the number of the hier; VALUE is URI encoded


        key = "hier".concat(i);

        if (i <= 5 && payload[key]) {
          adobeUrl.push(_queryParam("h".concat(i), payload[key]));
        } // List are mapped to lXX. Max number is 3.
        // lXX=<VALUE> <=== where XX is the number of the list; VALUE is URI encoded


        key = "list".concat(i);

        if (i <= 3 && payload[key]) {
          adobeUrl.push(_queryParam("l".concat(i), payload[key]));
        }
      } // Commerce properties such as products, currencyCode or purchase/transaction IDs


      if (payload.products) {
        adobeUrl.push(_queryParam('products', payload.products));
      }

      if (payload.currencyCode) {
        adobeUrl.push(_queryParam('cc', payload.currencyCode));
      }

      if (payload.purchaseID) {
        adobeUrl.push(_queryParam('purchaseID', payload.purchaseID));
      }

      if (payload.transactionID) {
        adobeUrl.push(_queryParam('xact', payload.transactionID));
      } // Special property "campaign" maps to v0


      if (payload.campaign) {
        adobeUrl.push(_queryParam('v0', payload.campaign));
      } // Generate end of beacon


      adobeUrl.push('AQE=1'); // Send the data via XHR service

      this._xhr('GET', adobeUrl.join(''), null, null); // URL sample t(): https://smetrics.aem.playstation.com/b/ss/snerdjan-dev/1/JS-1.8.0/s19342010650416?AQB=1&ndh=1&pf=1&t=27%2F3%2F2018%2015%3A57%3A36%205%20420&ts=2018-04-27T22%3A57%3A36Z&vid=14d1a5888a8b91b5184cf7163634442a94c7d5d279630333gbd9ag2649b6767g&fid=680C6502E6B614DA-29F682230943D513&ce=UTF-8&pageName=web%3Astore%3Agames%3Adetail%3Afoo&g=http%3A%2F%2Flocalhost%3A8080%2Fgrand-central-telemetry%2Fsandbox%2F&ch=web%3Astore%3Agames&server=table%20top&xact=pur%3A&events=event1%2Cevent182%2Cpurchase&products=%3Ba%3A1%3B2%3B20.00%3B%3B&v1=D%3DpageName&h1=D%3DpageName&c2=D%3Dv2&v2=usca-us-en%3Aempty%3Aempty&c3=D%3Dv3&v3=signed_in&c10=D%3Dv10&v10=detail&c15=D%3Dv15&v15=purchase&c47=D%3Dv47&v47=811342c1-aa38-c071-d16e-205854be9245&v68=http%3A%2F%2Fstore.playstation.com%2Fgame%2Ffoo&c69=2018-04-27T22%3A57%3A36.786Z&c71=D%3Dv71&v71=Mozilla%2F5.0%20%28Macintosh%20Intel%20Mac%20OS%20X%2010_13_3%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F68.0.3410.0%20Safari%2F537.36&c72=D%3Dv72&v72=web%3Astore&c74=D%3Dv74&v74=sandbox%3Adevb799%3Agct_v0.6.47%3Asdk_v1.8.0&c75=D%3Dv75&v75=14d1a5888a8b91b5184cf7163634442a94c7d5d279630333gbd9ag2649b6767g&s=3008x1692&c=24&j=1.6&v=N&k=Y&bw=1527&bh=136&AQE=1
      // URL sample tl(): https://smetrics.aem.playstation.com/b/ss/snerdjan-dev/1/JS-1.8.0/s15128219710254?AQB=1&ndh=1&pf=1&t=27%2F3%2F2018%2015%3A37%3A19%205%20420&ts=2018-04-27T22%3A37%3A18Z&vid=optoutxaba1e029c0b04713b26dca93f03328daf92e8b5e8ae54807951398c8b17b99d0&ce=UTF-8&g=http%3A%2F%2Flocalhost%3A8080%2Fgrand-central-telemetry%2Fsandbox%2F&events=event119%3D1000%2Cevent180&v39=1000&c47=D%3Dv47&v47=optoutxaba1e029c0b04713b26dca93f03328daf92e8b5e8ae54807951398c8b17b99d0&c69=2018-04-27T22%3A37%3A18.776Z&c71=D%3Dv71&v71=Mozilla%2F5.0%20%28Macintosh%20Intel%20Mac%20OS%20X%2010_13_3%29%20AppleWebKit%2F537.36%20%28KHTML%2C%20like%20Gecko%29%20Chrome%2F68.0.3410.0%20Safari%2F537.36&c72=D%3Dv72&v72=ps4%3Anav&c74=D%3Dv74&v74=sandbox%3Adevb799%3Agct_v0.6.47%3Asdk_v1.8.0&c75=D%3Dv75&v75=optoutxaba1e029c0b04713b26dca93f03328daf92e8b5e8ae54807951398c8b17b99d0&v95=wifi%3Ajpc%20boot%20test%3Alarge%20test%20jpc%3Avsh%20jpc%20test%204.50%3Aps4%3Anav%3Awhats%20new%3Atest&pe=lnk_o&pev2=load%20time&s=3008x1692&c=24&j=1.6&v=N&k=Y&bw=1527&bh=136&AQE=1
      // TODO: Browser properties to add at the end before AQE (see https://jira.sie.sony.com/browse/GHOST-847)
      //
      // s=3008x1692 <=== TBD if we need this
      // c=24 <=== TBD if we need this
      // j=1.6 <=== TBD if we need this
      // v=N <=== TBD if we need this
      // k=Y <=== TBD if we need this
      // bw=1527 <=== TBD if we need this
      // bh=136 <=== TBD if we need this
      // TODO: Current page URL and referrer (see https://jira.sie.sony.com/browse/GHOST-849)
      //
      // Current page URL
      // g=<PAGE URL> <=== URI encoded of current page URL
      // Note: if <PAGE URL> is longer than 255 characters, the value must be captured
      // through multiple parameters. See for details:
      // https://marketing.adobe.com/resources/help/en_US/sc/implement/query_parameters.html
      // Referrer
      // r=<REFERRER>
      // TODO: Support FID/MCID values (see https://jira.sie.sony.com/browse/GHOST-848)
      // - FID/MCID

    };

    _createClass$t(XhrDispatcher, [{
      key: "version",
      get: function get() {
        return 'xhr';
      }
    }]);

    return XhrDispatcher;
  }();

  function _extends$8() { _extends$8 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$8.apply(this, arguments); }
  var adobeXhrDispatcherFactory = (function (container) {
    var globalConfig = container.get('config'); // TODO: migrate to top level configuration config.adobe, instead of config.plugins.adobe

    var pluginConfig = _extends$8({}, (globalConfig.plugins || {}).adobe || {});

    var xhrInstance = container.get("/network/".concat(isString_1(pluginConfig.xhr) ? pluginConfig.xhr : 'xhrInterface')); // TODO: Deprecate local name, and alwards require a Fully Qualified Name (/network/xhrInterface);

    return new XhrDispatcher({
      xhr: xhrInstance
    });
  });

  var adobeDispatchers = {
    adobe: {
      dispatcher: {
        webSdk: {
          sdk: ''
        },
        xhr: {
          xhr: '/network/xhrInterface'
        }
      }
    },
    services: {
      factories: {
        '/adobe/webSdk': webSdkDispatcherFactory,
        '/adobe/xhr': adobeXhrDispatcherFactory
      }
    }
  };

  var cacheInterfaceFactory = (function (container) {
    // Return local storage by default
    if (isLocalStorageAvailable()) {
      return container.get('/cache/domLocalStorage');
    } // Return Memory Cache


    return container.get('/cache/memoryCache');
  });

  function _typeof$g(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$g = function _typeof(obj) { return typeof obj; }; } else { _typeof$g = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$g(obj); }
  var domLocalStorageCacheFactory = (function (container) {
    var appConfig = container.get('config');
    var config = appConfig.cache.domLocalStorage;

    if ((typeof window === "undefined" ? "undefined" : _typeof$g(window)) !== 'object') {
      throw new Error('No window object.');
    } // eslint-disable-next-line no-undef


    if (_typeof$g(window.localStorage) !== 'object') {
      throw new Error('No window.localStorage.');
    } // Attempt a new DomLocalStorage
    // eslint-disable-next-line no-undef


    return new DomStorageCache(window.localStorage, {
      namespace: config.namespace
    });
  });

  var memoryCacheFactory = (function () {
    return new MemoryCache();
  });

  var cache = {
    cache: {
      domLocalStorage: {
        namespace: 'gct'
      }
    },
    services: {
      factories: {
        '/cache/cacheInterface': cacheInterfaceFactory,
        '/cache/memoryCache': memoryCacheFactory,
        '/cache/domLocalStorage': domLocalStorageCacheFactory
      }
    }
  };

  /**
   *
   * @param {ContainerInterface} container
   * @returns {DeprecationManager}
   */

  var deprecationManagerFactory = (function (container) {
    // Overrides
    var appConfig = container.get('config');
    var deprecationConfig = appConfig.deprecation || {};
    var overrides = deprecationConfig.overrides || {};
    var alwaysThrow = deprecationConfig.alwaysThrow || false; // Logger

    var logger = container.get('Logger'); // Reference Date

    var referenceDate = container.get('/build/date'); // Final Configuration

    var config = {
      referenceDate: referenceDate,
      logger: logger,
      overrides: overrides,
      alwaysThrow: alwaysThrow
    };
    return new DeprecationManager(config);
  });

  /**
   *
   * @param {ContainerInterface} container
   * @returns {StaticDeprecationManager}
   */

  var staticDeprecationManagerFactory = (function (container) {
    var instance = new StaticDeprecationManager();

    if (!instance.deprecationManager) {
      var deprecationManager = container.get('/deprecation/deprecationManager');
      var appName = container.get('/host/appName');
      var logger = container.get('Logger');
      logger.info("Static deprecations are handled by ".concat(appName, "."));
      instance.deprecationManager = deprecationManager;
    }
  });

  var deprecation = {
    deprecation: {
      /**
       * Always throw an exception.
       * This prevents console.log from logging warnings, and will always throw an error.
       */
      alwaysThrow: false,
      overrides: {// Any deprecation overrides go in this block
      }
    },
    services: {
      factories: {
        '/deprecation/deprecationManager': deprecationManagerFactory,
        '/deprecation/staticDeprecationManager': staticDeprecationManagerFactory
      }
    }
  };

  var eventInspectorFactory = (function (container) {
    var appConfig = container.get('config');
    var config = appConfig.inspector || {};
    /**
     * Return new Event Inspector instance.
     */

    var eventInspector = new EventInspector();

    if (config.enabled) {
      eventInspector.enable();
    }

    return eventInspector;
  });

  var eventInspector = {
    inspector: {
      /**
       * Enable the event inspector at construction time.
       * This is the equivalent of calling eventInspector.enable() after creating a telemetryService instance.
       */
      enabled: false
    },
    services: {
      aliases: {
        EventInspector: '/inspector/eventInspector'
      },
      factories: {
        '/inspector/eventInspector': eventInspectorFactory
      }
    }
  };

  var eventManager = {
    services: {
      factories: {
        '/event/eventManager': function eventEventManager() {
          return new EventManager();
        }
      }
    }
  };

  /**
   *
   * @param {ContainerInterface} container
   * @returns {Date}
   */
  var gctBuildDateFactory = (function (container) {
    var buildDate = container.get('/build/rawBuildDate'); // eslint-disable-next-line no-useless-concat

    return buildDate === '@@' + 'BUILD_DATE' ? new Date() : new Date(buildDate);
  });

  var gctBuildDate = '2020-01-21T23:58:07.212Z';

  var gctBuildInfo = {
    schema: {
      enabled: false
    },
    services: {
      aliases: {
        GctBuildDate: '/build/date'
      },
      factories: {
        '/build/date': gctBuildDateFactory,
        '/build/rawBuildDate': function buildRawBuildDate() {
          return gctBuildDate;
        }
      }
    }
  };

  var appNameFactory = (function (container) {
    var appConfig = container.get('config');

    if (!appConfig.env) {
      return 'unknown-app';
    }

    return appConfig.env.appName || 'unknown-app';
  });

  var host = {
    services: {
      factories: {
        '/host/appName': appNameFactory
      }
    }
  };

  /**
   * Create a Short Term Id
   * @param container
   */

  var shortTermIdFactory = (function (container) {
    var appConfig = container.get('config');
    var appName = container.get('/host/appName');
    var config = appConfig.shortTermId || {};
    var constructorParams = {};

    if (config.cacheKey) {
      constructorParams.cacheKey = config.cacheKey;
    }

    if (config.cache) {
      constructorParams.cache = container.get(config.cache);
    }

    if (config.lifetime) {
      var stateConfig = {
        lifetime: config.lifetime
      };
      var validator = new StateValidator$1(stateConfig);
      constructorParams.validator = validator;
    }

    constructorParams.appName = appName;
    return new ShortTermId(constructorParams);
  });

  /**
   * Create a Session Id
   * @param container
   */

  var sessionIdFactory = (function (container) {
    var appConfig = container.get('config');
    var telemetryService = container.get('telemetryService');
    var config = appConfig.sessionId || {};
    var constructorParams = {};

    if (config.cacheKey) {
      constructorParams.cacheKey = config.cacheKey;
    }

    if (config.cache) {
      constructorParams.cache = container.get(config.cache);
    }

    var sessionId = new SessionId(constructorParams); // The listener is independent of both sessionId, and telemetryService and just adds an eventHandler
    // However, we don't have any need to keep the original reference.  Hopefully this doesn't get
    // rollup away.
    // eslint-disable-next-line no-unused-vars

    var prefixUpdater = new PrefixUserEventListener(sessionId, telemetryService);
    return sessionId;
  });

  /**
   * Create a Tracing Id
   */

  var tracingIdFactory = (function () {
    return new TracingId();
  });

  var identifierProviderFactory = (function (container) {
    var sessionId = container.get('/identifier/sessionId');
    var shortTermId = container.get('/identifier/shortTermId');
    var tracingId = container.get('/identifier/tracingId');
    var testIdentifiers = container.get('/identifier/testIdentifiers');
    return new IdentifierProvider({
      sessionId: sessionId,
      shortTermId: shortTermId,
      tracingId: tracingId,
      testIdentifiers: testIdentifiers
    });
  });

  var testIdentifiersFactory = (function (container) {
    var DEFAULT_CACHE_KEY = 'test-identifiers';
    var appConfig = container.get('config');
    var config = appConfig.testIdentifiers || {};
    var cacheKey = config.cacheKey || DEFAULT_CACHE_KEY;

    if (!config.cache) {
      return {};
    }

    var cache = container.get(config.cache);

    if (!cache) {
      return {};
    }

    var data = cache.get(cacheKey);
    return data || {};
  });

  /* eslint-disable quote-props */
  var identifiers = {
    sessionId: {
      /** @type {string} Service Name */
      cache: 'cache.sessionId',

      /** @type {?string} Cache Key Override */
      cacheKey: undefined
    },
    shortTermId: {
      /** @type {string} Service Name */
      cache: 'cache.shortTermId',

      /** @type {?string} Cache Key Override */
      cacheKey: undefined,

      /** @type {?number} How long the id is valid for, in ms */
      lifetime: undefined
    },
    testIdentifiers: {
      /** @type {string} Service Name */
      cache: 'cache.testIdentifiers',

      /** @type {?string} Cache Key Override */
      cacheKey: undefined
    },
    services: {
      aliases: {
        'cache.identifier': '/cache/cacheInterface',
        'cache.shortTermId': 'cache.identifier',
        'cache.sessionId': 'cache.identifier',
        'cache.testIdentifiers': 'cache.identifier'
      },
      factories: {
        '/identifier/sessionId': sessionIdFactory,
        '/identifier/shortTermId': shortTermIdFactory,
        '/identifier/tracingId': tracingIdFactory,
        '/identifier/testIdentifiers': testIdentifiersFactory,
        '/identifier/identifierProvider': identifierProviderFactory
      }
    }
  };

  var WARNING = LogLevel.WARNING,
      ERROR = LogLevel.ERROR,
      INFO = LogLevel.INFO,
      EMERGENCY = LogLevel.EMERGENCY,
      ALERT = LogLevel.ALERT,
      DEBUG = LogLevel.DEBUG,
      NOTICE = LogLevel.NOTICE,
      CRITICAL = LogLevel.CRITICAL;

  function _inheritsLoose$o(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  var BackCompatLogger =
  /*#__PURE__*/
  function (_LogDecorator) {
    _inheritsLoose$o(BackCompatLogger, _LogDecorator);

    function BackCompatLogger() {
      return _LogDecorator.apply(this, arguments) || this;
    }

    var _proto = BackCompatLogger.prototype;

    _proto.warn = function warn(message, context) {
      // TODO Deprecate
      this.log(WARNING, message, context);
    };

    _proto.groupCollapsed = function groupCollapsed(message) {
      // TODO Deprecate
      this.log(DEBUG, message, {});
    };

    _proto.groupEnd = function groupEnd() {// Do nothing
    };

    return BackCompatLogger;
  }(LogDecorator);

  var LogLevelMap = {
    EMERGENCY: EMERGENCY,
    ALERT: ALERT,
    CRITICAL: CRITICAL,
    ERROR: ERROR,
    WARNING: WARNING,
    NOTICE: NOTICE,
    INFO: INFO,
    DEBUG: DEBUG,

    /* Backwards Compatibility with JsLogger */
    TRACE: DEBUG,
    WARN: WARNING,
    TIME: DEBUG
  };

  var restrictLoggerToLogLevel = function restrictLoggerToLogLevel(logLevel, logger) {
    if (isString_1(logLevel)) {
      var requestedLogLevel = logLevel.toUpperCase(); // Requested level is OFF.
      // No Logger.

      if (requestedLogLevel === 'OFF') {
        return new NullLogger$2();
      }

      if (LogLevelMap[requestedLogLevel]) {
        // Console Logger
        return new RestrictByLogLevelDecorator(LogLevelMap[requestedLogLevel], logger);
      }
    } // Default is Error Logging only


    return new RestrictByLogLevelDecorator(ERROR, logger);
  };

  var jsonFormatter = function jsonFormatter(obj) {
    return JSON.stringify(obj, null, 2);
  };

  var loggerFactory = (function (container) {
    var config = container.get('config');
    var logConfig = config.logger || {};
    var consoleLogger = new ConsoleLogger(console);
    var logger = new MessagePrefixDecorator('[GCT] ', consoleLogger); // Finally: Convert output to JSON String?

    if (logConfig.jsonOutput) {
      logger = new ContextValueDecorator(jsonFormatter, logger);
    } // Second: Async the process
    //  TODO: solve babel issue with async
    // if (logConfig.async) {
    //     logger = new AsyncDecorator(logger);
    // }
    // First, restrict processing to the specified log level


    logger = restrictLoggerToLogLevel(config.logLevel, logger); // Backwards compatibility shim for plugin developers (adds warn, group*)

    logger = new BackCompatLogger(logger);
    return logger;
  });

  var logger = {
    logger: {
      // TODO: Move "root.logLevel" to here, and add deprecation notice
      async: false,

      /**
       * jsonOutput: boolean
       * Output to the writer as a JSON String.
       */
      jsonOutput: false
    },

    /**
     * Override the log level
     * @type {string}
     */
    logLevel: undefined,
    services: {
      aliases: {
        Logger: '/logger/console'
      },
      factories: {
        '/logger/console': loggerFactory
      }
    }
  };

  /**
   * Factory which will return a function to make network calls
   */
  var xhrInterfaceFactory = (function (container) {
    var config = container.get('config');
    var networkConfig = config.network || {};
    var xhr = isString_1(networkConfig.defaultXhr) ? networkConfig.defaultXhr : 'browserXhr';
    return container.get("/network/".concat(xhr));
  });

  var E_ERROR = -1;
  var E_ABORT = -2;
  var E_TIMEOUT = -3;
  var E_BADJSON = -4;
  /**
   * XMLHttpRequest abstraction
   *
   * @private
   *
   */

  var XHR =
  /*#__PURE__*/
  function () {
    /**
     * @callback xhr~callback
     * @param error
     * @param status
     * @param response
     * @returns {*}
     */

    /**
     * @param {string} method    - request method (assumes GET if not POST, DELETE or PUT)
     * @param {string} uri       - request target
     * @param {object} headers   - request headers
     * @param {xhr~callback} callback - callback
     */
    function XHR() {
      var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var uri = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;
      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
      this.method = /^(POST|DELETE|PUT)$/i.test(method) ? method.toUpperCase() : 'GET';
      this.uri = uri;
      this.headers = headers || {};

      this.callback = callback || function () {};

      this._logger = options.logger;
    }
    /**
     * Opens a request
     *
     * @param {string}   body    - request body (ignored for GET / DELETE)
     */


    var _proto = XHR.prototype;

    _proto.open = function open() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      // eslint-disable-next-line no-undef
      var request = new XMLHttpRequest();
      request.open(this.method, this.uri, true);
      Object.keys(this.headers).forEach(function (key) {
        request.setRequestHeader(key, _this.headers[key]);
      });

      if (this.timeout !== undefined) {
        request.timeout = this.timeout;
      }

      var callback = this.callback;

      request.onload = function () {
        var status = request.status;
        var response = request.responseText; // Empty responses aren't valid JSON, but some Kamaji calls erroneously return them.
        // Note: Content-Type headers can contain a suffix of parameters.

        var claimsToBeJson = /^application\/json/i.test(request.getResponseHeader('Content-Type'));

        if (claimsToBeJson && response.trim().length > 0) {
          try {
            response = JSON.parse(response);
          } catch (e) {
            _this._logger.error('Request returned invalid JSON', {
              uri: _this.uri,
              response: response
            });

            callback(true, E_BADJSON, 'InvalidJsonError: JSON Parse Error.');
          }
        }

        callback(status >= 400, status, response);
      };

      request.onerror = function () {
        callback(true, E_ERROR, 'HttpError: The server responded with an error.');
      };

      request.onabort = function () {
        callback(true, E_ABORT, 'ConnectionError: HTTP Request Terminated.');
      };

      request.ontimeout = function () {
        callback(true, E_TIMEOUT, 'TimeoutError: Server failed to respond after configured timeout.');
      };

      this._logger.debug('XHR Request Created.', {
        method: this.method,
        uri: this.uri,
        body: body
      });

      request.send(this.method === 'POST' || this.method === 'PUT' ? body : null);
    };

    return XHR;
  }();

  /**
   * Factory which will return a function to make network calls
   * using default browser XML HTTP Request
   */
  // TODO: determine what sort of callback do we want overrides to pass in?

  var configuredXhr = function configuredXhr(config) {
    return function (method, url, headers, body, callback) {
      var request = new XHR(method, url, headers, callback, config);
      request.open(body);
    };
  };

  var browserXhrFactory = (function (container) {
    var xhrConfig = {
      logger: container.get('Logger')
    };
    return configuredXhr(xhrConfig);
  });

  var network = {
    network: {
      defaultXhr: 'browserXhr' // TODO: add debugEndpoint feature with GHOST-768
      // debugEndpoint: '127.0.0.1'

    },
    services: {
      factories: {
        '/network/xhrInterface': xhrInterfaceFactory,
        '/network/browserXhr': browserXhrFactory
      }
    }
  };

  /* global AppMeasurement */
  var appMeasurementFactory = (function () {
    return new AppMeasurement();
  });

  /**
   * Default Compatibility Factory
   * Update to a concrete factory when able to refactor to dependency injection / remove serviceLocator from plugin.
   */

  var adobePluginFactory = createTransitionPluginFactory('adobe', AdobePlugin);

  var pluginAdobe = {
    plugins: {
      adobe: {// dispatcher: 'webSdk'
        // dispatcher: '/adobe/dispatcher/webSdk'
      }
    },
    services: {
      factories: {
        '/adobe/appMeasurement': appMeasurementFactory,
        '/plugin/adobe': adobePluginFactory
      }
    }
  };

  /**
   * Default Compatibility Factory
   * Update to a concrete factory when able to refactor to dependency injection / remove serviceLocator from plugin.
   */

  var clairvoyancePluginFactory = createTransitionPluginFactory('clairvoyance', ClairvoyancePlugin);

  var pluginClairvoyance = {
    plugins: {
      clairvoyance: {}
    },
    services: {
      factories: {
        '/plugin/clairvoyance': clairvoyancePluginFactory
      }
    }
  };

  var pluginKamaji = {
    plugins: {
      kamaji: {}
    },
    services: {
      factories: {
        '/plugin/kamaji': kamajiPluginFactory
      }
    }
  };

  /* eslint-disable no-param-reassign */

  var censor$1 = function censor(uriObject) {
    uriObject.userInfo = undefined;
    uriObject.query = replaceValueByCharacterCategory(uriObject.query) || undefined;
    uriObject.hash = undefined;
    return uriObject;
  };

  var uriCensorFactory = (function () {
    return function (uri) {
      return censorUri(uri, censor$1);
    };
  });

  var privacy = {
    services: {
      factories: {
        '/privacy/uriCensor': uriCensorFactory
      }
    }
  };

  /** `Object#toString` result references. */

  var objectTag$4 = '[object Object]';
  /** Used for built-in method references. */

  var funcProto$2 = Function.prototype,
      objectProto$f = Object.prototype;
  /** Used to resolve the decompiled source of functions. */

  var funcToString$2 = funcProto$2.toString;
  /** Used to check objects for own properties. */

  var hasOwnProperty$d = objectProto$f.hasOwnProperty;
  /** Used to infer the `Object` constructor. */

  var objectCtorString = funcToString$2.call(Object);
  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */

  function isPlainObject$2(value) {
    if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$4) {
      return false;
    }

    var proto = _getPrototype(value);

    if (proto === null) {
      return true;
    }

    var Ctor = hasOwnProperty$d.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString$2.call(Ctor) == objectCtorString;
  }

  var isPlainObject_1 = isPlainObject$2;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeMin = Math.min;
  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */

  function baseIntersection(arrays, iteratee, comparator) {
    var includes = comparator ? _arrayIncludesWith : _arrayIncludes,
        length = arrays[0].length,
        othLength = arrays.length,
        othIndex = othLength,
        caches = Array(othLength),
        maxLength = Infinity,
        result = [];

    while (othIndex--) {
      var array = arrays[othIndex];

      if (othIndex && iteratee) {
        array = _arrayMap(array, _baseUnary(iteratee));
      }

      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new _SetCache(othIndex && array) : undefined;
    }

    array = arrays[0];
    var index = -1,
        seen = caches[0];

    outer: while (++index < length && result.length < maxLength) {
      var value = array[index],
          computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;

      if (!(seen ? _cacheHas(seen, computed) : includes(result, computed, comparator))) {
        othIndex = othLength;

        while (--othIndex) {
          var cache = caches[othIndex];

          if (!(cache ? _cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }

        if (seen) {
          seen.push(computed);
        }

        result.push(value);
      }
    }

    return result;
  }

  var _baseIntersection = baseIntersection;

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */

  function castArrayLikeObject(value) {
    return isArrayLikeObject_1(value) ? value : [];
  }

  var _castArrayLikeObject = castArrayLikeObject;

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */

  var intersection = _baseRest(function (arrays) {
    var mapped = _arrayMap(arrays, _castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? _baseIntersection(mapped) : [];
  });
  var intersection_1 = intersection;

  /* Built-in method references for those with the same name as other `lodash` methods. */

  var nativeIsFinite = _root.isFinite;
  /**
   * Checks if `value` is a finite primitive number.
   *
   * **Note:** This method is based on
   * [`Number.isFinite`](https://mdn.io/Number/isFinite).
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(3);
   * // => true
   *
   * _.isFinite(Number.MIN_VALUE);
   * // => true
   *
   * _.isFinite(Infinity);
   * // => false
   *
   * _.isFinite('3');
   * // => false
   */

  function isFinite$1(value) {
    return typeof value == 'number' && nativeIsFinite(value);
  }

  var _isFinite = isFinite$1;

  /** `Object#toString` result references. */

  var numberTag$4 = '[object Number]';
  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */

  function isNumber$2(value) {
    return typeof value == 'number' || isObjectLike_1(value) && _baseGetTag(value) == numberTag$4;
  }

  var isNumber_1 = isNumber$2;

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `""`, `undefined`, and `NaN` are falsey.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {Array} array The array to compact.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact$1(array) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (value) {
        result[resIndex++] = value;
      }
    }

    return result;
  }

  var compact_1 = compact$1;

  var A = 'a',
      B = 'b',
      D = 'd',
      E = 'e',
      F = 'f',
      I = 'i',
      N = 'n',
      O = 'o',
      R = 'r',
      S = 's';
  var builtInSchema = {
    "schemaVersion": 1,
    "version": "1.0",
    "eventTemplates": {
      "baseEvent": {
        "type": E,
        "properties": {
          "deeplink": {
            "type": S,
            "c": R
          },
          "experimentData": {
            "type": A,
            "c": O,
            "collection": {
              "type": E,
              "c": O,
              "properties": {
                "experimentId": {
                  "type": S,
                  "c": O
                },
                "univexId": {
                  "type": S,
                  "c": O
                },
                "variantId": {
                  "type": S,
                  "c": O
                }
              }
            }
          },
          "httpReferrer": {
            "type": S,
            "c": O
          },
          "location": {
            "type": S,
            "c": R
          },
          "locationType": {
            "type": S,
            "c": R
          },
          "name": {
            "type": S,
            "c": R
          },
          "pageUrl": {
            "type": S,
            "c": R
          },
          "time": {
            "type": D,
            "c": R
          },
          "type": {
            "type": S,
            "c": R
          },
          "url": {
            "type": S,
            "c": R
          },
          "sessionId": {
            "type": S,
            "c": R
          },
          "shortTermId": {
            "type": S,
            "c": R
          },
          "testCaseId": {
            "type": S,
            "c": R
          },
          "testSessionId": {
            "type": S,
            "c": R
          }
        }
      },
      "recommendation": {
        "type": E,
        "c": O,
        "properties": {
          "name": {
            "type": S,
            "c": O
          },
          "sku": {
            "type": S,
            "c": O
          }
        }
      },
      "recommendations": {
        "type": A,
        "c": O,
        "collection": {
          "_include": ["recommendation"]
        }
      },
      "tile": {
        "type": E,
        "c": O,
        "properties": {
          "campaignId": {
            "type": S,
            "c": O
          },
          "ctaType": {
            "type": S,
            "c": O
          },
          "productTitle": {
            "type": S,
            "c": O
          },
          "sponsored": {
            "type": B,
            "c": O
          },
          "tileAuthor": {
            "type": S,
            "c": O
          },
          "tileTitle": {
            "type": S,
            "c": O
          },
          "tileCaption": {
            "type": S,
            "c": O
          },
          "tileId": {
            "type": S,
            "c": O
          },
          "tileLanguage": {
            "type": S,
            "c": O
          },
          "postAnythingHasText": {
            "type": B,
            "c": O
          },
          "postAnythingHasImage": {
            "type": B,
            "c": O
          },
          "postAnythingHasUrl": {
            "type": B,
            "c": O
          },
          "postAnythingHasGameTag": {
            "type": B,
            "c": O
          },
          "postAnythingHasFriendTag": {
            "type": B,
            "c": O
          },
          "tileTrackingId": {
            "type": S,
            "c": O
          },
          "tileType": {
            "type": S,
            "c": O
          },
          "tilePosition": {
            "type": I,
            "c": O
          }
        }
      },
      "tiles": {
        "type": A,
        "c": O,
        "collection": {
          "_include": ["tile"]
        }
      },
      "transaction": {
        "type": E,
        "c": O,
        "properties": {
          "currencyCode": {
            "type": S,
            "c": O
          },
          "paymentMethod": {
            "type": S,
            "c": O
          },
          "products": {
            "type": A,
            "c": O,
            "collection": {
              "type": E,
              "c": O,
              "properties": {
                "findingMethod": {
                  "type": S,
                  "c": O
                },
                "merchCategory": {
                  "type": S,
                  "c": O
                },
                "name": {
                  "type": S,
                  "c": O
                },
                "pstpCampaign": {
                  "type": S,
                  "c": O
                },
                "quantity": {
                  "type": I,
                  "c": O
                },
                "recAnchor": {
                  "type": S,
                  "c": O
                },
                "recCampaign": {
                  "type": S,
                  "c": O
                },
                "totalPrice": {
                  "type": F,
                  "c": O
                },
                "totalRevenue": {
                  "type": F,
                  "c": O
                },
                "totalDiscount": {
                  "type": F,
                  "c": O
                },
                "totalOrderLevelDiscount": {
                  "type": F,
                  "c": O
                },
                "walletRevenue": {
                  "type": F,
                  "c": O
                },
                "promotionalMarketingRevenue": {
                  "type": F,
                  "c": O
                },
                "sku": {
                  "type": S,
                  "c": O
                }
              }
            }
          },
          "purchaseID": {
            "type": S,
            "c": R
          },
          "transactionID": {
            "type": S,
            "c": R
          },
          "type": {
            "type": S,
            "c": R
          },
          "useWallet": {
            "type": B,
            "c": R
          }
        }
      }
    },
    "events": {
      "Click": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "allowAdditionalData": {
            "type": B,
            "c": O
          },
          "allowPersonalizedRecs": {
            "type": B,
            "c": O
          },
          "allowPersonalizedAds": {
            "type": B,
            "c": O
          },
          "apiStatus": {
            "type": S,
            "c": O
          },
          "banner": {
            "type": S,
            "c": O
          },
          "clickType": {
            "type": S,
            "c": O
          },
          "clickLocation": {
            "type": S,
            "c": O
          },
          "clickMetadata": {
            "type": S,
            "c": O
          },
          "contentDetail": {
            "type": S,
            "c": O
          },
          "displayPrice": {
            "type": S,
            "c": O
          },
          "downloadClick": {
            "type": B,
            "c": O
          },
          "exitClick": {
            "type": B,
            "c": O
          },
          "findingMethod": {
            "type": S,
            "c": O
          },
          "formAction": {
            "type": S,
            "c": O
          },
          "formLocation": {
            "type": S,
            "c": O
          },
          "griefReportItem": {
            "type": S,
            "c": O
          },
          "griefReportReason": {
            "type": S,
            "c": O
          },
          "genre": {
            "type": S,
            "c": O
          },
          "hasAttachment": {
            "type": B,
            "c": O
          },
          "hasColorChanged": {
            "type": B,
            "c": O
          },
          "hasImage": {
            "type": B,
            "c": O
          },
          "hasImageChanged": {
            "type": B,
            "c": O
          },
          "hasGameTagged": {
            "type": B,
            "c": O
          },
          "hasPlayersTagged": {
            "type": I,
            "c": O
          },
          "hasPlayersInvited": {
            "type": I,
            "c": O
          },
          "hasPurchaseIntent": {
            "type": B,
            "c": O
          },
          "hasSticker": {
            "type": B,
            "c": O
          },
          "hasText": {
            "type": B,
            "c": O
          },
          "urlsPosted": {
            "type": I,
            "c": O
          },
          "hasVideo": {
            "type": B,
            "c": O
          },
          "impressionTime": {
            "type": I,
            "c": O
          },
          "isPlaytimeUnlimited": {
            "type": B,
            "c": O
          },
          "maturity": {
            "type": S,
            "c": O
          },
          "merchCategory": {
            "type": S,
            "c": O
          },
          "multiViewTimeSpent": {
            "type": I,
            "c": O
          },
          "networkName": {
            "type": S,
            "c": O
          },
          "playerId": {
            "type": S,
            "c": O
          },
          "playtimeAgeGroup": {
            "type": S,
            "c": O
          },
          "playtimeDurationChange": {
            "type": I,
            "c": O
          },
          "productClassification1": {
            "type": S,
            "c": O
          },
          "productClassification2": {
            "type": S,
            "c": O
          },
          "productClassification3": {
            "type": S,
            "c": O
          },
          "productName": {
            "type": S,
            "c": O
          },
          "productSku": {
            "type": S,
            "c": O
          },
          "publisher": {
            "type": S,
            "c": O
          },
          "ratingNumber": {
            "type": I,
            "c": O
          },
          "recCampaign": {
            "type": S,
            "c": O
          },
          "recommendation": {
            "_include": ["recommendation"]
          },
          "recommendationSrc": {
            "type": S,
            "c": O
          },
          "releaseDate": {
            "type": S,
            "c": O
          },
          "searchFilter": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "searchTerm": {
            "type": S,
            "c": O
          },
          "sortOrder": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "streamType": {
            "type": S,
            "c": O
          },
          "textPostUrlDomain": {
            "type": S,
            "c": O
          },
          "tile": {
            "_include": ["tile"]
          },
          "tiles": {
            "_include": ["tiles"]
          },
          "transaction": {
            "_include": ["transaction"]
          },
          "videoType": {
            "type": S,
            "c": O
          },
          "videoFormat": {
            "type": S,
            "c": O
          },
          "videoId": {
            "type": S,
            "c": O
          },
          "videoSeasonNum": {
            "type": I,
            "c": O
          },
          "videoTitle": {
            "type": S,
            "c": O
          },
          "videoEpisodeName": {
            "type": S,
            "c": O
          },
          "videoEpisodeNum": {
            "type": I,
            "c": O
          }
        }
      },
      "Impression": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "banners": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "bannerType": {
            "type": S,
            "c": O
          },
          "publisher": {
            "type": S,
            "c": O
          },
          "tiles": {
            "_include": ["tiles"]
          },
          "recCampaign": {
            "type": S,
            "c": O
          },
          "recommendations": {
            "_include": ["recommendations"]
          },
          "transaction": {
            "_include": ["transaction"]
          }
        }
      },
      "LoadTime": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "bootInfo": {
            "c": R,
            "type": S
          },
          "dataSizeGroup": {
            "type": S,
            "c": R
          },
          "loadTime": {
            "type": F,
            "c": R
          },
          "timings": {
            "type": A,
            "c": R,
            "collection": {
              "type": E,
              "c": R,
              "properties": {
                "name": {
                  "c": R,
                  "type": S
                },
                "startTime": {
                  "c": R,
                  "type": F
                },
                "duration": {
                  "c": R,
                  "type": F
                },
                "bootInfo": {
                  "c": O,
                  "type": S
                },
                "metricInfo": {
                  "c": O,
                  "type": S
                }
              }
            }
          }
        }
      },
      "PageView": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "banners": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "bannerType": {
            "type": S,
            "c": O
          },
          "bootInfo": {
            "type": S,
            "c": O
          },
          "dataSizeGroup": {
            "type": S,
            "c": O
          },
          "clickType": {
            "type": S,
            "c": O
          },
          "community": {
            "type": E,
            "c": O,
            "properties": {
              "id": {
                "type": S,
                "c": O
              },
              "language": {
                "type": S,
                "c": O
              },
              "name": {
                "type": S,
                "c": O
              },
              "permissions": {
                "type": S,
                "c": O
              },
              "productTitle": {
                "type": S,
                "c": O
              },
              "timeZone": {
                "type": S,
                "c": O
              },
              "titleId": {
                "type": S,
                "c": O
              }
            }
          },
          "contentDetail": {
            "type": S,
            "c": O
          },
          "displayPrice": {
            "type": S,
            "c": O
          },
          "emailCampaign": {
            "type": S,
            "c": O
          },
          "emailRecipient": {
            "type": S,
            "c": O
          },
          "experienceId": {
            "type": S,
            "c": O
          },
          "findingMethod": {
            "type": S,
            "c": O
          },
          "formAction": {
            "type": S,
            "c": O
          },
          "formLocation": {
            "type": S,
            "c": O
          },
          "genre": {
            "type": S,
            "c": O
          },
          "loadTime": {
            "type": F,
            "c": O
          },
          "marketingCampaign": {
            "type": S,
            "c": O
          },
          "maturity": {
            "type": S,
            "c": O
          },
          "merchCategory": {
            "type": S,
            "c": O
          },
          "oskZeroStateResult": {
            "type": B,
            "c": O
          },
          "pstpCampaign": {
            "type": S,
            "c": O
          },
          "productClassification1": {
            "type": S,
            "c": O
          },
          "productClassification2": {
            "type": S,
            "c": O
          },
          "productClassification3": {
            "type": S,
            "c": O
          },
          "productName": {
            "type": S,
            "c": O
          },
          "productSku": {
            "type": S,
            "c": O
          },
          "productType": {
            "type": S,
            "c": O
          },
          "publisher": {
            "type": S,
            "c": O
          },
          "referrerLocation": {
            "type": S,
            "c": O
          },
          "recAnchor": {
            "type": S,
            "c": O
          },
          "recommendations": {
            "_include": ["recommendations"]
          },
          "recCampaign": {
            "type": S,
            "c": O
          },
          "releaseDate": {
            "type": S,
            "c": O
          },
          "searchResult": {
            "type": S,
            "c": O
          },
          "searchTerm": {
            "type": S,
            "c": O
          },
          "searchPosition": {
            "type": I,
            "c": O
          },
          "searchCount": {
            "type": I,
            "c": O
          },
          "searchCampaign": {
            "type": B,
            "c": O
          },
          "tiles": {
            "_include": ["tiles"]
          },
          "tournamentName": {
            "type": S,
            "c": O
          },
          "tournamentFormat": {
            "type": S,
            "c": O
          },
          "tournamentStageInfo": {
            "type": S,
            "c": O
          },
          "tournamentPrizeInfo": {
            "type": S,
            "c": O
          },
          "tournamentStartTime": {
            "type": D,
            "c": O
          },
          "tournamentVideoType": {
            "type": S,
            "c": O
          },
          "tournamentType": {
            "type": S,
            "c": O
          },
          "tournamentSponsors": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "hasCompletedTournamentSignUp": {
            "type": B,
            "c": O
          },
          "tournamentPlayersSignedUp": {
            "type": I,
            "c": O
          },
          "maturityRating": {
            "type": S,
            "c": O
          },
          "totalStrands": {
            "type": S,
            "c": O
          },
          "transaction": {
            "_include": ["transaction"]
          },
          "userGenes": {
            "type": S,
            "c": O
          },
          "viewCollectionId": {
            "type": S,
            "c": O
          },
          "viewIds": {
            "type": A,
            "c": O,
            "collection": {
              "type": S,
              "c": O
            }
          }
        }
      },
      "Startup": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "privacySettings": {
            "type": S,
            "c": R
          },
          "startupType": {
            "type": S,
            "c": R
          },
          "startupContext": {
            "type": S,
            "c": R
          },
          "bootInfo": {
            "type": S,
            "c": R
          },
          "dataSizeGroup": {
            "type": S,
            "c": R
          }
        }
      },
      "UserFacingError": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "apiUrl": {
            "type": S,
            "c": R
          },
          "code": {
            "type": S,
            "allowNumber": true,
            "c": R
          },
          "description": {
            "type": S,
            "c": R
          },
          "error": {
            "type": S,
            "c": R
          },
          "overrideAppName": {
            "type": S,
            "c": R
          },
          "overrideBuildVersion": {
            "type": S,
            "c": R
          },
          "severity": {
            "type": S,
            "c": R
          },
          "stack": {
            "type": S,
            "c": R
          },
          "errorMetadata": {
            "type": E,
            "c": R,
            "properties": {
              "skuId": {
                "type": S,
                "c": R
              },
              "titleId": {
                "type": S,
                "c": R
              },
              "errorUuid": {
                "type": S,
                "c": R
              },
              "somethingLong": {
                "type": S,
                "c": R
              }
            }
          }
        }
      },
      "VideoStream": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "banners": {
            "c": O,
            "type": A,
            "collection": {
              "type": S,
              "c": O
            }
          },
          "currentViewedTime": {
            "type": F,
            "c": O
          },
          "displayPrice": {
            "type": S,
            "c": O
          },
          "elapsedTime": {
            "type": F,
            "c": O
          },
          "genre": {
            "type": S,
            "c": O
          },
          "maturity": {
            "type": S,
            "c": O
          },
          "networkName": {
            "type": S,
            "c": O
          },
          "playerId": {
            "type": S,
            "c": O
          },
          "playerPosition": {
            "type": I,
            "c": O
          },
          "playerSoundEnabled": {
            "type": B,
            "c": O
          },
          "publisher": {
            "type": S,
            "c": O
          },
          "releaseDate": {
            "type": S,
            "c": O
          },
          "streamType": {
            "type": S,
            "c": O
          },
          "totalViewedTime": {
            "type": F,
            "c": O
          },
          "tile": {
            "_include": ["tile"]
          },
          "videoAction": {
            "type": S,
            "c": O
          },
          "videoType": {
            "type": S,
            "c": O
          },
          "videoDuration": {
            "type": F,
            "c": O
          },
          "videoEpisodeName": {
            "type": S,
            "c": O
          },
          "videoEpisodeNum": {
            "type": I,
            "c": O
          },
          "videoFormat": {
            "type": S,
            "c": O
          },
          "videoId": {
            "type": S,
            "c": O
          },
          "videoSeasonNum": {
            "type": I,
            "c": O
          },
          "videoTitle": {
            "type": S,
            "c": O
          },
          "windowMode": {
            "type": S,
            "c": O
          },
          "videoUrl": {
            "type": S,
            "c": O
          }
        }
      },
      "Search": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "searchTerm": {
            "type": S,
            "c": O
          },
          "searchType": {
            "type": S,
            "c": O
          },
          "retryCount": {
            "type": I,
            "c": O
          },
          "resultCount": {
            "type": I,
            "c": O
          },
          "itemIdNamespace": {
            "type": S,
            "c": O
          },
          "itemIds": {
            "type": A,
            "c": O,
            "collection": {
              "c": O,
              "type": S
            }
          },
          "contentType": {
            "type": S,
            "c": O
          },
          "storeRegion": {
            "type": S,
            "c": O
          },
          "storeLanguage": {
            "type": S,
            "c": O
          }
        }
      },
      "Dwell": {
        "_include": ["baseEvent"],
        "c": O,
        "properties": {
          "tile": {
            "_include": ["tile"]
          },
          "dwellTargetType": {
            "type": S,
            "c": O
          },
          "dwellTargetId": {
            "type": S,
            "c": O
          },
          "dwellStartTime": {
            "type": D,
            "c": O
          },
          "dwellEndTime": {
            "type": D,
            "c": O
          },
          "dwellDurationTime": {
            "type": I,
            "c": O
          }
        }
      },
      "AdClick": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "clickType": {
            "type": S,
            "c": R
          },
          "exitClick": {
            "type": B,
            "c": R
          },
          "banner": {
            "type": S,
            "c": R
          },
          "tile": {
            "_include": ["tile"],
            "properties": {
              "campaignId": {
                "c": R
              },
              "productTitle": {
                "c": R
              },
              "tileId": {
                "c": R
              },
              "tilePosition": {
                "c": R
              },
              "tileType": {
                "c": R
              }
            }
          }
        }
      },
      "AdImpression": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "banners": {
            "type": A,
            "c": R,
            "collection": {
              "type": S,
              "c": R
            }
          },
          "bannerType": {
            "type": S,
            "c": R
          },
          "tiles": {
            "type": A,
            "c": R,
            "collection": {
              "_include": ["tile"],
              "properties": {
                "campaignId": {
                  "c": R
                },
                "productTitle": {
                  "c": R
                },
                "tileId": {
                  "c": R
                },
                "tilePosition": {
                  "c": R
                },
                "tileType": {
                  "c": R
                }
              }
            }
          }
        }
      },
      "AdVideoStream": {
        "_include": ["baseEvent"],
        "c": R,
        "properties": {
          "banners": {
            "type": A,
            "c": R,
            "collection": {
              "type": S,
              "c": R
            }
          },
          "currentViewedTime": {
            "type": F,
            "c": R
          },
          "elapsedTime": {
            "type": F,
            "c": R
          },
          "playerId": {
            "type": S,
            "c": R
          },
          "streamType": {
            "type": S,
            "c": R
          },
          "totalViewedTime": {
            "type": F,
            "c": R
          },
          "videoAction": {
            "type": S,
            "c": R
          },
          "videoDuration": {
            "type": F,
            "c": R
          },
          "videoFormat": {
            "type": S,
            "c": R
          },
          "videoType": {
            "type": S,
            "c": R
          },
          "videoUrl": {
            "type": S,
            "c": R
          },
          "windowMode": {
            "type": S,
            "c": R
          },
          "tile": {
            "_include": ["tile"],
            "properties": {
              "campaignId": {
                "c": R
              },
              "productTitle": {
                "c": R
              },
              "tileId": {
                "c": R
              },
              "tilePosition": {
                "c": R
              },
              "tileType": {
                "c": R
              }
            }
          }
        }
      }
    },
    "environment": {
      "type": E,
      "c": R,
      "properties": {
        "platformPrivacyWs1": {
          "type": S,
          "c": R
        },
        "locale": {
          "type": S,
          "c": R
        },
        "deviceId": {
          "type": S,
          "c": O
        },
        "visitorId": {
          "type": S,
          "c": O
        },
        "appName": {
          "type": S,
          "c": R
        },
        "buildVersion": {
          "type": S,
          "c": R
        },
        "deviceType": {
          "type": S,
          "c": R
        },
        "charset": {
          "type": S,
          "c": R
        },
        "signedIn": {
          "type": B,
          "c": R
        },
        "plusUserType": {
          "type": S,
          "c": R
        },
        "isPlusUser": {
          "type": B,
          "c": R
        },
        "userAge": {
          "type": I,
          "c": O
        },
        "zipcode": {
          "type": I,
          "c": O
        },
        "postalCode": {
          "type": S,
          "c": O
        },
        "DMA": {
          "type": S,
          "c": O
        },
        "networkType": {
          "type": S,
          "c": R
        },
        "screenInfo": {
          "type": S,
          "c": R
        },
        "platformVersion": {
          "type": S,
          "c": R
        },
        "psnAccountLanguage": {
          "type": S,
          "c": R
        },
        "psnAccountRegion": {
          "type": S,
          "c": R
        },
        "psnowMembershipType": {
          "type": S,
          "c": R
        },
        "adobeMCID": {
          "type": S,
          "c": R
        },
        "constellationId": {
          "type": S,
          "c": R
        }
      }
    },
    "overlays": {
      "default": [],
      "sample-override": ["sample-override"],
      "commerce": ["commerce"],
      "monaco": ["monaco"],
      "titan": ["titan"],
      "blackbird": ["blackbird"],
      "feeds": ["feeds"],
      "apollo2": ["apollo2"],
      "psnow-auto-renew": ["psnow-auto-renew"],
      "psnow-player-menu": ["psnow-player-menu"],
      "valkyrie-storefront": ["valkyrie-storefront"],
      "valkyrie-vue": ["valkyrie-vue"],
      "chronos": ["chronos"],
      "friends": ["friends"],
      "yaka": ["yaka"],
      "unibeam": ["unibeam"]
    },
    "overlayFiles": {
      "sample-override": {
        "events": {
          "LoadTime": {
            "properties": {
              "bootInfo": {
                "c": O
              }
            }
          },
          "UserFacingError": {
            "properties": {
              "myCustomProperty": {
                "type": S,
                "c": R
              }
            }
          },
          "CustomEvent": {
            "_include": ["baseEvent"],
            "properties": {
              "deeplink": {
                "c": O
              }
            }
          }
        }
      },
      "commerce": {
        "events": {
          "UserFacingError": {
            "properties": {
              "errorMetadata": {
                "properties": {
                  "httpStatus": {
                    "type": I,
                    "c": R
                  },
                  "requestId": {
                    "type": S,
                    "c": O
                  },
                  "correlationId": {
                    "type": S,
                    "c": O
                  },
                  "skus": {
                    "type": S,
                    "c": O
                  }
                }
              }
            }
          },
          "Click": {
            "c": R,
            "properties": {
              "recommendation": {
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "tile": {
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "ctaType": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "sponsored": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileCaption": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tileLanguage": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileTrackingId": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  }
                }
              },
              "tiles": {
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "findingMethod": {
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "pstpCampaign": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recAnchor": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "sku": {
                          "c": R
                        },
                        "campaignId": {
                          "type": S,
                          "c": R
                        },
                        "coverContextType": {
                          "type": S,
                          "c": R
                        },
                        "discountSubType": {
                          "type": S,
                          "c": R
                        },
                        "discountType": {
                          "type": S,
                          "c": R
                        },
                        "displayPrice": {
                          "type": S,
                          "c": R
                        },
                        "imageUrl": {
                          "type": S,
                          "c": R
                        },
                        "itemId": {
                          "type": S,
                          "c": R
                        },
                        "itemPrice": {
                          "type": I,
                          "c": R
                        },
                        "itemSubtype": {
                          "type": S,
                          "c": R
                        },
                        "itemType": {
                          "type": S,
                          "c": R
                        },
                        "recContext": {
                          "type": S,
                          "c": R
                        },
                        "recUuid": {
                          "type": S,
                          "c": R
                        },
                        "rewardId": {
                          "type": S,
                          "c": R
                        },
                        "trackContentType": {
                          "type": S,
                          "c": R
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "allowAdditionalData": {
                "c": R
              },
              "allowPersonalizedRecs": {
                "c": R
              },
              "allowPersonalizedAds": {
                "c": R
              },
              "banner": {
                "c": R
              },
              "clickType": {
                "c": R
              },
              "clickLocation": {
                "c": R
              },
              "clickMetadata": {
                "c": R
              },
              "contentDetail": {
                "c": R
              },
              "displayPrice": {
                "c": R
              },
              "exitClick": {
                "c": R
              },
              "findingMethod": {
                "c": R
              },
              "formAction": {
                "c": R
              },
              "formLocation": {
                "c": R
              },
              "genre": {
                "c": R
              },
              "maturity": {
                "c": R
              },
              "networkName": {
                "c": R
              },
              "playerId": {
                "c": R
              },
              "productClassification1": {
                "c": R
              },
              "productClassification2": {
                "c": R
              },
              "productClassification3": {
                "c": R
              },
              "productName": {
                "c": R
              },
              "productSku": {
                "c": R
              },
              "publisher": {
                "c": R
              },
              "recCampaign": {
                "c": R
              },
              "releaseDate": {
                "c": R
              },
              "searchFilter": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "searchTerm": {
                "c": R
              },
              "sortOrder": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "videoType": {
                "c": R
              },
              "videoFormat": {
                "c": R
              },
              "videoId": {
                "c": R
              },
              "videoSeasonNum": {
                "c": R
              },
              "videoTitle": {
                "c": R
              },
              "videoEpisodeName": {
                "c": R
              },
              "videoEpisodeNum": {
                "c": R
              },
              "searchCampaign": {
                "type": B,
                "c": R
              },
              "searchPosition": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "searchPosition_commerce"
                }
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "adType": {
                "type": S,
                "c": R
              },
              "cartEventType": {
                "type": S,
                "c": R
              },
              "catHierarchy": {
                "type": S,
                "c": R
              },
              "downloadStatus": {
                "type": S,
                "c": R
              },
              "entryPoint": {
                "type": S,
                "c": R
              },
              "focus": {
                "type": S,
                "c": R
              },
              "interactType": {
                "type": S,
                "c": R
              },
              "isRedownload": {
                "type": B,
                "c": R
              },
              "isSuggested": {
                "type": B,
                "c": R
              },
              "itemCount": {
                "type": I,
                "c": R
              },
              "kamajiEventType": {
                "type": S,
                "c": R
              },
              "layoutId": {
                "type": S,
                "c": R
              },
              "menuContext": {
                "type": S,
                "c": R
              },
              "pageName": {
                "type": S,
                "c": R
              },
              "pageNumber": {
                "type": I,
                "c": R
              },
              "playGoType": {
                "type": S,
                "c": R
              },
              "productId": {
                "type": S,
                "c": R
              },
              "recommendationType": {
                "type": I,
                "c": R
              },
              "resultCount": {
                "type": I,
                "c": R
              },
              "sourceContext": {
                "type": S,
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "userGenes": {
                "type": S,
                "c": R
              },
              "userType": {
                "type": S,
                "c": R
              },
              "vAmount": {
                "type": S,
                "c": R
              },
              "vCode": {
                "type": S,
                "c": R
              },
              "vId": {
                "type": S,
                "c": R
              },
              "vType": {
                "type": S,
                "c": R
              }
            }
          },
          "Impression": {
            "c": R,
            "properties": {
              "bannerType": {
                "c": R
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "recommendations": {
                "collection": {
                  "c": R,
                  "properties": {
                    "name": {
                      "c": R
                    },
                    "sku": {
                      "c": R
                    }
                  }
                },
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "campaignId": {
                          "type": S,
                          "c": R
                        },
                        "discountSubType": {
                          "type": S,
                          "c": R
                        },
                        "discountType": {
                          "type": S,
                          "c": R
                        },
                        "displayPrice": {
                          "type": S,
                          "c": R
                        },
                        "findingMethod": {
                          "c": R
                        },
                        "imageUrl": {
                          "type": S,
                          "c": R
                        },
                        "itemId": {
                          "type": S,
                          "c": R
                        },
                        "itemPrice": {
                          "type": I,
                          "c": R
                        },
                        "itemSubtype": {
                          "type": S,
                          "c": R
                        },
                        "itemType": {
                          "type": S,
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "recContext": {
                          "type": S,
                          "c": R
                        },
                        "recUuid": {
                          "type": S,
                          "c": R
                        },
                        "rewardId": {
                          "type": S,
                          "c": R
                        },
                        "sku": {
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "trackContentType": {
                          "type": S,
                          "c": R
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "recommendation": {
                "_include": ["recommendation"],
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "adType": {
                "type": S,
                "c": R
              },
              "categoryId": {
                "type": S,
                "c": R
              },
              "catHierarchy": {
                "type": S,
                "c": R
              },
              "focus": {
                "type": S,
                "c": R
              },
              "isSuggested": {
                "type": B,
                "c": R
              },
              "kamajiEventType": {
                "type": S,
                "c": R
              },
              "menuContext": {
                "type": S,
                "c": R
              },
              "pageName": {
                "type": S,
                "c": R
              },
              "pageNumber": {
                "type": S,
                "c": R
              },
              "productId": {
                "type": S,
                "c": R
              },
              "recommendationType": {
                "type": I,
                "c": R
              },
              "resultCount": {
                "type": I,
                "c": R
              },
              "sourceContext": {
                "type": S,
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "userGenes": {
                "type": S,
                "c": R
              },
              "userType": {
                "type": S,
                "c": R
              }
            }
          },
          "VideoStream": {
            "c": R,
            "properties": {
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "currentViewedTime": {
                "c": R
              },
              "displayPrice": {
                "c": R
              },
              "elapsedTime": {
                "type": F,
                "c": R
              },
              "genre": {
                "c": R
              },
              "maturity": {
                "c": R
              },
              "networkName": {
                "c": R
              },
              "playerId": {
                "c": R
              },
              "releaseDate": {
                "c": R
              },
              "streamType": {
                "c": R
              },
              "totalViewedTime": {
                "type": F,
                "c": R
              },
              "videoAction": {
                "c": R
              },
              "videoDuration": {
                "type": F,
                "c": R
              },
              "videoEpisodeName": {
                "c": R
              },
              "videoEpisodeNum": {
                "c": R
              },
              "videoFormat": {
                "c": R
              },
              "videoId": {
                "c": R
              },
              "videoSeasonNum": {
                "c": R
              },
              "videoTitle": {
                "c": R
              },
              "videoType": {
                "c": R
              },
              "videoUrl": {
                "c": R
              },
              "windowMode": {
                "c": R
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "appVer": {
                "type": S,
                "c": R
              },
              "drmContentId": {
                "type": S,
                "c": R
              },
              "focus": {
                "type": S,
                "c": R
              },
              "kamajiEventType": {
                "type": S,
                "c": R
              },
              "playBackMethod": {
                "type": S,
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "userType": {
                "type": S,
                "c": R
              }
            }
          },
          "PageView": {
            "c": R,
            "properties": {
              "recommendation": {
                "_include": ["recommendation"],
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "recommendations": {
                "c": R,
                "collection": {
                  "c": R,
                  "properties": {
                    "name": {
                      "c": R
                    },
                    "sku": {
                      "c": R
                    }
                  }
                }
              },
              "tile": {
                "_include": ["tile"],
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "ctaType": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "sponsored": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileCaption": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tileLanguage": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileTrackingId": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  }
                }
              },
              "tiles": {
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "campaignId": {
                          "type": S,
                          "c": R
                        },
                        "coverContextType": {
                          "type": S,
                          "c": R
                        },
                        "discountAmt": {
                          "type": S,
                          "c": R
                        },
                        "discountCode": {
                          "type": S,
                          "c": R
                        },
                        "discountSubType": {
                          "type": S,
                          "c": R
                        },
                        "discountType": {
                          "type": S,
                          "c": R
                        },
                        "displayPrice": {
                          "type": S,
                          "c": R
                        },
                        "findingMethod": {
                          "c": R
                        },
                        "imageUrl": {
                          "type": S,
                          "c": R
                        },
                        "itemId": {
                          "type": S,
                          "c": R
                        },
                        "itemPrice": {
                          "type": I,
                          "c": R
                        },
                        "itemSubtype": {
                          "type": S,
                          "c": R
                        },
                        "itemType": {
                          "type": S,
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "pstpCampaign": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recAnchor": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "recContext": {
                          "type": S,
                          "c": R
                        },
                        "revFindingMethod": {
                          "type": S,
                          "c": R
                        },
                        "rewardId": {
                          "type": S,
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "trackContentType": {
                          "type": S,
                          "c": R
                        },
                        "sku": {
                          "c": R
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "bannerType": {
                "c": R
              },
              "clickType": {
                "c": R
              },
              "contentDetail": {
                "c": R
              },
              "displayPrice": {
                "c": R
              },
              "experienceId": {
                "c": R
              },
              "formAction": {
                "c": R
              },
              "formLocation": {
                "c": R
              },
              "genre": {
                "c": R
              },
              "loadTime": {
                "c": R
              },
              "marketingCampaign": {
                "c": R
              },
              "maturity": {
                "c": R
              },
              "productClassification1": {
                "c": R
              },
              "productClassification2": {
                "c": R
              },
              "productClassification3": {
                "c": R
              },
              "productName": {
                "c": R
              },
              "productSku": {
                "c": R
              },
              "productType": {
                "c": R
              },
              "publisher": {
                "c": R
              },
              "referrerLocation": {
                "c": R
              },
              "releaseDate": {
                "c": R
              },
              "searchCampaign": {
                "c": R
              },
              "searchPosition": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "searchPosition_commerce"
                }
              },
              "searchResult": {
                "c": R
              },
              "searchTerm": {
                "c": R
              },
              "searchCount": {
                "c": R
              },
              "userGenes": {
                "c": R
              },
              "viewCollectionId": {
                "c": R
              },
              "viewIds": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "searchFilter": {
                "type": A,
                "c": R,
                "collection": {
                  "type": S,
                  "c": R
                }
              },
              "sortOrder": {
                "type": A,
                "c": R,
                "collection": {
                  "type": S,
                  "c": R
                }
              },
              "oskZeroStateResult": {
                "type": B,
                "c": R
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "catHierarchy": {
                "type": S,
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "eaAccessIsVaultPurchase": {
                "type": B,
                "c": R
              },
              "eaAccessIsPFTPurchase": {
                "type": B,
                "c": R
              },
              "entryPoint": {
                "type": S,
                "c": R
              },
              "etsId": {
                "type": S,
                "c": R
              },
              "focus": {
                "type": S,
                "c": R
              },
              "fundingInformation": {
                "type": S,
                "c": R
              },
              "itemCount": {
                "type": I,
                "c": R
              },
              "itemIds": {
                "type": A,
                "c": R,
                "collection": {
                  "c": R,
                  "type": S
                }
              },
              "kamajiEventType": {
                "type": S,
                "c": R
              },
              "layoutId": {
                "type": S,
                "c": R
              },
              "menuContext": {
                "type": S,
                "c": R
              },
              "pageName": {
                "type": S,
                "c": R
              },
              "pageNumber": {
                "type": I,
                "c": R
              },
              "personalizations": {
                "type": A,
                "c": R,
                "collection": {
                  "c": R,
                  "type": S
                }
              },
              "purchaseType": {
                "type": I,
                "c": R
              },
              "resultCount": {
                "type": I,
                "c": R
              },
              "searchType": {
                "type": S,
                "c": R
              },
              "userType": {
                "type": S,
                "c": R
              },
              "walletFundingValue": {
                "type": I,
                "c": R
              },
              "memorySnapshot": {
                "type": S,
                "c": O
              },
              "visitedLocations": {
                "type": S,
                "c": O
              }
            }
          }
        }
      },
      "monaco": {
        "events": {
          "UserFacingError": {
            "c": R,
            "properties": {
              "errorMetadata": {
                "c": R,
                "properties": {
                  "appCacheStatus": {
                    "type": I,
                    "c": R
                  },
                  "appName": {
                    "type": S,
                    "c": R
                  },
                  "errApps": {
                    "type": A,
                    "c": R,
                    "collection": {
                      "type": E,
                      "c": R,
                      "properties": {
                        "title_id": {
                          "c": R,
                          "type": S
                        },
                        "name": {
                          "c": R,
                          "type": S
                        }
                      }
                    }
                  },
                  "filename": {
                    "type": S,
                    "c": R
                  },
                  "imgUrl": {
                    "type": S,
                    "c": R
                  },
                  "message": {
                    "type": S,
                    "c": R
                  },
                  "method": {
                    "type": S,
                    "c": R
                  },
                  "newStrandSize": {
                    "type": I,
                    "c": R
                  },
                  "oldStrandSize": {
                    "type": I,
                    "c": R
                  },
                  "pageName": {
                    "type": S,
                    "c": R
                  },
                  "readyState": {
                    "type": I,
                    "c": R
                  },
                  "responseMsg": {
                    "type": S,
                    "c": R
                  },
                  "result": {
                    "type": S,
                    "c": R
                  },
                  "retries": {
                    "type": I,
                    "c": R
                  },
                  "strandId": {
                    "type": S,
                    "c": R
                  },
                  "vshVersion": {
                    "type": S,
                    "c": R
                  }
                }
              }
            }
          },
          "MonacoCustomEvent": {
            "_include": ["baseEvent"],
            "type": E,
            "c": O,
            "properties": {
              "strandId": {
                "type": S,
                "c": O
              },
              "tilePosition": {
                "type": S,
                "c": O
              },
              "contentId": {
                "type": S,
                "c": O
              },
              "strandPosition": {
                "type": S,
                "c": O
              },
              "partnerNpTitleId": {
                "type": S,
                "c": O
              },
              "contentType": {
                "type": S,
                "c": O
              },
              "contentName": {
                "type": S,
                "c": O
              },
              "page": {
                "type": S,
                "c": O
              },
              "partnerName": {
                "type": S,
                "c": O
              },
              "totalNumberOfStrands": {
                "type": S,
                "c": O
              },
              "country": {
                "type": S,
                "c": O
              },
              "language": {
                "type": S,
                "c": O
              },
              "searchState": {
                "type": S,
                "c": O
              },
              "searchTerm": {
                "type": S,
                "c": O
              }
            }
          }
        }
      },
      "titan": {
        "events": {
          "UserFacingError": {
            "c": R,
            "properties": {
              "errorMetadata": {
                "properties": {
                  "appName": {
                    "type": S,
                    "c": R
                  },
                  "url": {
                    "type": S,
                    "c": O
                  },
                  "method": {
                    "type": S,
                    "c": R
                  },
                  "message": {
                    "type": S,
                    "c": R
                  },
                  "vshVersion": {
                    "type": S,
                    "c": R
                  }
                },
                "c": R
              }
            }
          }
        }
      },
      "blackbird": {
        "events": {
          "Click": {
            "properties": {
              "kamajiEventType": {
                "type": S,
                "c": O
              },
              "searchPosition": {
                "type": I,
                "c": O
              },
              "cust05": {
                "type": S,
                "c": O
              },
              "cust06": {
                "type": S,
                "c": O
              },
              "cust07": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "cust07_blackbird"
                }
              },
              "cust15": {
                "type": S,
                "c": O
              },
              "userType": {
                "type": S,
                "c": O
              },
              "searchType": {
                "type": S,
                "c": O
              },
              "resultCount": {
                "type": I,
                "c": O
              },
              "searchIndex": {
                "type": I,
                "c": O
              },
              "entryPoint": {
                "type": S,
                "c": O
              },
              "refSource": {
                "type": S,
                "c": O
              },
              "sourceContext": {
                "type": S,
                "c": O
              },
              "destContext": {
                "type": S,
                "c": O
              },
              "interactType": {
                "type": S,
                "c": O
              },
              "galleryViewButtonType": {
                "type": S,
                "c": O
              },
              "titleId": {
                "type": S,
                "c": O
              },
              "actorOnlineId": {
                "type": S,
                "c": O
              },
              "relatedOnlineIds": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "focus": {
                "type": S,
                "c": O
              },
              "action": {
                "type": I,
                "c": O
              },
              "messageId": {
                "type": S,
                "c": O
              },
              "currentPageUrl": {
                "type": S,
                "c": O
              },
              "isPlusUser": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "isPlusUser_blackbird"
                }
              },
              "storyType": {
                "type": S,
                "c": O
              }
            }
          },
          "Impression": {
            "properties": {
              "kamajiEventType": {
                "type": S,
                "c": O
              },
              "isPlusUser": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "isPlusUser_blackbird"
                }
              },
              "focus": {
                "type": S,
                "c": O
              },
              "cust15": {
                "type": S,
                "c": O
              },
              "userType": {
                "type": S,
                "c": O
              },
              "productId": {
                "type": S,
                "c": O
              },
              "action": {
                "type": I,
                "c": O
              },
              "sourceContext": {
                "type": S,
                "c": O
              },
              "destContext": {
                "type": S,
                "c": O
              },
              "interactType": {
                "type": S,
                "c": O
              },
              "actorOnlineId": {
                "type": S,
                "c": O
              },
              "relatedOnlineIds": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              },
              "galleryViewButtonType": {
                "type": S,
                "c": O
              },
              "communityId": {
                "type": S,
                "c": O
              },
              "backgroundPicture": {
                "type": I,
                "c": O
              },
              "communityName": {
                "type": S,
                "c": O
              },
              "missionStatement": {
                "type": I,
                "c": O
              },
              "privacy": {
                "type": I,
                "c": O
              },
              "profilePicture": {
                "type": I,
                "c": O
              },
              "timezone": {
                "type": S,
                "c": O
              },
              "messageAttached": {
                "type": I,
                "c": O
              },
              "onlineIdAffected": {
                "type": S,
                "c": O
              },
              "attachmentTypeId": {
                "type": I,
                "c": O
              },
              "titleId": {
                "type": S,
                "c": O
              },
              "messageId": {
                "type": S,
                "c": O
              },
              "originalMessageId": {
                "type": S,
                "c": O
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "impressionType": {
                "type": S,
                "c": O
              },
              "storyId": {
                "type": S,
                "c": O
              },
              "plusUserAffected": {
                "type": I,
                "c": O
              },
              "role": {
                "type": I,
                "c": O
              },
              "notificationSettings": {
                "type": S,
                "c": O
              },
              "expId": {
                "type": S,
                "c": O
              },
              "itemId": {
                "type": S,
                "c": O
              },
              "entryPoint": {
                "type": S,
                "c": O
              },
              "cust05": {
                "type": S,
                "c": O
              },
              "cust10": {
                "type": S,
                "c": O
              },
              "cust16": {
                "type": S,
                "c": O
              },
              "cust19": {
                "type": S,
                "c": O
              },
              "pageUrl": {
                "type": S,
                "c": O
              },
              "storyType": {
                "type": S,
                "c": O
              }
            }
          },
          "VideoStream": {
            "properties": {
              "kamajiEventType": {
                "type": S,
                "c": O
              },
              "isPlusUser": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "isPlusUser_blackbird"
                }
              },
              "focus": {
                "type": S,
                "c": O
              },
              "accessToken": {
                "type": S,
                "c": O
              },
              "contentPageUrl": {
                "type": S,
                "c": O
              },
              "userType": {
                "type": S,
                "c": O
              },
              "pcnt": {
                "type": I,
                "c": O
              },
              "playBackMethod": {
                "type": S,
                "c": O
              },
              "playBackMode": {
                "type": S,
                "c": O
              },
              "ipAddress": {
                "type": S,
                "c": O
              },
              "contentType": {
                "type": S,
                "c": O
              },
              "pageUrl": {
                "type": S,
                "c": O
              },
              "refSource": {
                "type": S,
                "c": O
              },
              "userAgent": {
                "type": S,
                "c": O
              },
              "videoUrl": {
                "type": S,
                "c": O
              },
              "itemId": {
                "type": S,
                "c": O
              },
              "entryPoint": {
                "type": S,
                "c": O
              }
            }
          }
        }
      },
      "feeds": {
        "events": {
          "Click": {
            "properties": {
              "friendTagsList": {
                "type": S,
                "c": O
              },
              "storyId": {
                "type": S,
                "c": O
              },
              "titleId": {
                "type": S,
                "c": O
              }
            }
          }
        }
      },
      "apollo2": {
        "events": {
          "Click": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_apollo2"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": N,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_apollo2"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_apollo2"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              },
              "displayEstimatedWaitTimeOnOpen": {
                "type": N,
                "c": O
              },
              "displayEstimatedWaitTimeOnOpenMS": {
                "type": N,
                "c": O
              },
              "displayPlaceInLineOnOpen": {
                "type": N,
                "c": O
              },
              "displayQueuePosition": {
                "type": N,
                "c": O
              },
              "displayWaitTimeEstimate": {
                "type": S,
                "c": O
              },
              "ESRBRating": {
                "type": S,
                "c": O
              },
              "gameIndex": {
                "type": N,
                "c": O
              },
              "Genre": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              },
              "productId": {
                "type": S,
                "c": O
              },
              "queuePosition": {
                "type": N,
                "c": O
              },
              "oskZeroStateResult": {
                "type": B,
                "c": O
              },
              "searchInvalidTerm": {
                "type": S,
                "c": O
              },
              "searchResults": {
                "type": N,
                "c": O
              },
              "searchPosition": {
                "type": N,
                "c": O
              },
              "searchCount": {
                "type": N,
                "c": O
              },
              "sku": {
                "type": S,
                "c": O
              },
              "Sort": {
                "type": S,
                "c": O
              },
              "SwitchToProductID": {
                "type": S,
                "c": O
              },
              "catalogId": {
                "type": S,
                "c": O
              },
              "catalogTrackingId": {
                "type": S,
                "c": O
              },
              "tile": {
                "type": E,
                "c": O,
                "properties": {
                  "productId": {
                    "type": S,
                    "c": O
                  },
                  "rowPosition": {
                    "type": I,
                    "c": O
                  },
                  "parentId": {
                    "type": S,
                    "c": O
                  },
                  "parentTitle": {
                    "type": S,
                    "c": O
                  },
                  "parentTrackingId": {
                    "type": S,
                    "c": O
                  }
                }
              },
              "userInitiated": {
                "type": B,
                "c": O
              },
              "waitTimeErrorMargin": {
                "type": N,
                "c": O
              },
              "waitTimeErrorMarginPct": {
                "type": N,
                "c": O
              },
              "waitTimeEstimate": {
                "type": N,
                "c": O
              },
              "enabledFeatureFlags": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              },
              "downloadHistoryCount": {
                "type": N,
                "c": O
              }
            }
          },
          "LoadTime": {
            "properties": {
              "code": {
                "type": S,
                "c": R
              },
              "description": {
                "type": S,
                "c": R
              },
              "componentCode": {
                "type": S,
                "c": R
              },
              "clientSessionId": {
                "type": S,
                "c": R
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_apollo2"
                }
              },
              "componentVersion": {
                "type": S,
                "c": R
              },
              "environment": {
                "type": S,
                "c": R
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": R
              },
              "locale": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "locale_apollo2"
                }
              },
              "membershipType": {
                "type": S,
                "c": R
              },
              "networkType": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "networkType_apollo2"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": R
              }
            }
          },
          "PageView": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_apollo2"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": F,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_apollo2"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_apollo2"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "productId": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              },
              "viewCollectionName": {
                "type": S,
                "c": O
              }
            }
          },
          "UserFacingError": {
            "properties": {
              "code": {
                "type": S,
                "c": R
              },
              "description": {
                "type": S,
                "c": R
              },
              "componentCode": {
                "type": S,
                "c": R
              },
              "clientSessionId": {
                "type": S,
                "c": R
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_apollo2"
                }
              },
              "componentVersion": {
                "type": S,
                "c": R
              },
              "environment": {
                "type": S,
                "c": R
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": R
              },
              "locale": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "locale_apollo2"
                }
              },
              "membershipType": {
                "type": S,
                "c": R
              },
              "networkType": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "networkType_apollo2"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": R
              },
              "deeplinkUri": {
                "type": S,
                "c": O
              },
              "productId": {
                "type": S,
                "c": O
              },
              "productName": {
                "type": S,
                "c": O
              },
              "errorMetadata": {
                "type": E,
                "c": R,
                "properties": {
                  "appendedName": {
                    "type": S,
                    "c": R
                  },
                  "code": {
                    "type": S,
                    "c": R
                  },
                  "col": {
                    "type": S,
                    "c": R
                  },
                  "error": {
                    "type": S,
                    "c": R
                  },
                  "lineNum": {
                    "type": S,
                    "c": R
                  },
                  "message": {
                    "type": S,
                    "c": R
                  },
                  "name": {
                    "type": S,
                    "c": R
                  },
                  "position": {
                    "type": N,
                    "c": R
                  },
                  "query": {
                    "type": S,
                    "c": R
                  },
                  "stack": {
                    "type": S,
                    "c": R
                  },
                  "totalSize": {
                    "type": N,
                    "c": R
                  },
                  "payload": {
                    "type": E,
                    "c": R,
                    "properties": {
                      "eventCode": {
                        "type": S,
                        "c": R
                      },
                      "name": {
                        "type": S,
                        "c": R
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "psnow-auto-renew": {
        "events": {
          "Click": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowautorenew"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": N,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_psnowautorenew"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_psnowautorenew"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "stringValue": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              }
            }
          },
          "PageView": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowautorenew"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": F,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_psnowautorenew"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_psnowautorenew"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "stringValue": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              }
            }
          },
          "UserFacingError": {
            "properties": {
              "code": {
                "type": S,
                "c": R
              },
              "description": {
                "type": S,
                "c": R
              },
              "componentCode": {
                "type": S,
                "c": R
              },
              "clientSessionId": {
                "type": S,
                "c": R
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowautorenew"
                }
              },
              "componentVersion": {
                "type": S,
                "c": R
              },
              "environment": {
                "type": S,
                "c": R
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": R
              },
              "locale": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "locale_psnowautorenew"
                }
              },
              "membershipType": {
                "type": S,
                "c": R
              },
              "networkType": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "networkType_psnowautorenew"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "stringValue": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": R
              }
            }
          },
          "LoadTime": {
            "properties": {
              "code": {
                "type": S,
                "c": R
              },
              "description": {
                "type": S,
                "c": R
              },
              "componentCode": {
                "type": S,
                "c": R
              },
              "clientSessionId": {
                "type": S,
                "c": R
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowautorenew"
                }
              },
              "componentVersion": {
                "type": S,
                "c": R
              },
              "environment": {
                "type": S,
                "c": R
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": R
              },
              "locale": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "locale_psnowautorenew"
                }
              },
              "membershipType": {
                "type": S,
                "c": R
              },
              "networkType": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "networkType_psnowautorenew"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": R
              }
            }
          }
        }
      },
      "psnow-player-menu": {
        "events": {
          "Click": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowplayermenu"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": N,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_psnowplayermenu"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_psnowplayermenu"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              },
              "newValue": {
                "type": N,
                "c": O
              },
              "oldValue": {
                "type": N,
                "c": O
              }
            }
          },
          "PageView": {
            "properties": {
              "code": {
                "type": S,
                "c": O
              },
              "description": {
                "type": S,
                "c": O
              },
              "componentCode": {
                "type": S,
                "c": O
              },
              "clientSessionId": {
                "type": S,
                "c": O
              },
              "apiUrl": {
                "type": S,
                "c": O
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowplayermenu"
                }
              },
              "componentVersion": {
                "type": S,
                "c": O
              },
              "environment": {
                "type": S,
                "c": O
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": O
              },
              "loadTime": {
                "type": F,
                "c": O
              },
              "locale": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "locale_psnowplayermenu"
                }
              },
              "membershipType": {
                "type": S,
                "c": O
              },
              "networkType": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "networkType_psnowplayermenu"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": O
              }
            }
          },
          "UserFacingError": {
            "properties": {
              "code": {
                "type": S,
                "c": R
              },
              "description": {
                "type": S,
                "c": R
              },
              "componentCode": {
                "type": S,
                "c": R
              },
              "clientSessionId": {
                "type": S,
                "c": R
              },
              "appName": {
                "type": S,
                "c": O,
                "sbahn": {
                  "alias": "appName_psnowplayermenu"
                }
              },
              "componentVersion": {
                "type": S,
                "c": R
              },
              "environment": {
                "type": S,
                "c": R
              },
              "eventSource": {
                "type": S,
                "c": O
              },
              "isHomeshare": {
                "type": B,
                "c": O
              },
              "isMember": {
                "type": B,
                "c": O
              },
              "line": {
                "type": S,
                "c": R
              },
              "locale": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "locale_psnowplayermenu"
                }
              },
              "membershipType": {
                "type": S,
                "c": R
              },
              "networkType": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "networkType_psnowplayermenu"
                }
              },
              "platform": {
                "type": S,
                "c": O
              },
              "SMCID": {
                "type": S,
                "c": O
              },
              "streamSessionId": {
                "type": S,
                "c": O
              },
              "subscriptionSku": {
                "type": S,
                "c": O
              },
              "vshVersion": {
                "type": S,
                "c": R
              }
            }
          }
        }
      },
      "valkyrie-storefront": {
        "events": {
          "Click": {
            "_include": ["baseEvent"],
            "c": R,
            "properties": {
              "recommendation": {
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "tile": {
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "ctaType": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "sponsored": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileCaption": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tileLanguage": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileTrackingId": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  }
                }
              },
              "tiles": {
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "findingMethod": {
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "pstpCampaign": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recAnchor": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "sku": {
                          "c": R
                        },
                        "walletRevenue": {
                          "c": R
                        },
                        "promotionalMarketingRevenue": {
                          "c": R
                        },
                        "totalDiscount": {
                          "c": R
                        },
                        "voucherValue": {
                          "c": R,
                          "type": N
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "allowAdditionalData": {
                "c": R
              },
              "allowPersonalizedRecs": {
                "c": R
              },
              "allowPersonalizedAds": {
                "c": R
              },
              "banner": {
                "c": R
              },
              "clickType": {
                "c": R
              },
              "clickLocation": {
                "c": R
              },
              "clickMetadata": {
                "c": R
              },
              "contentDetail": {
                "c": R
              },
              "displayPrice": {
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "exitClick": {
                "c": R
              },
              "findingMethod": {
                "c": R
              },
              "formAction": {
                "c": R
              },
              "formLocation": {
                "c": R
              },
              "genre": {
                "c": R
              },
              "maturity": {
                "c": R
              },
              "networkName": {
                "c": R
              },
              "playerId": {
                "c": R
              },
              "productClassification1": {
                "c": R
              },
              "productClassification2": {
                "c": R
              },
              "productClassification3": {
                "c": R
              },
              "productName": {
                "c": R
              },
              "productSku": {
                "c": R
              },
              "publisher": {
                "c": R
              },
              "recCampaign": {
                "c": R
              },
              "releaseDate": {
                "c": R
              },
              "searchFilter": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "searchTerm": {
                "c": R
              },
              "sortOrder": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "videoType": {
                "c": R
              },
              "videoFormat": {
                "c": R
              },
              "videoId": {
                "c": R
              },
              "videoSeasonNum": {
                "c": R
              },
              "videoTitle": {
                "c": R
              },
              "videoEpisodeName": {
                "c": R
              },
              "videoEpisodeNum": {
                "c": R
              }
            }
          },
          "Impression": {
            "c": R,
            "properties": {
              "bannerType": {
                "c": R
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "recommendations": {
                "collection": {
                  "c": R,
                  "properties": {
                    "name": {
                      "c": R
                    },
                    "sku": {
                      "c": R
                    }
                  }
                },
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "findingMethod": {
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "sku": {
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "walletRevenue": {
                          "c": R
                        },
                        "promotionalMarketingRevenue": {
                          "c": R
                        },
                        "totalDiscount": {
                          "c": R
                        },
                        "voucherValue": {
                          "c": R,
                          "type": N
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "recommendation": {
                "_include": ["recommendation"],
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              }
            }
          },
          "PageView": {
            "_include": ["baseEvent"],
            "c": R,
            "properties": {
              "recommendation": {
                "_include": ["recommendation"],
                "c": R,
                "properties": {
                  "name": {
                    "c": R
                  },
                  "sku": {
                    "c": R
                  }
                }
              },
              "recommendations": {
                "c": R,
                "collection": {
                  "c": R,
                  "properties": {
                    "name": {
                      "c": R
                    },
                    "sku": {
                      "c": R
                    }
                  }
                }
              },
              "tile": {
                "_include": ["tile"],
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "ctaType": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "sponsored": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileCaption": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tileLanguage": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileTrackingId": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  }
                }
              },
              "tiles": {
                "c": R
              },
              "transaction": {
                "c": R,
                "properties": {
                  "currencyCode": {
                    "c": R
                  },
                  "paymentMethod": {
                    "c": R
                  },
                  "products": {
                    "c": R,
                    "collection": {
                      "c": R,
                      "properties": {
                        "findingMethod": {
                          "c": R
                        },
                        "merchCategory": {
                          "c": R
                        },
                        "name": {
                          "c": R
                        },
                        "pstpCampaign": {
                          "c": R
                        },
                        "quantity": {
                          "c": R
                        },
                        "recAnchor": {
                          "c": R
                        },
                        "recCampaign": {
                          "c": R
                        },
                        "totalPrice": {
                          "c": R
                        },
                        "totalRevenue": {
                          "c": R
                        },
                        "sku": {
                          "c": R
                        },
                        "walletRevenue": {
                          "c": R
                        },
                        "promotionalMarketingRevenue": {
                          "c": R
                        },
                        "totalDiscount": {
                          "c": R
                        },
                        "voucherValue": {
                          "c": R,
                          "type": N
                        }
                      }
                    }
                  },
                  "transactionID": {
                    "c": R
                  },
                  "type": {
                    "c": R
                  }
                }
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "bannerType": {
                "c": R
              },
              "clickType": {
                "c": R
              },
              "contentDetail": {
                "c": R
              },
              "displayPrice": {
                "c": R
              },
              "eaMemberAccess": {
                "type": S,
                "c": R,
                "enum": ["ea access member", "ea access trial member"]
              },
              "eaAccessIsVaultPurchase": {
                "type": B,
                "c": R
              },
              "eaAccessIsPFTPurchase": {
                "type": B,
                "c": R
              },
              "experienceId": {
                "c": R
              },
              "formAction": {
                "c": R
              },
              "formLocation": {
                "c": R
              },
              "genre": {
                "c": R
              },
              "loadTime": {
                "c": R
              },
              "marketingCampaign": {
                "c": R
              },
              "maturity": {
                "c": R
              },
              "productClassification1": {
                "c": R
              },
              "productClassification2": {
                "c": R
              },
              "productClassification3": {
                "c": R
              },
              "productName": {
                "c": R
              },
              "productSku": {
                "c": R
              },
              "productType": {
                "c": R
              },
              "publisher": {
                "c": R
              },
              "referrerLocation": {
                "c": R
              },
              "releaseDate": {
                "c": R
              },
              "searchCampaign": {
                "c": R
              },
              "searchPosition": {
                "type": S,
                "c": R,
                "sbahn": {
                  "alias": "searchPosition_valkyriestorefront"
                }
              },
              "searchResult": {
                "c": R
              },
              "searchTerm": {
                "c": R
              },
              "userGenes": {
                "c": R
              },
              "viewCollectionId": {
                "c": R
              },
              "viewIds": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "searchFilter": {
                "type": A,
                "c": R,
                "collection": {
                  "type": S,
                  "c": R
                }
              },
              "sortOrder": {
                "type": A,
                "c": R,
                "collection": {
                  "type": S,
                  "c": R
                }
              }
            }
          }
        }
      },
      "valkyrie-vue": {
        "events": {
          "UserFacingError": {
            "properties": {
              "errorMetadata": {
                "properties": {
                  "amazonPay": {
                    "type": B,
                    "c": O
                  },
                  "browser": {
                    "type": E,
                    "c": O,
                    "properties": {
                      "name": {
                        "type": S,
                        "c": O
                      },
                      "version": {
                        "type": S,
                        "c": O
                      }
                    }
                  },
                  "cobraCode": {
                    "type": S,
                    "c": O
                  },
                  "httpStatus": {
                    "type": I,
                    "c": O
                  },
                  "dma": {
                    "type": E,
                    "c": O,
                    "properties": {
                      "dmaCode": {
                        "type": I,
                        "c": O
                      },
                      "dmaZipCode": {
                        "type": S,
                        "c": O
                      }
                    }
                  },
                  "pathName": {
                    "type": S,
                    "c": O
                  },
                  "presentation": {
                    "type": S,
                    "c": O
                  },
                  "referrer": {
                    "type": S,
                    "c": O
                  },
                  "routeName": {
                    "type": S,
                    "c": O
                  }
                }
              },
              "callStack": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              }
            }
          }
        }
      },
      "chronos": {
        "events": {
          "Click": {
            "c": R,
            "properties": {
              "clickType": {
                "c": R
              },
              "exitClick": {
                "c": R
              },
              "banner": {
                "c": R
              }
            }
          },
          "VideoStream": {
            "c": R,
            "properties": {
              "streamType": {
                "c": R
              },
              "videoType": {
                "c": R
              },
              "videoFormat": {
                "c": R
              },
              "videoAction": {
                "c": R
              },
              "videoId": {
                "c": R
              },
              "playerId": {
                "c": R
              },
              "videoDuration": {
                "c": R
              },
              "elapsedTime": {
                "c": R
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              }
            }
          },
          "Impression": {
            "c": R,
            "properties": {
              "bannerType": {
                "c": R
              },
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              }
            }
          }
        }
      },
      "friends": {
        "events": {
          "Click": {
            "_include": ["baseEvent"],
            "c": O,
            "properties": {
              "localUserId": {
                "type": S,
                "c": O
              },
              "entryPoint": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "entryPoint_friends"
                }
              },
              "receiversOnlineId": {
                "type": S,
                "c": O
              },
              "targetOrigin": {
                "type": I,
                "c": O
              },
              "typeOfRelation": {
                "type": I,
                "c": O
              },
              "sourceContext": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "sourceContext_friends"
                }
              },
              "buttonType": {
                "type": I,
                "c": O
              },
              "titleId": {
                "type": S,
                "c": O
              },
              "numberOfUsers": {
                "type": I,
                "c": O
              },
              "maxNumberOfUsers": {
                "type": I,
                "c": O
              }
            }
          },
          "Impression": {
            "_include": ["baseEvent"],
            "c": O,
            "properties": {
              "localUserId": {
                "type": S,
                "c": O
              },
              "entryPoint": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "entryPoint_friends"
                }
              },
              "buttonTypeList": {
                "type": A,
                "c": O,
                "collection": {
                  "type": I,
                  "c": O
                }
              },
              "titleIdList": {
                "type": A,
                "c": O,
                "collection": {
                  "type": S,
                  "c": O
                }
              },
              "sourceContext": {
                "type": I,
                "c": O,
                "sbahn": {
                  "alias": "sourceContext_friends"
                }
              },
              "numberOfRecomendedUsers": {
                "type": I,
                "c": O
              }
            }
          },
          "PageView": {
            "_include": ["baseEvent"],
            "c": O,
            "properties": {
              "localUserId": {
                "type": S,
                "c": O
              },
              "introductionScreenType": {
                "type": I,
                "c": O
              }
            }
          }
        }
      },
      "yaka": {
        "events": {
          "Hover": {
            "_include": ["baseEvent"],
            "properties": {
              "sourceContext": {
                "type": S,
                "c": O
              },
              "cust04": {
                "type": S,
                "c": O
              },
              "cust05": {
                "type": S,
                "c": O
              },
              "cust06": {
                "type": S,
                "c": O
              },
              "trackAction": {
                "type": S,
                "c": O
              }
            }
          },
          "Click": {
            "properties": {
              "sourceContext": {
                "type": S,
                "c": O
              },
              "cust04": {
                "type": S,
                "c": O
              },
              "cust05": {
                "type": S,
                "c": O
              },
              "cust06": {
                "type": S,
                "c": O
              },
              "cust07": {
                "type": S,
                "c": O
              },
              "cust08": {
                "type": S,
                "c": O
              },
              "cust09": {
                "type": S,
                "c": O
              },
              "cust10": {
                "type": S,
                "c": O
              },
              "cust11": {
                "type": S,
                "c": O
              },
              "trackAction": {
                "type": S,
                "c": O
              }
            }
          }
        }
      },
      "unibeam": {
        "events": {
          "Click": {
            "c": R,
            "properties": {
              "banner": {
                "c": R
              },
              "clickType": {
                "c": R
              },
              "exitClick": {
                "c": R
              },
              "tile": {
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  }
                }
              }
            }
          },
          "Impression": {
            "c": R,
            "properties": {
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "bannerType": {
                "c": R
              },
              "tiles": {
                "c": R,
                "collection": {
                  "c": R,
                  "properties": {
                    "campaignId": {
                      "c": R
                    },
                    "productTitle": {
                      "c": R
                    },
                    "tileAuthor": {
                      "c": R
                    },
                    "tileId": {
                      "c": R
                    },
                    "tilePosition": {
                      "c": R
                    },
                    "tileTitle": {
                      "c": R
                    },
                    "tileType": {
                      "c": R
                    }
                  }
                }
              }
            }
          },
          "VideoStream": {
            "c": R,
            "properties": {
              "banners": {
                "c": R,
                "collection": {
                  "c": R
                }
              },
              "elapsedTime": {
                "c": R
              },
              "playerId": {
                "c": R
              },
              "streamType": {
                "c": R
              },
              "tile": {
                "c": R,
                "properties": {
                  "campaignId": {
                    "c": R
                  },
                  "productTitle": {
                    "c": R
                  },
                  "tileAuthor": {
                    "c": R
                  },
                  "tileId": {
                    "c": R
                  },
                  "tilePosition": {
                    "c": R
                  },
                  "tileTitle": {
                    "c": R
                  },
                  "tileType": {
                    "c": R
                  }
                }
              },
              "videoAction": {
                "c": R
              },
              "videoDuration": {
                "c": R
              },
              "videoFormat": {
                "c": R
              },
              "videoType": {
                "c": R
              },
              "videoUrl": {
                "c": R
              },
              "windowMode": {
                "c": R
              }
            }
          }
        }
      }
    }
  };

  /**
   * Recursively Resolve Schema Includes
   *
   * @param {Object} templates   Named References to Schema Templates
   * @param {Object} schema      Schema Object to process
   *
   * @returns {Object}  Fully Resolved Schema
   */

  var processSchema = function processSchema(templates, schema) {
    var resolvedSchema = {}; // If the key _include is found, load the named object from the templates argument

    if (schema._include) {
      // For each value, merge the associated block, if the block exists.
      resolvedSchema = schema._include.reduce(function (accumulator, value) {
        if (templates[value]) {
          // to avoid needless calls that would take to long to resolve.
          var template = templates[value]._include ? processSchema(templates, templates[value]) : templates[value];
          return merge(accumulator, template);
        }

        return accumulator;
      }, {});
    } // With all the base references


    resolvedSchema = merge(resolvedSchema, schema);
    delete resolvedSchema._include; // Process Children Includes
    // Case 1: object properties

    if (resolvedSchema.properties) {
      Object.keys(resolvedSchema.properties).forEach(function (key) {
        resolvedSchema.properties[key] = processSchema(templates, resolvedSchema.properties[key]);
      });
    } // Case 2: array collection


    if (resolvedSchema.collection) {
      resolvedSchema.collection = processSchema(templates, resolvedSchema.collection);
    }

    return resolvedSchema;
  };
  /**
   * Resolve any _includes from an event schema set.
   *
   * @param  {Object} eventTemplates   Event Templates
   * @param  {Object} events           Event Schema Set to resolve.
   * @return {Object}                  Resolved Schema
   */


  var resolveEventSchema = function resolveEventSchema(eventTemplates, events) {
    var parsedEvents = {};
    Object.keys(events).forEach(function (key) {
      parsedEvents[key] = processSchema(eventTemplates, events[key]);
    });
    return parsedEvents;
  };
  /**
   * Process environment any _includes from an en schema set.
   *
   * @param  {Object} environmentTemplates   Environment Templates
   * @param  {Object} environment            Environment Schema Set to resolve.
   * @return {Object}                        Resolved Schema
   * @since  0.6.22
   */


  var resolveEnvironmentSchema = function resolveEnvironmentSchema(environment) {
    var environmentTemplates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return processSchema(environmentTemplates, environment);
  };

  function _defineProperties$u(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$u(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$u(Constructor.prototype, protoProps); if (staticProps) _defineProperties$u(Constructor, staticProps); return Constructor; }
  /**
   * Apply overlays recursively.
   *
   * This function will create a full separation of references via JSON.parse(JSON.stringify))
   * Otherwise it is a simple wrapper around "utils/merge"
   *
   * Terminology:
   * Overlay was chosen instead of 'override' in that this function not simply override an existing set of values,
   * but will blindly merge an overlay object onto a base object.   The result of this function will allow:
   * types to change, append array values, and extend objects properties.
   *
   * @param {Object}  base       Schema Base
   * @param {Object[]} overlays  Schema Overlays
   */

  var applyOverlays = function applyOverlays(base, overlays) {
    overlays.forEach(function (overlay) {
      merge(base, JSON.parse(JSON.stringify(overlay)));
    });
  };

  var translateOverlays = function translateOverlays(overlays) {
    return overlays.map(function (overlay) {
      return JSON.parse(JSON.stringify(overlay).replace(/"classification"/g, '"c"').replace(/"required"/g, '"r"').replace(/"optional"/g, '"o"').replace(/"string"/g, '"s"').replace(/"int"/g, '"i"').replace(/"float"/g, '"f"').replace(/"number"/g, '"n"').replace(/"object"/g, '"e"').replace(/"boolean"/g, '"b"').replace(/"array"/g, '"a"').replace(/"date"/g, '"d"'));
    });
  };
  /**
   * Telemetry Schema Configuration
   * @typedef {Object} schema~TelemetrySchemaOptions
   *
   * @property {String} overlayId               Overlay Id
   * @since 0.6.23
   *
   * @property {Object[]} schemaOverlays        Additional Schema to overlay
   *
   * @property {boolean}  disableDefaultSchema  Disable loading of the Default Schema
   *
   * @property {LoggerInterface} logger         Logger Instance
   * @since 0.6.23
   */

  /**
   *
   * Telemetry Schema.
   *
   * This class will abstract interactions with the Telemetry Schema (DSL)
   *
   *
   */


  var TelemetrySchema =
  /*#__PURE__*/
  function () {
    function TelemetrySchema() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$overlaySetId = _ref.overlaySetId,
          overlaySetId = _ref$overlaySetId === void 0 ? '' : _ref$overlaySetId,
          _ref$schemaOverlays = _ref.schemaOverlays,
          schemaOverlays = _ref$schemaOverlays === void 0 ? [] : _ref$schemaOverlays,
          _ref$defaultSchema = _ref.defaultSchema,
          defaultSchema = _ref$defaultSchema === void 0 ? builtInSchema : _ref$defaultSchema,
          _ref$disableDefaultSc = _ref.disableDefaultSchema,
          disableDefaultSchema = _ref$disableDefaultSc === void 0 ? false : _ref$disableDefaultSc,
          _ref$logger = _ref.logger,
          logger = _ref$logger === void 0 ? new NullLogger$2() : _ref$logger;

      this._schema = disableDefaultSchema ? {} : JSON.parse(JSON.stringify(defaultSchema));
      this._logger = logger;

      this._overlaysNotification(schemaOverlays);

      applyOverlays(this._schema, this.getOverlaysForId(overlaySetId));
      applyOverlays(this._schema, translateOverlays(schemaOverlays));
      this._schema.events = resolveEventSchema(this._schema.eventTemplates || {}, this._schema.events || {});
      this._schema.environment = resolveEnvironmentSchema(this._schema.environment || {});
    }

    var _proto = TelemetrySchema.prototype;

    _proto._overlaysNotification = function _overlaysNotification(schemaOverlays) {
      if (schemaOverlays.length !== 0) {
        this._logger.warning('Overlays are meant to be used only in testing environment, use overrideid instead for production.');
      }
    };

    _proto.getSchemaForEvent = function getSchemaForEvent(eventName) {
      return this._schema.events[eventName] || {};
    };

    _proto.getOverlay = function getOverlay(id) {
      var overlays = this.schema.overlays || {};
      return overlays[id];
    };

    _proto.hasOverlay = function hasOverlay(id) {
      return !isUndefined_1(this.schema.overlays || {})[id];
    }
    /**
     * Return the list of overlay files for the giver override id
      * Returns an empty list if not found.
     * @param {string} overlayId
     * @returns {Array}
     */
    ;

    _proto.getOverlayFilesIdsFor = function getOverlayFilesIdsFor(overlayId) {
      if (!overlayId) {
        return [];
      } // Override Id Must Exist


      if (!this.hasOverlay(overlayId)) {
        this._error('InvalidArgumentError: Overlay not found.', {
          overlayId: overlayId
        });

        return [];
      }
      /** @type {Array} */


      var overlayFileIds = this.getOverlay(overlayId);

      if (!isArray_1(overlayFileIds)) {
        this._error('TypeError: Overlay is not an Array of strings.', {
          overlayId: overlayId,
          type: Object.prototype.toString.call(overlayFileIds)
        });

        return [];
      }

      return overlayFileIds;
    };

    _proto.getOverlayFile = function getOverlayFile(overlayFileId) {
      var hasOverlay = this.schema.overlayFiles && this.schema.overlayFiles[overlayFileId];

      if (!hasOverlay) {
        this._error('NotFoundError: Overlay file not found.', {
          overlayFileId: overlayFileId
        });

        return undefined;
      }

      var overlay = this.schema.overlayFiles[overlayFileId];

      if (!isPlainObject_1(overlay)) {
        this._error('TypeError: Overlay file is not an object.', {
          overlayFileId: overlayFileId,
          type: Object.prototype.toString.call(overlay)
        });

        return undefined;
      }

      return overlay;
    }
    /**
     *
     * @param {string} overlayId
     * @return {Object[]} overrides
     * @private
     */
    ;

    _proto.getOverlaysForId = function getOverlaysForId(overlayId) {
      var _this = this;

      var overlayFileIds = this.getOverlayFilesIdsFor(overlayId);
      var overlays = overlayFileIds.map(function (id) {
        return _this.getOverlayFile(id);
      });
      return compact_1(overlays);
    }
    /**
     * Log an error, using a json context object.
     * @param {string} message
     * @param {Object} context
     * @private
     */
    ;

    _proto._error = function _error(message, context) {
      this.logger.error("".concat(message, "|").concat(JSON.stringify(context)));
    };

    _createClass$u(TelemetrySchema, [{
      key: "schema",
      get: function get() {
        return this._schema;
      }
    }, {
      key: "events",
      get: function get() {
        return this._schema.events;
      }
    }, {
      key: "environment",
      get: function get() {
        return this._schema.environment;
      }
    }, {
      key: "logger",
      get: function get() {
        return this._logger;
      }
    }]);

    return TelemetrySchema;
  }();

  function _extends$9() { _extends$9 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$9.apply(this, arguments); }

  function _defineProperties$v(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$v(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$v(Constructor.prototype, protoProps); if (staticProps) _defineProperties$v(Constructor, staticProps); return Constructor; }
  // Longer term, move to service locator default values so that it isn't controlled here.

  var propertyDefaults = {
    _activeSchema: undefined,
    // No Setter Function
    _remoteUpdate: {},
    disableDefaultSchema: false,
    disableEventTypeCheck: false,
    disableEventPrivacyFilter: false,
    disableEnvironmentTypeCheck: true,
    // TODO: @carlos will look into how to handle null and undefined first.
    disableEnvironmentPrivacyFilter: false,
    enabled: true,
    filters: [],
    logger: undefined,
    overrideId: undefined,
    overlays: []
  };
  var knownKeys = Object.keys(propertyDefaults);
  /**
   * Return a value suitable for a string configuration.
   * @param {*} value
   * @returns {string}
   */

  var stringVal = function stringVal(value) {
    // String value
    if (isString_1(value)) {
      return value;
    } // Number, but not NaN or Infinity


    if (isNumber_1(value) && _isFinite(value)) {
      return String(value);
    }

    return '';
  };
  /**
   * Properties and default values
   * @type {Object}
   * @alias SchemaOptions
   */


  var SchemaOptions =
  /*#__PURE__*/
  function () {
    /**
     * @param options
     */
    function SchemaOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _extends$9(this, propertyDefaults);

      this._fromObject(options); // For testing:  Longer term, convert to service locator so that instantiation isn't controlled here.


      this._builtInSchema = builtInSchema;
      this._remoteUpdate = options.remoteUpdate || {};
      Object.seal(this);
    }

    var _proto = SchemaOptions.prototype;

    /**
     * Invalid Value handling routine.
     * @param fieldName
     * @param value
     * @private
     */
    _proto._invalidValue = function _invalidValue(fieldName, value) {
      var message = "env.invalidValue: Invalid value for property ".concat(fieldName, ": ").concat(JSON.stringify(value), ".");
      this.logger.warning(message);
    }
    /**
     * Sets parameters on this instance from an object
     * @param {Object} options
     * @private
     */
    ;

    _proto._fromObject = function _fromObject(options) {
      var _this = this;

      var keys = Object.keys(options);
      var invalidKeys = difference_1(keys, knownKeys);

      if (invalidKeys.length) {
        this.logger.warning('schema.unknownOption: Unknown options in schema configuration.', {
          invalidKeys: invalidKeys
        });
      }

      if (!invalidKeys.length) {
        _extends$9(this, options);
      } else {
        var validKeys = intersection_1(keys, knownKeys);
        validKeys.forEach(function (key) {
          _this[key] = options[key];
        });
      }
    };

    _proto._createRemoteSchema = function _createRemoteSchema(schema) {
      return new TelemetrySchema({
        defaultSchema: schema,
        disableDefaultSchema: false
      });
    };

    _proto._createSchema = function _createSchema() {
      return new TelemetrySchema({
        defaultSchema: this._builtInSchema,
        overlaySetId: this.overrideId,
        schemaOverlays: this.overlays,
        disableDefaultSchema: this.disableDefaultSchema
      });
    }
    /**
     * request new schema from remote CDN, when resolved it'll fill active schema and attempt to store the
     * new schema in cache for future use.
    */
    ;

    _proto._fetchLatest = function _fetchLatest() {
      var _this2 = this;

      this._remoteUpdate.fetchRemoteSchema().then(function (schema) {
        _this2._activeSchema = _this2._createRemoteSchema(schema);

        _this2._remoteUpdate.save(schema);

        _this2.logger.warning('Remote fetch succeeded!');
      })["catch"](function (err) {
        _this2.logger.warning('Remote fetch failed!', {
          message: err.message
        });
      });
    }
    /**
     * Initialize with the build-in schema, in the case remote update is enabled it'll attempt to fetch latest,
     * which will be available when fetch resolve and active schema and the next time active schema is requested,
     * meanwhile return the currently cached version of schema if available, or construct a new schema from built-in version.
    */
    ;

    _proto._initializeSchema = function _initializeSchema() {
      if (this._remoteUpdate.enabled) {
        this._fetchLatest();

        if (this._remoteUpdate.isCached) {
          return this._createRemoteSchema(this._remoteUpdate.cachedSchema);
        } // The remote update case is by-definition, a single file, with no overlays


        if (this.overlays.length) {
          this.logger.warning('Overlays are ignored while remote update is enabled.');
        }
      }

      return this._createSchema();
    }
    /**
     * The Currently Active Schema.
     * @see enabled
     * @see overlays
     * @see disableDefaultSchema
     * @since 0.6.25 added remote fetching.
     * @return {Promise.<TelemetrySchema>}
     */
    ;

    _createClass$v(SchemaOptions, [{
      key: "remoteUpdate",
      get: function get() {
        return this._remoteUpdate;
      }
    }, {
      key: "activeSchema",
      get: function get() {
        if (this._activeSchema === undefined) {
          this._activeSchema = this._initializeSchema();
        }

        return this._activeSchema;
      }
      /**
       * Schema Processing Enabled Status
       * @returns {boolean}
       */

    }, {
      key: "enabled",
      get: function get() {
        return this._enabled;
      }
      /**
       * Schema Processing Enabled Status
       * @see activeSchema
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._activeSchema = undefined;
        this._enabled = Boolean(value);
      }
      /**
       * Additional Filters to apply
       * @returns {function[]}
       */

    }, {
      key: "filters",
      get: function get() {
        return this._filters;
      }
      /**
       * Additional property filters.
       * @param {function[]} value
       */
      ,
      set: function set(value) {
        // TODO: Type validation should be a regular filter
        // TODO: Abstract out the userPrivacyFilter creation to be a simple filter
        this._filters = value;
      }
      /**
       * Disable Default Schema
       * @returns {boolean}
       */

    }, {
      key: "disableDefaultSchema",
      get: function get() {
        return this._disableDefault;
      }
      /**
       * Disable Default Schema
       * @see activeSchema
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._activeSchema = undefined;
        this._disableDefault = Boolean(value);
      }
      /**
       * Disable Event Type Checking
       * @returns {boolean}
       */

    }, {
      key: "disableEventTypeCheck",
      get: function get() {
        return this._disableEventTypeCheck;
      }
      /**
       * Disable Event Type Checking
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._disableEventTypeCheck = Boolean(value);
      }
      /**
       * Disable Environment Type Checking
       * @returns {boolean}
       */

    }, {
      key: "disableEnvironmentTypeCheck",
      get: function get() {
        return this._disableEnvironmentTypeCheck;
      }
      /**
       * Disable Environment Type Checking
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._disableEnvironmentTypeCheck = Boolean(value);
      }
      /**
       * Disable Event Privacy Filter
       * @returns {boolean}
       */

    }, {
      key: "disableEventPrivacyFilter",
      get: function get() {
        return this._disableEventPrivacyFilter;
      }
      /**
       * Disable Event Privacy Filter
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._disableEventPrivacyFilter = Boolean(value);
      }
      /**
       * Disable Environment Privacy Filter
       * @returns {boolean}
       */

    }, {
      key: "disableEnvironmentPrivacyFilter",
      get: function get() {
        return this._disableEnvironmentPrivacyFilter;
      }
      /**
       * Disable Environment Privacy Filter
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._disableEnvironmentPrivacyFilter = Boolean(value);
      }
      /**
       * Override Build Id
       * @returns {string}
       */

    }, {
      key: "overrideId",
      get: function get() {
        return this._overrideId;
      }
      /**
       * Overrride Build Id
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._overrideId = stringVal(value);
      }
      /**
       * Schema Overlays
       * @returns {Object[]}
       */

    }, {
      key: "overlays",
      get: function get() {
        return this._overlays;
      }
      /**
       * Schema Overlays
       * @see activeSchema
       * @param {Object[]} value
       */
      ,
      set: function set(value) {
        this._activeSchema = undefined;

        if (!isArray_1(value)) {
          this._invalidValue('overlays', value);

          this._overlays = [];
          return;
        }

        this._overlays = value;
      }
    }, {
      key: "logger",
      get: function get() {
        if (!this._logger) {
          this._logger = new NullLogger$2();
        }

        return this._logger;
      },
      set: function set(value) {
        this._logger = value;
      }
    }]);

    return SchemaOptions;
  }();

  var schemaOptionsFactory = (function (container) {
    var config = container.get('config');
    var logger = container.get('Logger');
    var remoteUpdate = container.get('/schema/remoteUpdate');
    var schemaConfig = config.schema || {}; // in the case a concret instance was passed to config.schema can't extend object since it is sealed.

    if (Object.isExtensible(schemaConfig)) {
      schemaConfig.remoteUpdate = remoteUpdate;
    } // Instance provided
    // TODO: Remove this and force SchemaOptions to be set as the service directly via config.services.SchemaOptions


    if (schemaConfig instanceof SchemaOptions) {
      return schemaConfig;
    } // Invalid value


    if (!isPlainObject_1(schemaConfig)) {
      logger.error('schemaOptions.invalidValue: Schema Options must be an object, or instance of SchemaOptions.');
      schemaConfig = {};
    }

    var schemaOptions = new SchemaOptions(schemaConfig); // TODO: Deprecate schema.logger in favour of a service or alias
    // TODO: Define a common means of specifying the default or override logger
    // If no override logger is provided, inject default logger

    if (!schemaConfig.logger) {
      schemaOptions.logger = logger;
    }

    return schemaOptions;
  });

  /**
   * Checks if `value` is `null` or `undefined`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
   * @example
   *
   * _.isNil(null);
   * // => true
   *
   * _.isNil(void 0);
   * // => true
   *
   * _.isNil(NaN);
   * // => false
   */
  function isNil(value) {
    return value == null;
  }

  var isNil_1 = isNil;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }

    end = end > length ? length : end;

    if (end < 0) {
      end += length;
    }

    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);

    while (++index < length) {
      result[index] = array[index + start];
    }

    return result;
  }

  var _baseSlice = baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */

  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : _baseSlice(array, start, end);
  }

  var _castSlice = castSlice;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */

  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && _baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}

    return index;
  }

  var _charsEndIndex = charsEndIndex;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  var _asciiToArray = asciiToArray;

  /** Used to compose unicode character classes. */
  var rsAstralRange = "\\ud800-\\udfff",
      rsComboMarksRange = "\\u0300-\\u036f",
      reComboHalfMarksRange = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange = "\\u20d0-\\u20ff",
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsVarRange = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsZWJ = "\\u200d";
  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */

  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */

  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  var _hasUnicode = hasUnicode;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = "\\ud800-\\udfff",
      rsComboMarksRange$1 = "\\u0300-\\u036f",
      reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
      rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
      rsVarRange$1 = "\\ufe0e\\ufe0f";
  /** Used to compose unicode capture groups. */

  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo = '[' + rsComboRange$1 + ']',
      rsFitz = "\\ud83c[\\udffb-\\udfff]",
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange$1 + ']',
      rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
      rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
      rsZWJ$1 = "\\u200d";
  /** Used to compose unicode regexes. */

  var reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange$1 + ']?',
      rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */

  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  var _unicodeToArray = unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */

  function stringToArray(string) {
    return _hasUnicode(string) ? _unicodeToArray(string) : _asciiToArray(string);
  }

  var _stringToArray = stringToArray;

  /** Used to match leading and trailing whitespace. */

  var reTrimEnd = /\s+$/;
  /**
   * Removes trailing whitespace or specified characters from `string`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to trim.
   * @param {string} [chars=whitespace] The characters to trim.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {string} Returns the trimmed string.
   * @example
   *
   * _.trimEnd('  abc  ');
   * // => '  abc'
   *
   * _.trimEnd('-_-abc-_-', '_-');
   * // => '-_-abc'
   */

  function trimEnd(string, chars, guard) {
    string = toString_1(string);

    if (string && (guard || chars === undefined)) {
      return string.replace(reTrimEnd, '');
    }

    if (!string || !(chars = _baseToString(chars))) {
      return string;
    }

    var strSymbols = _stringToArray(string),
        end = _charsEndIndex(strSymbols, _stringToArray(chars)) + 1;
    return _castSlice(strSymbols, 0, end).join('');
  }

  var trimEnd_1 = trimEnd;

  function _defineProperties$w(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$w(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$w(Constructor.prototype, protoProps); if (staticProps) _defineProperties$w(Constructor, staticProps); return Constructor; }
  /**
   * Return a value suitable for a string configuration.
   * @param {*} value
   * @returns {string}
   */

  var stringVal$1 = function stringVal(value) {
    // String value
    if (isString_1(value)) {
      return value;
    } // Number, but not NaN or Infinity


    if (isNumber_1(value) && _isFinite(value)) {
      return String(value);
    }

    return '';
  };

  var DEFAULT_CACHE_KEY$2 = 'remote-schema';

  var _default$1 =
  /*#__PURE__*/
  function () {
    function _default() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._environment = options.remoteUpdateEnvironment || 'e1-np';
      this._path = options.remoteUpdatePath || {
        // eslint-disable-next-line quote-props
        'np': 'https://theia.dl.playstation.net/telemetry-config',
        'e1-np': 'https://theia.e1-np.dl.playstation.net/telemetry-config'
      };
      this.timeout = options.remoteUpdateFetchTimeout;
      this.enabled = options.remoteUpdateEnabled;
      this.fileName = options.remoteUpdateFileName;
      this._cacheKey = options.cacheKey || DEFAULT_CACHE_KEY$2;
      this._cacheKey = "".concat(this._cacheKey, ".").concat(this.fileName.toLowerCase().replace('.json', ''));
      this._cache = options.cache;
      this.logger = options.logger || new NullLogger$2();
    }
    /**
     * Save state to cache
     */


    var _proto = _default.prototype;

    _proto.save = function save(schema) {
      if (!this._cache) {
        return;
      }

      this._cache.set(this._cacheKey, schema);
    };

    /**
     * Fetch update json from remote CDN.
     */
    _proto.fetchRemoteSchema = function fetchRemoteSchema() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var headers = {
          'Content-Type': 'application/json; charset=utf-8'
        };

        var callback = function callback(error, status, response) {
          _this.logger.info("Remote Fetch ".concat(error ? 'failed' : 'successful', " with ").concat(status));

          if (error) {
            var err = Error("RemoteFetch failed with message: ".concat(response));
            reject(err);
            throw err;
          }

          if (status === 200) {
            resolve(response);
          }
        };

        var request = new XHR('GET', _this.fetchUrl, headers, callback, {
          logger: _this.logger
        });
        request.timeout = _this.timeout;
        request.open();

        _this.logger.warn('Remote fetch invoked!');
      });
    };

    _createClass$w(_default, [{
      key: "isCached",
      get: function get() {
        if (!this._cache) {
          return false;
        }

        return this._cache.has(this._cacheKey);
      }
    }, {
      key: "cachedSchema",
      get: function get() {
        if (!this._cache) {
          return {};
        }

        return this._cache.get(this._cacheKey);
      }
    }, {
      key: "fetchUrl",
      get: function get() {
        var url = null;

        if (this._path[this.environment] !== undefined) {
          url = "".concat(this._path[this.environment], "/").concat(this.fileName);
        } else {
          throw new Error('activeSchema.invalidEnvironment: invalid environment type supplied.');
        }

        return url;
      }
      /**
       * Remote Update Enabled
       * @returns {boolean}
       */

    }, {
      key: "enabled",
      get: function get() {
        return this._enabled;
      }
      /**
       * Remote Update Enabled
       * @param {boolean} value
       */
      ,
      set: function set(value) {
        this._enabled = isNil_1(value) ? false : Boolean(value);
      }
      /**
       * Remote Update NP Base Path (URL)
       * This property contains the NP base directory for schema definitions
       * Include "https://"
       * Omit trailing "/"
       * @returns {string}
       */

    }, {
      key: "NPPath",
      get: function get() {
        return this._path.np;
      }
      /**
       * Remote Update NP Base Path
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._path.np = trimEnd_1(stringVal$1(value), '/');
      }
      /**
       * Remote Update E1 Base Path (URL)
       * This property contains the E1 base directory for schema definitions
       * Include "https://"
       * Omit trailing "/"
       * @returns {string}
       */

    }, {
      key: "E1Path",
      get: function get() {
        return this._path['e1-np'];
      }
      /**
       * Remote Update E1 Base Path
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._path['e1-np'] = trimEnd_1(stringVal$1(value), '/');
      }
    }, {
      key: "environment",
      get: function get() {
        return this._environment;
      },
      set: function set(value) {
        this._environment = trimEnd_1(stringVal$1(value), '/');
      }
      /**
       * Remote Update File Name
       * @returns {string}
       */

    }, {
      key: "fileName",
      get: function get() {
        return this._fileName;
      }
      /**
       * Remote Update File Name
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._fileName = isNil_1(value) ? 'default.json' : stringVal$1(value);
      }
      /**
       * Remote Update fetch timeout in ms
       * @returns {string}
       */

    }, {
      key: "timeout",
      get: function get() {
        return this._timeout;
      }
      /**
       * Remote Update fetch timeout in ms
       * @param {string} value
       */
      ,
      set: function set(value) {
        this._timeout = isNil_1(value) || !isNumber_1(value) ? 10000 : value;
      }
    }]);

    return _default;
  }();

  var remoteUpdateFactory = (function (container) {
    var config = container.get('config');
    var logger = container.get('Logger');
    var schemaConfig = config.schema || {};
    var constructorParams = {};

    if (schemaConfig.cacheKey) {
      constructorParams.cacheKey = schemaConfig.cacheKey;
    } // fix this


    if (schemaConfig.cache) {
      constructorParams.cache = container.get(schemaConfig.cache);
    } // add check ??


    constructorParams.remoteUpdateEnvironment = schemaConfig.remoteUpdateEnvironment;
    constructorParams.remoteUpdatePath = schemaConfig.remoteUpdatePath;
    constructorParams.remoteUpdateEnabled = schemaConfig.remoteUpdateEnabled;
    constructorParams.remoteUpdateFileName = schemaConfig.remoteUpdateFileName;
    constructorParams.remoteUpdateFetchTimeout = schemaConfig.remoteUpdateFetchTimeout; // Invalid value

    if (!isPlainObject_1(schemaConfig)) {
      logger.error('schemaOptions.invalidValue: Schema Options must be an object, or instance of SchemaOptions.');
      schemaConfig = {};
    }

    if (!schemaConfig.logger) {
      constructorParams.logger = logger;
    }

    var remoteUpdate = new _default$1(constructorParams); // TODO: Deprecate schema.logger in favour of a service or alias
    // TODO: Define a common means of specifying the default or override logger
    // If no override logger is provided, inject default logger

    return remoteUpdate;
  });

  var schema = {
    schema: {
      enabled: true,

      /** @type {string} Service Name */
      cache: 'cache.remoteSchema',

      /** @type {?string} Cache Key Override */
      cacheKey: undefined,

      /** @type {string} default remote update environment */
      remoteUpdateEnvironment: 'e1-np',

      /** @type {object} environment urls lookup */
      remoteUpdatePath: {
        // eslint-disable-next-line quote-props
        'np': 'https://theia.dl.playstation.net/telemetry-config',
        'e1-np': 'https://theia.e1-np.dl.playstation.net/telemetry-config'
      },

      /** @type {boolean} remote update enabled */
      remoteUpdateEnabled: false,

      /** @type {object} schema file name to be used */
      remoteUpdateFileName: 'default.json',

      /** @type {?number} How long should remote update wait before it terminates, in ms */
      remoteUpdateFetchTimeout: 10000
    },
    services: {
      aliases: {
        SchemaOptions: '/schema/schemaOptions',
        RemoteUpdate: '/schema/remoteUpdate',
        'cache.remoteSchema': '/cache/cacheInterface'
      },
      factories: {
        '/schema/remoteUpdate': remoteUpdateFactory,
        '/schema/schemaOptions': schemaOptionsFactory
      }
    }
  };

  var MigrateLocaleToPsnAccount =
  /*#__PURE__*/
  function () {
    function MigrateLocaleToPsnAccount(deprecationManager) {
      this._deprecationManager = deprecationManager;
    }

    var _proto = MigrateLocaleToPsnAccount.prototype;

    _proto.apply = function apply(environment) {
      if (!environment || !environment.locale) {
        return environment;
      }

      if (environment.psnAccountLanguage || environment.psnAccountRegion) {
        return environment;
      }

      this.triggerDeprecation(); // Legacy Locale Format  xx_XX

      var parts = environment.locale.split('_');
      var legacyLanguageTag = parts[0] || undefined;
      var legacyCountryTag = parts[1] || undefined;
      var result = cloneDeep_1(environment);
      result.psnAccountLanguage = legacyLanguageTag;
      result.psnAccountRegion = legacyCountryTag;
      delete result.locale;
      return result;
    };

    _proto.triggerDeprecation = function triggerDeprecation() {
      this._deprecationManager.trigger(new Deprecation({
        date: '2019-03-12',
        name: 'environment.locale',
        description: 'Please use "psnAccountLanguage" and "psnAccountRegion" instead of "locale".',
        overrideKey: 'allowEnvironmentLocale'
      }));
    };

    return MigrateLocaleToPsnAccount;
  }();

  var migrateLocaleToPsnAccountFactory = (function (container) {
    var deprecationManager = container.get('/deprecation/deprecationManager');
    return new MigrateLocaleToPsnAccount(deprecationManager);
  });

  /**
   * Telemetry Configuration Serializer
   *
   * Default Serialization for Developer Debug
   *
   * @param config
   */
  var defaultDebug = (function (config) {
    var replacer = function replacer(key, value) {
      if (key === 'sdkInstance') {
        return 'sdkInstance';
      }

      if (key[0] === '_') {
        return undefined;
      }

      return value;
    };

    return JSON.stringify(config, replacer, 2);
  });

  var defaultDebugFactory = (function () {
    return defaultDebug;
  });

  var BackFillLocaleFromPsnAccount =
  /*#__PURE__*/
  function () {
    function BackFillLocaleFromPsnAccount() {}

    var _proto = BackFillLocaleFromPsnAccount.prototype;

    _proto.apply = function apply(environment) {
      // Optional
      if (!environment) {
        return environment;
      } // Must have something to back-port


      if (!environment.psnAccountRegion || !environment.psnAccountLanguage) {
        return environment;
      }

      var languageTag = parseLanguageTag$1(environment.psnAccountLanguage);
      var legacyLocaleLanguage = languageTag.languageId.toLowerCase();
      var legacyLocaleRegion = environment.psnAccountRegion.toUpperCase();
      var legacyLocale = "".concat(legacyLocaleLanguage, "_").concat(legacyLocaleRegion);
      var result = cloneDeep_1(environment);
      result.locale = legacyLocale;
      return result;
    };

    return BackFillLocaleFromPsnAccount;
  }();

  var telemetry = {
    telemetry: {
      /**
       * Is GCT running as Unified Telemetry
       * This is a temporary flag to ease migration in code
       * As UT is updated to handle Web/Mobile use-cases, this will be removed.
       */
      _isUnifiedTelemetry: false
    },
    services: {
      factories: {
        '/telemetry/serializer/defaultDebug': defaultDebugFactory,
        '/telemetry/MigrateLocaleToPsnAccount': migrateLocaleToPsnAccountFactory,
        '/telemetry/BackFillLocaleFromPsnAccount': function telemetryBackFillLocaleFromPsnAccount() {
          return new BackFillLocaleFromPsnAccount();
        }
      }
    }
  };

  /**
   * Return a constant value
   *
   * This file is a shim to migrate away from always having a throttler
   * Instead of enabling/disabling and always running a throttler,
   * this can be a throttler that always returns false (i.e throttling disabled)
   *
   * Longer term, when the eventing system is fleshed out,
   * this class can be removed and no throttler supplied or run at all.
   *
   * Or, for a multi-tenancy, applications with throttler disabled can internally
   * use this as the throttler reference.
   */
  var ConstantThrottler =
  /*#__PURE__*/
  function () {
    function ConstantThrottler(value) {
      this._result = Boolean(value);
    }
    /**
     *
     * @param {string} eventType
     * @param {string} pluginId
     * @returns {*}
     */
    // eslint-disable-next-line no-unused-vars


    var _proto = ConstantThrottler.prototype;

    _proto.isPluginEventTypeMuted = function isPluginEventTypeMuted(eventType, pluginId) {
      return this._result;
    };

    return ConstantThrottler;
  }();

  function _defineProperties$x(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$x(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$x(Constructor.prototype, protoProps); if (staticProps) _defineProperties$x(Constructor, staticProps); return Constructor; }

  var asFloat = function asFloat(v) {
    return _isFinite(v) && v || isString_1(v) && Number(v) || 0;
  };
  /**
   * Parse thresholds variable as passed in by the user
   * @param thresholds
   * @returns {{}}
   */


  var parseUserThresholds = function parseUserThresholds(thresholds) {
    if (!isObject_1(thresholds)) {
      return {};
    }

    var parsedThresholds = {};
    Object.keys(thresholds).forEach(function (pluginId) {
      if (!isObject_1(thresholds[pluginId])) {
        return;
      }

      parsedThresholds[pluginId] = {};
      Object.keys(thresholds[pluginId]).forEach(function (eventType) {
        parsedThresholds[pluginId][eventType] = asFloat(thresholds[pluginId][eventType]);
      });
    });
    return parsedThresholds;
  };
  /**
   * Parses the sampling chance
   *
   * @param samplingChance
   * @returns {*}
   */


  var parseUserSamplingChance = function parseUserSamplingChance(samplingChance) {
    return asFloat(samplingChance);
  };

  var GctThrottlerOptions =
  /*#__PURE__*/
  function () {
    function GctThrottlerOptions() {
      this._thresholds = {};
      this._samplingChance = 0;
    }

    GctThrottlerOptions.fromObject = function fromObject(config) {
      var options = new this();
      options._thresholds = parseUserThresholds(config.thresholds);
      options._samplingChance = parseUserSamplingChance(config.samplingChance);
      return options;
    };

    _createClass$x(GctThrottlerOptions, [{
      key: "thresholds",
      get: function get() {
        return this._thresholds;
      }
    }, {
      key: "samplingChance",
      get: function get() {
        return this._samplingChance;
      }
    }]);

    return GctThrottlerOptions;
  }();

  function _defineProperties$y(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$y(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$y(Constructor.prototype, protoProps); if (staticProps) _defineProperties$y(Constructor, staticProps); return Constructor; }
  /**
   * Cast the user value to a float.
   *
   * Notes:
   * The original implementation was: (isNaN(v) ? 0 : parseFloat(v));
   * which has some issues in type-saftey.
   * in particular, it returns NaN in many cases, which isn't the designed reponse
   *    undefined => 0
   *    null => NaN
   *    NaN => 0
   *    "1.4" => 1.4
   *    "1xeao" => 1
   *
   * To make this more idomatic in code, the behaviour is changed:
   *    Number => as is
   *    Inf, NaN => 0
   *    coerseable string => Number(string)
   *    non-coersable string => 0
   *
   * Blindly using Number(v) doesn't work either as it handles null and [] correctly, but not undefined.
   *
   * Code is simplification of:
   *    if (isFinite(v))
   *       return v;
   *    else if (isString(v) && Number(v)) // Number(v) may return NaN, which is falsey
   *       return Number(v)
   *    else
   *      return 0;
   */

  var asFloat$1 = function asFloat(v) {
    return _isFinite(v) && v || isString_1(v) && Number(v) || 0;
  };
  /**
   * Default Throttling Implementation
   *
   */


  var GctThrottler =
  /*#__PURE__*/
  function () {
    function GctThrottler(options) {
      this._options = options || new GctThrottlerOptions();
    }
    /**
     * Options
     * @returns {GctThrottlerOptions}
     */


    var _proto = GctThrottler.prototype;

    /**
     * Does the threshold represent a muted event?
     * @param rawThreshold
     * @returns {boolean}
     */
    _proto.isMuted = function isMuted(rawThreshold) {
      var samplingChance = this.options.samplingChance;
      var threshold = asFloat$1(rawThreshold); // Case 1: samplingChance is 0; threshold not ALL (1)
      // Case 2: samplingChance greater than threshold;
      // TODO: Question: This doesn't change during runtime, should we just pre-calculate the values?

      return threshold < 1 && samplingChance === 0 || samplingChance > threshold;
    }
    /**
     * is the given plugin/event type combination muted
     * @param eventType
     * @param pluginId
     * @returns {*}
     */
    ;

    _proto.isPluginEventTypeMuted = function isPluginEventTypeMuted(eventMetadata, pluginId) {
      // Case 1: Undefined plugin target will throttle all entries if enabled
      if (!this.options.thresholds[pluginId]) {
        return true;
      } // Case 2: Undefined plugin-event target will throttle event


      var pluginThresholds = this.options.thresholds[pluginId];

      if (!isUndefined_1(pluginThresholds[eventMetadata.eventLocalName])) {
        return this.isMuted(pluginThresholds[eventMetadata.eventLocalName]);
      }

      if (!isUndefined_1(pluginThresholds[eventMetadata.eventName])) {
        return this.isMuted(pluginThresholds[eventMetadata.eventName]);
      } // Case 2.1: Deprecated event key


      if (!isUndefined_1(pluginThresholds[eventMetadata.legacyEventLocalName])) {
        return this.isMuted(pluginThresholds[eventMetadata.legacyEventLocalName]);
      }

      if (!isUndefined_1(pluginThresholds[eventMetadata.legacyEventName])) {
        return this.isMuted(pluginThresholds[eventMetadata.legacyEventName]);
      } // Default: threshold=0 => always muted


      return true;
    };

    _createClass$y(GctThrottler, [{
      key: "options",
      get: function get() {
        return this._options;
      }
    }]);

    return GctThrottler;
  }();

  /**
   *
   * @param {ContainerInterface} container
   * @returns {Date}
   */
  var GctThrottlerFactory = (function (container) {
    var appConfig = container.get('config');
    var appSamplingChance = appConfig.samplingChance;
    var appSamplingThresholds = appConfig.samplingThresholds;
    var enabled = !(isUndefined_1(appSamplingChance) && isUndefined_1(appSamplingThresholds)); // Original Logic:
    // If undefined(config.samplingChance) && undefined(config.samplingThresholds) => not enabled

    if (!enabled) {
      return new ConstantThrottler(false);
    } // Thresholds should be an object


    var thresholds = isObject_1(appSamplingThresholds) ? appSamplingThresholds : {};
    var options = GctThrottlerOptions.fromObject({
      samplingChance: appSamplingChance,
      thresholds: thresholds
    });
    var throttler = new GctThrottler(options);
    return throttler;
  });

  var throttler = {
    /**
     * Sampling Thresholds
     * Legacy Configuration
     *
     * Legacy behaviour checks whether the value is undefined to determine whether to enable or not.
     */
    samplingThresholds: undefined,

    /**
     * Sampling Chance
     * Legacy Configuration
     *
     * Legacy behaviour checks whether the value is undefined to determine whether to enable or not.
     */
    samplingChance: undefined,
    // TODO: Migrate to a better format for configuration that isn't root level
    // TODO: Deterimen migration path for users to use the new configuration that doesn't break the old behaviours,
    //       Which relies on fields being undefined
    // throttle: {
    //     /**
    //      * Is the throttling enabled
    //      */
    //     enabled: true,
    //     /**
    //      * Sampling Chance : float
    //      * Value between 0 and 1 inclusive.
    //      * A given
    //      */
    //     samplingChance: 0,
    //     /**
    //      * Hash of Thresholds
    //      * The value should be a number between 0 and 1 inclusive.
    //      */
    //     samplingThresholds: {
    //         /** Example Format
    //          adobe: {
    //             Click: 1,
    //             Impression: 0.05,
    //             LoadTime: 1,
    //             PageView: 1,
    //             Startup: 1,
    //             UserFacingError: 1,
    //             VideoStream: 1
    //          }
    //          */
    //     }
    // },
    services: {
      factories: {
        '/throttler/GctThrottler': GctThrottlerFactory
      }
    }
  };

  var mergedConfig = [adobeDispatchers, cache, deprecation, eventInspector, eventManager, gctBuildInfo, host, identifiers, logger, pluginAdobe, pluginClairvoyance, pluginKamaji, privacy, network, schema, telemetry, throttler].reduce(function (accumulator, currentValue) {
    return merge(accumulator, currentValue);
  }, {});

  function _defineProperties$z(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$z(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$z(Constructor.prototype, protoProps); if (staticProps) _defineProperties$z(Constructor, staticProps); return Constructor; }

  var EventMetadata =
  /*#__PURE__*/
  function () {
    function EventMetadata(inputEvent, deprecationManager) {
      this._deprecationManager = deprecationManager;
      this.eventLocalName = inputEvent.type;
      this.eventNamespace = inputEvent.namespace === undefined ? 'default' : inputEvent.namespace;
    }

    _createClass$z(EventMetadata, [{
      key: "eventLocalName",
      get: function get() {
        return this._eventLocalName;
      },
      set: function set(value) {
        this._eventLocalName = value;
      }
    }, {
      key: "legacyEventLocalName",
      get: function get() {
        this._deprecationManager.trigger(new Deprecation({
          date: '2019-07-15',
          name: 'events.legacy',
          description: 'Please use PascalCase instead of camelCase when referencing event names in config.',
          overrideKey: 'AllowEventNameWithoutNamespace'
        }));

        var legacyEventKey = this.eventLocalName.replace(/Event$/, '');
        legacyEventKey = legacyEventKey[0].toLowerCase() + legacyEventKey.substr(1, legacyEventKey.length);
        return legacyEventKey;
      }
    }, {
      key: "eventNamespace",
      get: function get() {
        return this._eventNamespace;
      },
      set: function set(value) {
        this._eventNamespace = value;
      }
    }, {
      key: "eventName",
      get: function get() {
        return "".concat(this.eventNamespace, ":").concat(this.eventLocalName);
      }
    }, {
      key: "legacyEventName",
      get: function get() {
        return "".concat(this.eventNamespace, ":").concat(this.legacyEventLocalName);
      }
    }]);

    return EventMetadata;
  }();

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

  function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

  function _defineProperties$A(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$A(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$A(Constructor.prototype, protoProps); if (staticProps) _defineProperties$A(Constructor, staticProps); return Constructor; }
  /**
   * Telemetry Events
   * Events that trigger throughout the GCT EcoSystem
   *
   * @TODO: Need a SharedEventManager so that listeners can subscribe before their dependencies instantiate
   * @TODO: Migrate User state away from being owned by TelemeteryService
   */

  var EVENT = {
    PLATFORM_PRIVACY_LEVEL_CHANGE: 'platformPrivacyLevelChange',
    SIGNED_IN_STATE_CHANGE: 'signedInStateChange'
  };
  var staticPluginRegistrations = {
    BasePlugin: BasePlugin$2,
    AdobePlugin: AdobePlugin,
    ClairvoyancePlugin: ClairvoyancePlugin,
    KamajiPlugin: KamajiPlugin
  };
  var staticEventRegistrations = {
    BaseEvent: BaseEvent,
    ClickEvent: ClickEvent,
    ImpressionEvent: ImpressionEvent,
    LoadTimeEvent: LoadTimeEvent,
    PageViewEvent: PageViewEvent,
    StartupEvent: StartupEvent,
    UserFacingErrorEvent: UserFacingErrorEvent,
    SearchEvent: SearchEvent,
    DwellEvent: DwellEvent,
    VideoStreamEvent: VideoStreamEvent,
    AdClickEvent: AdClickEvent,
    AdImpressionEvent: AdImpressionEvent,
    AdVideoStreamEvent: AdVideoStreamEvent
  };
  /**
   * This is the main class of Grand Central Telemetry.
   *
   * @alias GrandCentralTelemetry.TelemetryService
   */

  var TelemetryService =
  /*#__PURE__*/
  function () {
    /** *
     *
     * @param configuration
     */
    function TelemetryService(configuration) {
      var _this = this;

      // TODO: Migrate all this to a custom GctConfig class
      // @TODO: Migrate `.plugins` subkey to be more reliably "configuration".
      // @TODO: Migrate live-objects to be instantiated via service locator. (adobe.sdk, clairvoyance.xhr, etc.)
      // This will break any objects with a prototype chain (class instances)
      // They will need to be wrapped in a function, and moved to the service location in order
      // for the configuration to remain deterministic.
      var mergedConfig$1 = [{}, mergedConfig, configuration].reduce(function (a, b) {
        return merge(a, b);
      }, {});
      mergedConfig$1.plugins = configuration.plugins;
      this._config = mergedConfig$1;

      this._transitionMigrateRegistryPlugins();

      this._sharedServices = new TelemetryServices(this.serviceLocator);
      this.serviceLocator.setService('config', mergedConfig$1);

      this._validateTelemetryConfig(mergedConfig$1);

      this.serviceLocator.setService('telemetryService', this);

      this._constructorInitPlatformPrivacyWs1(mergedConfig$1.env || {});

      this._constructorInitEnvironment(mergedConfig$1.env || {}); // Before we go and start mucking with things, ensure the platform privacy level is
      // calculated, and thus preventing weird circular dependency graphs.
      // eslint-disable-next-line no-unused-vars


      this._sharedServices.logger.info('Resolved WS1 Setting.', {
        platformPrivacyLevel: this.platformPrivacyLevel
      });

      this._lastPageView = undefined; // Allows events to dispatch themselves

      BaseEvent.setDispatcher(this.dispatch.bind(this));
      this.initializeStaticDeprecationManager();

      this._sharedServices.logger.debug('GCT Initialized.', function () {
        var serializer = _this.serviceLocator.get('/telemetry/serializer/defaultDebug');

        return {
          version: GctVersion,
          config: serializer(_this._config),
          filteredEnvironment: _this.filteredEnvironment
        };
      });
    }
    /**
     * Initializes the Legacy Environment Variable.
     * This will isolate all usages of `TelemetryService.environment`
     * Preparation work for 2019 Change in architecture.
     *
     * @param {object} configEnvironment
     * @private
     */


    var _proto = TelemetryService.prototype;

    _proto._constructorInitEnvironment = function _constructorInitEnvironment(configEnvironment) {
      this._requireValidEventEnvironment(configEnvironment);

      this._legacyEnvironment = new LegacyEnvironment(configEnvironment);
      this._legacyEnvironmentControl = new LegacyEnvironmentControl(this._legacyEnvironment, {
        logger: this._sharedServices.logger,
        deprecationManager: this._sharedServices.deprecationManager
      });

      this._processEventEnvironmentLegacyConstructor(this._legacyEnvironment, this._legacyEnvironmentControl);
    }
    /**
     * This will only process Environment set in the constructor
     * Environment values dispatched will not be mutated
     * @private
     * @param legacyEnvironment          Environment Container
     * @param legacyEnvironmentControl   Environment Controller
     */
    ;

    _proto._processEventEnvironmentLegacyConstructor = function _processEventEnvironmentLegacyConstructor(legacyEnvironment, legacyEnvironmentControl) {
      legacyEnvironment.withPlatformPrivacyWs1(this.platformPrivacyLevel);
      legacyEnvironmentControl.compat_resolveUndefinedSignedIn();
      legacyEnvironmentControl.compat_resolveConstructorSignedOut();
    }
    /**
     * Environment Validator
     * @private
     * @returns {EnvironmentValidator}
     */
    ;

    /**
     * Require that an environment is valid.
     * @throws {Error}
     * @private
     *
     * @param env   Environment Object to validate
     */
    _proto._requireValidEventEnvironment = function _requireValidEventEnvironment(env) {
      if (!this.environmentValidator.isValid(env)) {
        throw new Error(Array.from(this.environmentValidator.messages.values()).join('; '));
      }
    }
    /**
     * Migrate any Plugin Registry items to the service locator
     *
     * This does not track any subsequent register/unregister calls.
     * Once you create the TelemetryInstance, it is assumed by design that the available
     * plugins will not change during runtime.
     *
     * @private
     */
    ;

    _proto._transitionMigrateRegistryPlugins = function _transitionMigrateRegistryPlugins() {
      var _this2 = this;

      var pluginIds = Object.keys(Registry.PLUGINS);

      if (!pluginIds.length) {
        return;
      }

      var serviceContainer = this.serviceLocator;
      pluginIds.forEach(function (pluginId) {
        var serviceKey = _this2._pluginServiceKeyFor(pluginId);

        if (serviceContainer.has(serviceKey)) {
          throw new Error("The service ".concat(pluginId, " has been defined more than once."));
        }

        var factory = createTransitionPluginFactory(pluginId, Registry.PLUGINS[pluginId]); // TODO: Implement: serviceLocator.setFactory(targetKey, targetFactory)
        // HACK: Hack it in directly for now

        serviceContainer._factories[serviceKey] = factory;
      });
    }
    /**
     * Initialize any static deprecations that have enqueued if this is the first instance of GCT.
     */
    ;

    _proto.initializeStaticDeprecationManager = function initializeStaticDeprecationManager() {
      // This will create the static deprecation manager instance, and assign the concrete dispatcher
      // only if one is not yet set.
      this.serviceLocator.get('/deprecation/staticDeprecationManager');
    }
    /**
     * Default Service Locator
     * @returns {ContainerInterface}
     */
    ;

    _proto._validateTelemetryConfig = function _validateTelemetryConfig(config) {
      // Validate that all plugin configurations correspond to registered plugins (pre-instantiation)
      this._validatePluginIds(config);
    }
    /**
     * PUBLIC API.
     * Leave here.
     * @returns {EventInspector}
     */
    ;

    _proto._parsePlatformPrivacyLevel = function _parsePlatformPrivacyLevel(env) {
      if (!this._sharedServices.schemaOptions.enabled) {
        return UserPermissionLevel.EXEMPT;
      } // Platform Privacy Level: What is the reporting requirement.  Exempt, Minimal, Maximal(All)


      return resolveUserPermissionLevel({
        env: env
      });
    };

    _proto._constructorInitPlatformPrivacyWs1 = function _constructorInitPlatformPrivacyWs1(env) {
      this._platformPrivacyLevel = this._parsePlatformPrivacyLevel(env);
    }
    /**
     * Platform Privacy Level (WS1)
     * Returns the effective value.
     *
     * TODO: Extract this out of TelemetryService
     * @since 0.6.22 Implementation
     * @returns ?string Platform Privacy Setting, undefined if feature not enabled.
     * @private
     */
    ;

    /**
     * @typedef {object} PsnAccountObject
     * @property {string} language
     * @property {string} region
     */

    /**
     * Set user in a signed in state
     *
     * This method will update the config after instantiation and set signedIn to true
     * and visitorId to the value of first argument
     *
     * @param {string} visitorId Mandatory visitorId for signed in user which is the hashed PSN account id
     * @param {string|{PsnAccountObject}} [npAccountLocaleOrPsnAccountObject] Optional locale for signed in user which is the PSN account locale
     * @param {string} [postalCode] Optional postalCode for signed in user
     * @param {string} [dma] Optional DMA for signed in user
     */
    _proto.setSignedInState = function setSignedInState(visitorId, npAccountLocaleOrPsnAccountObject, postalCode, dma) {
      // Switch:  V1:  npAccountLocale is ?string.
      if (isString_1(npAccountLocaleOrPsnAccountObject)) {
        return this._setSignedInStateV1(visitorId, npAccountLocaleOrPsnAccountObject, postalCode, dma);
      } // New Format: npAccountLocale is ?object


      return this._setSignedInStateV2(visitorId, npAccountLocaleOrPsnAccountObject, postalCode, dma);
    };

    _proto._setSignedInStateV2 = function _setSignedInStateV2(visitorId, psnAccountObject, postalCode, dma) {
      // Keep this in sync with _setSignedInStateV1 until .locale deprecated is removed.
      var legacyNpAccount = undefined;

      this._legacyEnvironmentControl.compat_withUserSignedIn(visitorId, legacyNpAccount, postalCode, dma, psnAccountObject);

      this._sharedServices.eventManager.trigger(EVENT.SIGNED_IN_STATE_CHANGE, this, {});
    };

    _proto._setSignedInStateV1 = function _setSignedInStateV1(visitorId, legacyNpAccount, postalCode, dma) {
      // Keep this in sync with _setSignedInStateV2 until .locale deprecated is removed.
      var psnAccountObject = undefined;

      this._legacyEnvironmentControl.compat_withUserSignedIn(visitorId, legacyNpAccount, postalCode, dma, psnAccountObject);

      this._sharedServices.eventManager.trigger(EVENT.SIGNED_IN_STATE_CHANGE, this, {});
    }
    /**
     * set DMA config
     *
     * This method will update the config after instantiation and set DMA to new value,
     * it'll also filter the environment if the schema is enabled.
     *
     * @param {string|integer|undefined|null} DMA Optional dma value to set on runtime
     *                              if string doesn't only consist of whitespaces, after it'll be trimmed and set.
     *                              if integer is greater than zero, it'll preform cast to string and set.
     *                              if undefined or null it'll be set to null.
     */
    ;

    _proto.setDMA = function setDMA(dma) {
      this._legacyEnvironmentControl.user_withDma(dma);
    }
    /**
     * set postal code config
     *
     * This method will update the config after instantiation and set postalCode to new value,
     * it'll also filter the environment if the schema is enabled.
     *
     * @param {string|integer|undefined|null} postalCode Optional postalCode value to set on runtime
     *                              if string doesn't only consist of whitespaces, after it'll be trimmed and set.
     *                              if integer is greater than zero, it'll preform cast to string and set.
     *                              if undefined or null it'll be set to null.
     * @since 0.6.22
     */
    ;

    _proto.setPostalCode = function setPostalCode(postalCode) {
      this._legacyEnvironmentControl.user_withPostalCode(postalCode);
    }
    /**
     * Set a new value to network type
     *
     * This method will update the config after instantiation and set networkType to new value
     *
     * @param {string} networkType Mandatory if invalid it will restore the networkType to empty state.
     */
    ;

    _proto.setNetworkType = function setNetworkType(networkType) {
      this._legacyEnvironmentControl.platform_withNetworkType(networkType);
    };

    _proto.setUserSignedOut = function setUserSignedOut() {
      this._legacyEnvironmentControl.compat_withUserSignedOutBlankAssociated();

      this._sharedServices.eventManager.trigger(EVENT.SIGNED_IN_STATE_CHANGE, this, {});
    }
    /**
     * Set user in a signed out state
     *
     * This method will update the config after instantiation and set signedIn to false
     * and visitorId to null
     */
    ;

    _proto.setSignedOutState = function setSignedOutState() {
      this.setUserSignedOut();
    }
    /**
     * Set user Plus membership status
     *
     * This method will update the config after instantiation and set PS Plus membership status
     *
     * @param {boolean} isPlusUser Mandatory, set to true if plus member or false if not
     * @param {string} [plusUserType] Optional string of PSPLUS_TYPES to identify type of membership
     */
    ;

    _proto.updatePlusUserStatus = function updatePlusUserStatus(isPlusUser, plusUserType) {
      this._legacyEnvironmentControl.compat_withPlusUserStatusAndType(isPlusUser, plusUserType);
    }
    /**
     * Set user PS Now membership status
     *
     * This method will update the config after instantiation and set PS Now membership status
     *
     * @param {string} [psnowMembershipType] String of PSNOW_TYPES to identify membershipTypes
     */
    ;

    _proto.updatePSNowMembershipType = function updatePSNowMembershipType(psnowMembershipType) {
      this._legacyEnvironmentControl.user_withPsNowMembershipType(psnowMembershipType);
    }
    /**
     * Submits event to any registered plugins.
     * @param  {BaseEvent} inputEvent The event to be dispatched (should extend BaseEvent)
     * @return {DispatchedEvent}
     */
    ;

    _proto.dispatch = function dispatch(inputEvent) {
      var environment = this._legacyEnvironment.value;
      return this.dispatch2WithLog(inputEvent, environment, this.config);
    };

    _proto._processFallbackLocationFeature = function _processFallbackLocationFeature(config, inputEvent) {
      if (!isUseLastLocationEnabled(config)) {
        return inputEvent;
      }

      var clonedEvent = cloneDeep_1(inputEvent);

      this._dispatchTrackPageView(clonedEvent);

      return clonedEvent;
    };

    _proto.dispatch2WithLog = function dispatch2WithLog(inputEvent, environment, config) {
      if (!inputEvent) {
        this._sharedServices.logger.error('Attempting to dispatch null or undefined.');
      }

      var dispatchedEvent = this.dispatch2(inputEvent, environment, config);
      logDispatchedEvent(this._sharedServices.logger, dispatchedEvent);
      return dispatchedEvent;
    };

    _proto.dispatch2 = function dispatch2(inputEvent, environment, config) {
      var eventMetadata = new EventMetadata(inputEvent, this._sharedServices.deprecationManager);
      return this.dispatch3(inputEvent, environment, config, eventMetadata);
    } // TODO: https://github.sie.sony.com/SIE/grand-central-telemetry/pull/868#discussion_r670163
    // Convert to always be FQN in BC-Break
    ;

    _proto.dispatch3 = function dispatch3(inputEvent, environment, config, eventMetadata) {
      // make sure that event
      if (eventMetadata === undefined || eventMetadata.eventLocalName === undefined) {
        this._sharedServices.logger.error('eventMetaData eventLocalName can not be undefined.');
      }

      if (inputEvent.type === undefined) {
        // eslint-disable-next-line no-param-reassign
        inputEvent.type = eventMetadata.eventLocalName;
      } else if (inputEvent.type !== eventMetadata.eventLocalName) {
        this._sharedServices.logger.error('eventMetaData type conflict with inputEvent type.');
      }

      if (!inputEvent) {
        return new DispatchedEvent();
      } // eslint-disable-next-line


      inputEvent = this._processFallbackLocationFeature(config, inputEvent);

      var dispatchEnv = this._applyDeprecatedEnvironmentLocale(environment);
      /**
       * Apply overlay for MillenniumFalcon, this is considered only a temporary solution.
       * @todo: find a better solution
       */


      var activeSchema = this._resolveActiveSchema(config, inputEvent); // Resolve the Platform Privacy Level it should be a straight value in environment after construction


      var platformPrivacyLevel = resolveUserPermissionLevel({
        env: environment
      });
      var dispatchedEvent = dispatchEvent(this._sharedServices.identifiers, this._sharedServices.logger, this._sharedServices.schemaOptions, this._sharedServices.throttler, this.pluginInstances, this._uriCensor, this._isUnifiedTelemetry, platformPrivacyLevel, inputEvent, dispatchEnv, config, eventMetadata, activeSchema);
      this.eventInspector.addEvent(dispatchedEvent);
      return dispatchedEvent;
    };

    _proto._applyDeprecatedEnvironmentLocale = function _applyDeprecatedEnvironmentLocale(environment) {
      var migrator = this._serviceLocator.get('/telemetry/MigrateLocaleToPsnAccount');

      var backFiller = this._serviceLocator.get('/telemetry/BackFillLocaleFromPsnAccount');

      var env = migrator.apply(environment);
      env = backFiller.apply(env);
      return env;
    };

    _proto._resolveActiveSchema = function _resolveActiveSchema(config, inputEvent) {
      var _this$_sharedServices = this._sharedServices.schemaOptions,
          activeSchema = _this$_sharedServices.activeSchema,
          overlays = _this$_sharedServices.overlays;

      var _ref = config.schema || {},
          overrideId = _ref.overrideId;

      if (this._isUnifiedTelemetry && this._isMillenniumFalcon(inputEvent) && overrideId && activeSchema.hasOverlay(overrideId)) {
        return new TelemetrySchema({
          defaultSchema: {},
          schemaOverlays: _toConsumableArray(overlays),
          disableDefaultSchema: true
        });
      }

      return activeSchema;
    }
    /**
     * Retrieve the currently instantiated plug-in instance.
     * @param {string} pluginName  Name of desired plugin instance
     */
    ;

    _proto.plugin = function plugin(pluginName) {
      if (!this.pluginInstances[pluginName]) {
        throw new Error("Plugin with name '".concat(pluginName, "' has not been registered."));
      }

      return this.pluginInstances[pluginName];
    }
    /**
     * Retrieve all instantiated plugins as an array.
     *
     * Order is not guaranteed stable.
     * @private
     * @return {Array}
     */
    ;

    _proto._plugins = function _plugins() {
      var _this3 = this;

      var result = [];
      Object.keys(this.pluginInstances).forEach(function (k) {
        result.push(_this3.pluginInstances[k]);
      });
      return result;
    }
    /**
     * The ServiceLocator key for a given Plugin Id;
     * @param {string} pluginId
     * @returns {string}
     * @private
     */
    ;

    _proto._pluginServiceKeyFor = function _pluginServiceKeyFor(pluginId) {
      return "/plugin/".concat(pluginId);
    }
    /**
     * Is the plugin registered
     * @param {string} id
     * @returns {boolean}
     * @private
     */
    ;

    _proto._isPluginRegistered = function _isPluginRegistered(id) {
      return this.serviceLocator.has(this._pluginServiceKeyFor(id));
    }
    /**
     * Validate that the plugin configuration is valid
     * @private
     */
    ;

    _proto._validatePluginIds = function _validatePluginIds(config) {
      var _this4 = this;

      var pluginIds = Object.keys(config.plugins || []);
      pluginIds.forEach(function (id) {
        if (!_this4._isPluginRegistered(id)) {
          throw new Error("Invalid plugin '".concat(id, "'! Please register plugin first.")); // return false
        }
      });
      return true;
    }
    /**
     * Instantiate each plugin specified in configuration
     *
     * @private
     *
     * @param      {Object}  pluginsConfig  The plugins configuration from telemetry config 'plugins' key
     */
    ;

    _proto._instantiatePlugins = function _instantiatePlugins(pluginsConfig) {
      var _this5 = this;

      // Keep a single instance of each plugin around
      this._pluginInstances = {};
      var plugins = pluginsConfig ? Object.keys(pluginsConfig) : [];

      if (!plugins.length) {
        return;
      }

      plugins.forEach(function (name) {
        var serviceKey = _this5._pluginServiceKeyFor(name); // TODO: Change the semantics of pluginRegistered to hasService later
        // Also, why do we do this check, this should be guarded against by the
        // constructor hard-fail.


        if (!_this5._isPluginRegistered(name)) {
          return;
        } // This guard should not be needed with the current logic.
        // Keep it around, just in case the caller drops it's guard check.


        if (!_this5._pluginInstances[name]) {
          _this5._pluginInstances[name] = _this5.serviceLocator.get(serviceKey);
        }
      });
    };

    /**
     * Keep track of the last Page View so events can omit location/locationType
     * TODO: this shouldn't cache the entire object, only the .location and .locationType fields
     * @param {Object} rawEvent
     * @private
     */
    _proto._dispatchTrackPageView = function _dispatchTrackPageView(rawEvent) {
      // Always keep track of most recent page view
      if (rawEvent.type !== 'PageView') {
        return;
      }

      this._lastPageView = rawEvent;
    }
    /** ***************************
     * Compatibilty to support deprecating Registry entirely
     **************************** */

    /**
     * Register an external plugin
     *
     * @param      {string}   pluginName  The plugin name
     * @param      {function} pluginClass The plugin class (constructor)
     */
    ;

    TelemetryService.registerPlugin = function registerPlugin(pluginName, pluginClass) {
      // Cannot deprecate this method until Ember Core pattern is updated to allow for clients
      // to pass in binary data (factories) as part of their config.
      // This method is called before TelemetryService is instantiated.
      // Deprecation will display on construction.
      // TODO: Enable deprecation once built-in plugins are fully migrated
      // TelemetryService.staticDeprecationManager.trigger(new Deprecation({
      //     date: '2018-06-12',
      //     name: 'telemetry.registerPlugin',
      //     description: 'Telemetry.registerPlugin has been deprecated.',
      //     overrideKey: 'allowRegisterPlugin'
      // }));
      var pluginIds = Object.keys(Registry.PLUGINS);
      var inPlugins = pluginIds.filter(function (p) {
        return p.toLocaleLowerCase() === pluginName.toLocaleLowerCase();
      }).length !== 0;
      var isNotRegistered = !TelemetryService.__isPluginRegistered(pluginName);

      if (!inPlugins && isNotRegistered) {
        Registry.register(TelemetryService, pluginName, pluginClass, 'plugin');
      } else {
        throw new Error("The plugin '".concat(pluginName, "' is already registered!"));
      }
    }
    /**
     * Un-register an external plugin
     *
     * @param      {string}   pluginName  The plugin name
     */
    ;

    TelemetryService.unregisterPlugin = function unregisterPlugin(pluginName) {
      // Cannot deprecate this method until Ember Core pattern is updated to allow for clients
      // to pass in binary data (factories) as part of their config.
      // This method is called before TelemetryService is instantiated.
      // Deprecation will display on construction.
      // TelemetryService.staticDeprecationManager.trigger(new Deprecation({
      //     date: '2018-06-12',
      //     name: 'telemetry.unregisterPlugin',
      //     description: 'Telemetry.unregisterPlugin has been deprecated.',
      //     overrideKey: 'allowUnregisterPlugin'
      // }));
      var pluginIds = Object.keys(Registry.PLUGINS);
      var inPlugins = pluginIds.filter(function (p) {
        return p.toLocaleLowerCase() === pluginName.toLocaleLowerCase();
      }).length !== 0;
      var isNotRegistered = !TelemetryService.__isPluginRegistered(pluginName);

      if (!pluginIds.length || !inPlugins && isNotRegistered) {
        return;
      }

      Registry.unregister(TelemetryService, pluginName, 'plugin');
    }
    /**
     * Test Support, because of working with global statics, and unable to guarantee state.
     * @private
     */
    ;

    TelemetryService.__resetStaticState = function __resetStaticState() {
      if (TelemetryService.staticDeprecationManager.__resetState) {
        TelemetryService.staticDeprecationManager.__resetState();
      }

      TelemetryService._staticDeprecationManager = undefined;
      TelemetryService._pushEventAccessDeprecation = false;
      TelemetryService._pushPluginAccessDeprecation = false;
    }
    /**
     * Static Deprecation Manager
     * @returns {StaticDeprecationManager}
     */
    ;

    /**
     * Check to bypass directly accessing .PLUGINS from Registry
     * @transitional
     * @deprecated
     * @param {string} pluginId
     * @returns {boolean}
     * @private
     */
    TelemetryService.__isPluginRegistered = function __isPluginRegistered(pluginId) {
      return Boolean(TelemetryService[pluginId] || staticPluginRegistrations[pluginId]);
    }
    /**
     * Creates the references on this object on behalf of Registry to bypass Deprecations
     * @transitional
     * @deprecated
     * @param {string}   id
     * @param {function} constructor
     * @private
     */
    ;

    TelemetryService.__createTransitionPluginReference = function __createTransitionPluginReference(id, constructor) {
      TelemetryService[id] = constructor;
      staticPluginRegistrations[id] = constructor;
    }
    /**
     * Creates the references on this object on behalf of Registry to bypass Deprecations
     * @transitional
     * @deprecated
     * @param {string}   id
     * @param {function} constructor
     * @private
     */
    ;

    TelemetryService.__createTransitionEventReference = function __createTransitionEventReference(id, constructor) {
      TelemetryService[id] = constructor;
      staticEventRegistrations[id] = constructor;
    };

    /**
     * Warning: This is a hardcoded appName for MillenniumFalcon
     */
    _proto._isMillenniumFalcon = function _isMillenniumFalcon(event) {
      return event.appName === 'mf';
    };

    _createClass$A(TelemetryService, [{
      key: "environmentValidator",
      get: function get() {
        if (!this._environmentValidator) {
          this._environmentValidator = new EnvironmentValidator();
        }

        return this._environmentValidator;
      }
    }, {
      key: "serviceLocator",
      get: function get() {
        if (!this._serviceLocator) {
          this._serviceLocator = new _default(this._config.services);
        }

        return this._serviceLocator;
      }
      /**
       * Used internally to register events
       * Delegate to internal service;
       * @returns {EventManager}
       */

    }, {
      key: "eventManager",
      get: function get() {
        return this._sharedServices.eventManager;
      }
      /**
       * TENTATIVE PUBLIC API
       * Returns identifiers generated by GCT.
       *
       * @returns {IdentifierProvider}
       */

    }, {
      key: "identifiers",
      get: function get() {
        return this._sharedServices.identifiers;
      }
    }, {
      key: "eventInspector",
      get: function get() {
        return this._sharedServices.eventInspector;
      }
      /**
       * Return the plugin instances
       * Todo: Convert to Service Locator
       * @returns {Object}
       */

    }, {
      key: "pluginInstances",
      get: function get() {
        if (this._pluginInstances === undefined) {
          this._instantiatePlugins(this.config.plugins);
        }

        return this._pluginInstances;
      }
    }, {
      key: "platformPrivacyLevel",
      get: function get() {
        return this._platformPrivacyLevel;
      }
      /**
       * Set the platform privacy level
       * @param {?string} level
       */
      ,
      set: function set(level) {
        var newLevel = level;

        if (!isValidPlatformPrivacyLevel(level)) {
          this._sharedServices.logger.error('InvalidArgument: Unknown value for platformPrivacyLevel. Using default of MINIMAL.', {
            level: level
          });

          newLevel = UserPermissionLevel.MINIMAL;
        }

        this._platformPrivacyLevel = newLevel;

        this._legacyEnvironment.withPlatformPrivacyWs1(this._platformPrivacyLevel);

        this._sharedServices.eventManager.trigger(EVENT.PLATFORM_PRIVACY_LEVEL_CHANGE, this);
      }
      /**
       * Filtered Environment Object
       * @private
       * @deprecated 2018-11-27 Internal state management of Environment is no longer supported.
       *      Environment is planned to be merged into the Event Object
       *      Environment will be filtered on each dispatch (Multi-App, Delayed Processing)
       * @returns {Object}
       */

    }, {
      key: "filteredEnvironment",
      get: function get() {
        // TODO Deprecation
        // TODO Need to mark "get" properties as private.
        // .locale does not exist within GCT.
        // For backwards compatibility, it will be backfilled for people requesting it.
        var legacyEnvironment = this._legacyEnvironment.value;

        var backFillEnvLocale = this._serviceLocator.get('/telemetry/BackFillLocaleFromPsnAccount');

        var legacyEnvironmentWithLocale = backFillEnvLocale.apply(legacyEnvironment);
        var platformPrivacyLevel = this.platformPrivacyLevel;
        var schemaOptions = this._sharedServices.schemaOptions;
        var filters = getPolicyFilters(schemaOptions, platformPrivacyLevel);
        var filteredEnvironment = filterEnvironment(schemaOptions.activeSchema, filters, legacyEnvironmentWithLocale);
        return Object.freeze(filteredEnvironment);
      }
      /**
       * Return current configuration
       */

    }, {
      key: "config",
      get: function get() {
        // BACK_COMPAT
        this._config.env = this.filteredEnvironment;
        return this._config;
      }
    }, {
      key: "_uriCensor",
      get: function get() {
        if (!this.__uriCensor) {
          this.__uriCensor = this._serviceLocator.get('/privacy/uriCensor');
        }

        return this.__uriCensor;
      }
    }, {
      key: "_isUnifiedTelemetry",

      /**
       * Is GCT running as Unified Telemetry
       * This is a shim for code-migration
       * Will be removed when Web and Mobile cases are addressed.
       * @temp
       * @returns {boolean}
       * @private
       */
      get: function get() {
        return this._config.telemetry._isUnifiedTelemetry;
      }
    }], [{
      key: "staticDeprecationManager",
      get: function get() {
        if (!TelemetryService._staticDeprecationManager) {
          TelemetryService._staticDeprecationManager = new StaticDeprecationManager();
        }

        return TelemetryService._staticDeprecationManager;
      }
    }, {
      key: "VERSION",
      get: function get() {
        return "v".concat(GctVersion);
      }
    }, {
      key: "Utils",
      get: function get() {
        // TODO: Expand this out and make into proper end-user consumable components
        return Utils$1;
      }
    }]);

    return TelemetryService;
  }();

  // Telemetry Class

  exports.AGE_GROUP = AGE_GROUP$1;
  exports.API_STATUSES = API_STATUSES$1;
  exports.AdClickEvent = AdClickEvent;
  exports.AdImpressionEvent = AdImpressionEvent;
  exports.AdVideoStreamEvent = AdVideoStreamEvent;
  exports.AdobePlugin = AdobePlugin;
  exports.BANNER_TYPES = BANNER_TYPES$1;
  exports.BaseEvent = BaseEvent;
  exports.BasePlugin = BasePlugin$2;
  exports.CLICK_TYPES = CLICK_TYPES$1;
  exports.COUNTRIES = COUNTRIES$1;
  exports.ClairvoyancePlugin = ClairvoyancePlugin;
  exports.ClickEvent = ClickEvent;
  exports.DEVICES = DEVICES$1;
  exports.DwellEvent = DwellEvent;
  exports.FORM_ACTIONS = FORM_ACTIONS$1;
  exports.ImpressionEvent = ImpressionEvent;
  exports.KamajiPlugin = KamajiPlugin;
  exports.LOCALES = LOCALES$1;
  exports.LoadTimeEvent = LoadTimeEvent;
  exports.NETWORKS = NETWORKS;
  exports.PAYMENT_METHODS = PAYMENT_METHODS$1;
  exports.PERSONALIZED_ADS = PERSONALIZED_ADS$1;
  exports.PRODUCT_TYPES = PRODUCT_TYPES$1;
  exports.PSNOW_TYPES = PSNOW_TYPES$1;
  exports.PSPLUS_TYPES = PSPLUS_TYPES$1;
  exports.PURCHASE_REC = PURCHASE_REC$1;
  exports.PageViewEvent = PageViewEvent;
  exports.REMOTE_UPDATE_ENVIRONMENT = REMOTE_UPDATE_ENVIRONMENT;
  exports.SEVERITIES = SEVERITIES$1;
  exports.STARTUP_TYPES = STARTUP_TYPES$1;
  exports.STREAM_TYPES = STREAM_TYPES$1;
  exports.SearchEvent = SearchEvent;
  exports.StartupEvent = StartupEvent;
  exports.TRANSACTION_TYPES = TRANSACTION_TYPES$1;
  exports.TelemetryService = TelemetryService;
  exports.UserFacingErrorEvent = UserFacingErrorEvent;
  exports.VIDEO_ACTIONS = VIDEO_ACTIONS$1;
  exports.VIDEO_FORMATS = VIDEO_FORMATS$1;
  exports.VIDEO_TYPES = VIDEO_TYPES$1;
  exports.VideoStreamEvent = VideoStreamEvent;
  exports.WINDOW_MODES = WINDOW_MODES$1;
  exports.buildDate = gctBuildDate;
  exports.version = GctVersion;

  Object.defineProperty(exports, '__esModule', { value: true });

}));

</script>

    <script>
/* eslint-disable */
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (browserNavigator, queryParams, defaultLanguage, defaultCountry) {
  // If we've gotten a complaint from GRC about an invalid locale, use default locale.  This can happen if we've got a
  // bad locale and attempt to sign in.
  // GRC seems to bounce us back with
  //        error=invalid_request,
  //        error_description=Parameter+request_locale+is+malformed
  //        error_code=4099
  // appended to our URL.
  if (queryParams.error && parseInt(queryParams.error_code, 10) === 4099) {
    return defaultLanguage + '-' + defaultCountry;
  }

  // If an override was provided, use it.
  if (queryParams.browserLocale) {
    return queryParams.browserLocale;
  }

  // Grab what locales the browser has for us.  Fall back on default language.
  var languages = browserNavigator.languages || [browserNavigator.language || browserNavigator.userLanguage];
  var browserLocale = languages[0] || defaultLanguage;

  // If it had a country code, we're done!
  if (hasCountryCode(browserLocale)) {
    return browserLocale;
  }

  // If there's another locale of the same language that includes a country code, use it.
  for (var i = 1; i < languages.length; ++i) {
    if (new RegExp('^' + browserLocale + '-[a-z][a-z]$', 'i').test(languages[i])) {
      return languages[i];
    }
  }

  // Fall back on default country
  return browserLocale + '-' + defaultCountry;
};

function hasCountryCode(locale) {
  // Script parts (e.g. Hant) are four characters long, so if we have a dash followed by two characters, it's a
  // country code.
  return (/-[a-z][a-z]$/i.test(locale)
  );
}

/**
 * Figure out which locale we should use until we get the user's locale from the session call.
 * @param {Navigator} browserNavigator - window.navigator
 * @param {Object} queryParams
 * @param {string} queryParams.browserLocale - Manual override.  Useful when testing.
 * @param {string} defaultLanguage
 * @param {string} defaultCountry
 */

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = generateCultureCode;
// @return {boolean} True if str is a string that is not empty or only whitespace.
function isNotEmptyString(str) {
  return typeof str === 'string' && str.trim().length > 0;
}

// Converts two symbol language from Kamaji locale string to ISO 639 format.
function standardizeKamajiLanguage(lang, country) {
  if (lang === 'ch' || lang === 'zh') {
    switch (country) {
      case 'TW':
        return 'zh-Hant';
      case 'CN':
      case 'HK':
        return lang === 'ch' ? 'zh-Hant' : 'zh-Hans';
      default:
    }
  }
  return lang;
}

// Converts ISO 639 language + script codes to Kamaji's country-dependent language code/
function kamajizeStandardLanguage(lang) {
  if (lang === 'zh-Hans') {
    return 'zh';
  } else if (lang === 'zh-Hant') {
    return 'ch';
  } else {
    return lang;
  }
}

/**
* generateCultureCode() consumes locale codes of any recognizable format and outputs an object of normalized formats.
*
* @params {CultureCode|object|string} locale - Can be a CultureCode object, an object with language and country string
*   fields, a full locale string in recognizable format (e.g. en-US), or just a language string with the country string
*   included as a second parameter.
* @params {string} country - Country code, if locale parameter is the language code.
* @return {object} CultureCode object that represents a format-agnostic culture code, or null if input parameters could
*   not be parsed.
*/
function generateCultureCode(locale, country) {
  var language = void 0;

  // Step 1: To avoid duplicating parsing code, let's convert the various inputs into a single locale string.
  if (locale) {
    if ((typeof locale === 'undefined' ? 'undefined' : _typeof(locale)) === 'object') {
      if (isNotEmptyString(locale.language) && isNotEmptyString(locale.country)) {
        locale = locale.language + '-' + locale.country;
      }
    } else if (isNotEmptyString(locale) && isNotEmptyString(country)) {
      locale = locale + '-' + country;
    }
  }
  if (!isNotEmptyString(locale)) {
    return null;
  }

  // Step 2: Parse string into language, script and country strings, standardizing capitalization as we go.
  var cultureRegex = /^(?:(\w{2}))(?:[-_](\w{1,4}))?[-_](?:(\w{2}))$/;
  var matches = cultureRegex.exec(locale.toLowerCase());
  if (!matches) {
    return null;
  }

  language = matches[1].toLowerCase();
  country = matches[3].toUpperCase();
  if (!language || !country) {
    return null;
  }

  if (matches[2]) {
    // Script/dialect code present, like Hans in zh-Hans-CN
    var script = matches[2];
    language = language + '-' + script.slice(0, 1).toUpperCase() + script.slice(1).toLowerCase();
  }

  // Step 3: Deal with kamaji language code.
  language = standardizeKamajiLanguage(language, country);
  var kamajiLanguage = kamajizeStandardLanguage(language);

  // Step 4: Put it all together.
  return {
    locale: language + '-' + country,
    language: language,
    country: country,

    kamaji: {
      locale: kamajiLanguage + '-' + country,
      language: kamajiLanguage,
      country: country
    }
  };
}

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Deferred;

var _promise = require('./promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Homebrew Deferred implementation
 * @constructor
 */
function Deferred() {
  var _this = this;

  this.resolve = null;
  this.reject = null;

  this.promise = new _promise2.default(function (resolve, reject) {
    _this.resolve = resolve;
    _this.reject = reject;
  });
}

},{"./promise":9}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gcUtilities = require('../lib/gc-utilities');

function getEmberEnvironmentObject() {
  var encodedEnv = document.head.querySelector('meta[name="psst/config/environment"]').getAttribute('content');
  return JSON.parse(decodeURIComponent(encodedEnv));
}

exports.default = {
  ember: getEmberEnvironmentObject(),
  navigator: window.navigator,
  location: window.location,
  queryParams: (0, _gcUtilities.parseQueryString)(window.location.search),
  document: document,
  clairvoyance: window.valkyrie.transact.clairvoyance,
  redirect: function redirect(url) {
    window.location.href = url;
  }
};

},{"../lib/gc-utilities":5}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
if (!window.GrandCentralCore) {
  throw new Error('Grand Central Core must be loaded before preflight can execute.');
}

/**
 *    For preflight use Only.  For Ember application use 'psst/utilities/gc-utilities'
 */

var _window$GrandCentralC = window.GrandCentralCore,
    createPostBody = _window$GrandCentralC.createPostBody,
    createQueryString = _window$GrandCentralC.createQueryString,
    parseQueryString = _window$GrandCentralC.parseQueryString;
exports.createPostBody = createPostBody;
exports.createQueryString = createQueryString;
exports.parseQueryString = parseQueryString;

},{}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = function (clientConfigService, configBaseUrl, partnerClientId, configOverrides) {
  var env = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _environment2.default;

  function getJSON(filename) {
    return fetch(filename).then(function (results) {
      return results.json();
    });
  }

  // We start the XHR requests in parallel but parse them in order below.

  // Request app config file
  var configPromise = getJSON(env.ember.baseURL + 'assets/app-6aa6beee0ac43f536b16167495491ea6.json');

  // Request partner config file
  var partnerConfigPromise = new _promise2.default(function (resolve) {
    // Grab the partner's client ID from the oauth_client_id query param
    if (partnerClientId) {
      partnerClientId = partnerClientId.toLowerCase();

      if (/[^0-9a-f-]/.test(partnerClientId)) {
        // Client IDs should only include hexadecimal digits and dashes.  Disqualify anything else for security reasons.
        console.warn('Invalid value for oauth_client_id: ' + partnerClientId);
        partnerClientId = '';
      }
    }

    if (!partnerClientId) {
      // Missing/invalid client ID should not fail the promise chain.
      resolve();
    } else {
      getJSON(configBaseUrl + 'partners/' + partnerClientId + '.json').catch(function (reason) {
        console.error(reason);
        console.warn('Could not load requested partner config file.  Continuing as if no partner was specified.');
        return null;
      })
      // Cause this promise to resolve our outer promise.
      .then(resolve);
    }
  });

  // Okay, now let's give the results to the config service.
  // IMPORTANT: The order of these processConfig() calls denote priority, with config settings of later calls overriding those
  // of earlier calls.

  function processConfig(config) {
    if (!config) {
      return;
    }

    if (Array.isArray(config)) {
      config = { overrides: config };
    }

    clientConfigService.addSettings(config);
  }

  return _promise2.default.all([partnerConfigPromise, configPromise]).then(function (results) {
    var _results = _slicedToArray(results, 2),
        partnerConfig = _results[0],
        config = _results[1];

    processConfig(partnerConfig);
    processConfig(config);

    var line = env.ember.line || _getLineViaHost(window.location.host);

    // This uses sets of criteria so adjust the reg exp to use groups.
    clientConfigService.addCriteriaVerifier('line', function (criteriaValue) {
      return clientConfigService.matchesRegExp('(' + criteriaValue + ')', line);
    });

    clientConfigService.addCriteriaVerifier('disableWindows', function (criteriaValue) {
      return clientConfigService.matchesRegExp('(' + criteriaValue + ')', env.queryParams.disableWindows);
    });

    // The buildVersion is coming from the package.json
    clientConfigService.addCriteriaVerifier('buildVersion', function (criteriaValue) {
      return clientConfigService.matchesRegExp('(' + criteriaValue + ')', env.ember.version);
    });

    clientConfigService.addCriteriaVerifier('authConfig', function (criteriaValue) {
      return clientConfigService.matchesRegExp('(' + criteriaValue + ')', env.queryParams.authConfig);
    });

    // *todo discuss with broader group about allowing overrides in production
    // nick thinks this would be useful. maybe do this with grease/tamper monkey?
    var settings = clientConfigService.computeSettings();
    if (configOverrides && !settings.isCustomerFacing) {
      clientConfigService.addSettings(configOverrides);
    }
  });
};

var _promise = require('../lib/promise');

var _promise2 = _interopRequireDefault(_promise);

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getLineViaHost(host) {
  if (host === _environment2.default.ember.localUrl) {
    return 'e1-np';
  }

  var lineInHost = _environment2.default.ember.lines.find(function (line) {
    return host === 'transact.' + line + '.playstation.com';
  });
  if (lineInHost) {
    return lineInHost;
  }

  return 'np';
}

/**
 * loadConfig needs to fetch the config JSON file from the server
 * using the Grand Central utilities service and then open and
 * add it to the config service before applying pending overrides and
 * query param overrides.
 * Note: the env parameter is only used for unit testing purposes.
 *
 * @return {Promise.<void>} resolved when config is available.
 */

},{"../lib/environment":4,"../lib/promise":9}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PreflightOperation;
/**
 * PreflightOperation Constructor
 * @param {object}    options
 * @param {function}  options.execute - the task to be executed
 * @param {string}    options.name - name of the task
 * @param {function}  [options.recordMetrics] - called with timing results of operation.
 */
function PreflightOperation(options) {
  var name = options.name,
      deps = options.deps,
      execute = options.execute,
      recordMetrics = options.recordMetrics;


  if (typeof name !== 'string') {
    throw new Error('Preflight operation is missing a name!');
  }

  if (typeof execute !== 'function') {
    throw new Error('Preflight operation "' + name + '" is missing an execute function!');
  }

  this.name = name;
  this.deps = deps || [];
  this.execute = execute;
  this.recordMetrics = recordMetrics;
}

},{}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PreflightRunner;

var _deferred = require('./deferred');

var _deferred2 = _interopRequireDefault(_deferred);

var _promise = require('./promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Decorates the operation with meta properties required by PreflightRunner
 * @param {PreflightOperation} operation
 * @return {object} anonymous wrapped object
 */
function wrapOperation(operation) {
  return {
    deferred: new _deferred2.default(),
    operation: operation,
    execution: {
      succeeded: false,
      finished: false,
      started: null,
      duration: null,
      result: null
    }
  };
}

/**
 * Preflight execution scheduler
 * @constructor
 */
function PreflightRunner() {
  /**
   * @see getSchedulePromise() and start()
   * @type {?Promise}
   */
  this._schedulePromise = null;

  /**
   * A registry of all operations (without any consideration paid to execution order)
   * @type {PreflightOperation[]}
   */
  this.operations = {};
}

/**
 * @param {string} opName
 * @return {boolean} True if an operation has been scheduled under that name.
 */
PreflightRunner.prototype.hasOperation = function (opName) {
  return !!this.operations[opName];
};

/**
 * Executes an operation.  Automatically waits for dependencies.
 * @param {string} opName
 * @return {Promise} Resolved with this op's result once this op has finished.
 */
PreflightRunner.prototype._executeOperation = function (opName) {
  var _this = this;

  // Enable this to print start/stop messages for all ops.
  var printDebugOutput = false;

  var wrapper = this.operations[opName];
  if (!wrapper) {
    throw new Error('Preflight runner attempted to execute unknown op ' + opName);
  }

  var op = wrapper.operation;
  var execution = wrapper.execution;

  function finishOperation(result, succeeded) {
    execution.duration = new Date().getTime() - execution.started;
    execution.finished = true;
    execution.succeeded = succeeded;
    execution.result = result;

    if (printDebugOutput) {
      console.debug('Operation ' + opName + ' finished!,', execution); // eslint-disable-line no-console
    }
    wrapper.deferred[succeeded ? 'resolve' : 'reject'](result);
  }

  var missingDepName = op.deps.find(function (depName) {
    return !_this.hasOperation(depName);
  });
  if (missingDepName) {
    throw new Error('Preflight operation ' + opName + ' is executing but dependency ' + missingDepName + ' was not scheduled.');
  }
  var depPromises = op.deps.map(function (depName) {
    return _this.operations[depName].deferred.promise;
  });

  return _promise2.default.all(depPromises).catch(function (reason) {
    // FIXME: It would be better for this guy to fail with something like `new DependencyFailedToExecute().  However,
    // if it did then the app would need to be smart enough to ignore these cascading and show the actual root cause
    // on the error page.  For now, passing on the root cause makes sure we show the right thing.
    wrapper.deferred.reject(reason);
    throw reason;
  }).then(function (depResults) {
    return (
      // Wrap the execute() in a .then() so that
      // - thrown exceptions will be converted to rejected promises,
      // - returned non-promise values will be converted into resolved promises, and
      // - returning a promise will still work.
      _promise2.default.resolve().then(function () {
        var _op$execute;

        if (printDebugOutput) {
          console.debug('Operation ' + opName + ' started'); // eslint-disable-line no-console
        }
        execution.started = new Date().getTime();
        return (_op$execute = op.execute).call.apply(_op$execute, [op].concat(_toConsumableArray(depResults)));
      }).then(function (result) {
        finishOperation(result, true);
        return result;
      }, function (reason) {
        finishOperation(reason, false);
        throw reason;
      })
    );
  });
};

/**
 * Appends an operation at the end of the schedule.
 * Runs when all previously scheduled operations have successfully finished
 * @param {PreflightOperation} operation instance of PreflightOperation
 * @return {PreflightRunner} Fluent Interface
 */
PreflightRunner.prototype.schedule = function (operation) {
  var _this2 = this;

  if (this._schedulePromise) {
    throw new Error('PreflightRunner.schedule: cannot add "' + operation.name + '" to an already-started schedule.');
  }

  var missingDepName = operation.deps.find(function (depName) {
    return !_this2.hasOperation(depName);
  });
  if (missingDepName) {
    throw new Error('Preflight operation ' + operation.name + ' was scheduled before dependency ' + missingDepName + '.');
  }

  this.operations[operation.name] = wrapOperation(operation);

  return this;
};

/**
 * @return {Pomise} Will be resolved with a map of the results of all operations.
 */
PreflightRunner.prototype.getSchedulePromise = function () {
  return this._schedulePromise;
};

// Takes a map of [key, promise] pairs and returns a promise which resolves to a map of [key, result] pairs.
// Basically just RSVP.hash().
function promiseAllMap(map) {
  // We will return a promise which resolves to this.
  var results = {};

  // Executes a promise and captures the result.
  function executePromiseByName(key) {
    return map[key].then(function (result) {
      results[key] = result;
    });
  }

  var promises = Object.keys(map).map(executePromiseByName);

  return _promise2.default.all(promises).then(function () {
    return results;
  });
}

/**
 * Tells the runner to execute the provided schedule.
 * @return {PreflightRunner} Fluent interface
 */
PreflightRunner.prototype.start = function () {
  var _this3 = this;

  // Translate our hash of ops to a hash of promises via _executeOperation().
  var opPromises = {};
  Object.keys(this.operations).forEach(function (opName) {
    opPromises[opName] = _this3._executeOperation(opName);
  });

  this._schedulePromise = promiseAllMap(opPromises);

  return this;
};

/**
 * Utility method to retrieve the result of a task when it's finished
 * @return {Promise}
 */
PreflightRunner.prototype.getPromise = function (opName) {
  return this.hasOperation(opName) ? this.operations[opName].deferred.promise : _promise2.default.reject('PreflightRunner.getExecution: operation "' + opName + '" doesn\'t exist');
};

PreflightRunner.prototype.getExecution = function (opName) {
  return this.hasOperation(opName) ? this.operations[opName].execution : {};
};

},{"./deferred":3,"./promise":9}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var PromiseImplementation = window.Promise;

exports.default = PromiseImplementation;

},{}],10:[function(require,module,exports){
'use strict';

var _preflightRunner = require('./lib/preflight-runner');

var _preflightRunner2 = _interopRequireDefault(_preflightRunner);

var _bootstrapCultureCode = require('./tasks/bootstrap-culture-code');

var _bootstrapCultureCode2 = _interopRequireDefault(_bootstrapCultureCode);

var _preLocaleConfig = require('./tasks/pre-locale-config');

var _preLocaleConfig2 = _interopRequireDefault(_preLocaleConfig);

var _gcClientConfig = require('./tasks/gc-client-config');

var _gcClientConfig2 = _interopRequireDefault(_gcClientConfig);

var _cultureCode = require('./tasks/culture-code');

var _cultureCode2 = _interopRequireDefault(_cultureCode);

var _postLocaleConfig = require('./tasks/post-locale-config');

var _postLocaleConfig2 = _interopRequireDefault(_postLocaleConfig);

var _i18n = require('./tasks/i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _fetchCurrencyDetails = require('./tasks/fetch-currency-details');

var _fetchCurrencyDetails2 = _interopRequireDefault(_fetchCurrencyDetails);

var _gcAuth = require('./tasks/gc-auth');

var _gcAuth2 = _interopRequireDefault(_gcAuth);

var _oauthAccessToken = require('./tasks/oauth-access-token');

var _oauthAccessToken2 = _interopRequireDefault(_oauthAccessToken);

var _oauthGatedAccessToken = require('./tasks/oauth-gated-access-token');

var _oauthGatedAccessToken2 = _interopRequireDefault(_oauthGatedAccessToken);

var _accountDetails = require('./tasks/account-details');

var _accountDetails2 = _interopRequireDefault(_accountDetails);

var _setLayout = require('./tasks/set-layout.js');

var _setLayout2 = _interopRequireDefault(_setLayout);

var _gcTelemetry = require('./tasks/gc-telemetry.js');

var _gcTelemetry2 = _interopRequireDefault(_gcTelemetry);

var _fetchAccountIdHash = require('./tasks/fetch-account-id-hash.js');

var _fetchAccountIdHash2 = _interopRequireDefault(_fetchAccountIdHash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.valkyrie = window.valkyrie || {}; /**
                                          * @module Preflight
                                          * @class ProductionPreflightManifest
                                          */

window.valkyrie.transact = window.valkyrie.transact || {};

window.valkyrie.transact.preflightRunner = new _preflightRunner2.default().schedule(_bootstrapCultureCode2.default).schedule(_gcClientConfig2.default).schedule(_preLocaleConfig2.default).schedule(_gcAuth2.default).schedule(_oauthAccessToken2.default).schedule(_oauthGatedAccessToken2.default).schedule(_fetchCurrencyDetails2.default).schedule(_accountDetails2.default).schedule(_cultureCode2.default).schedule(_postLocaleConfig2.default).schedule(_i18n2.default).schedule(_setLayout2.default).schedule(_fetchAccountIdHash2.default).schedule(_gcTelemetry2.default).start();

},{"./lib/preflight-runner":8,"./tasks/account-details":11,"./tasks/bootstrap-culture-code":12,"./tasks/culture-code":13,"./tasks/fetch-account-id-hash.js":14,"./tasks/fetch-currency-details":15,"./tasks/gc-auth":16,"./tasks/gc-client-config":17,"./tasks/gc-telemetry.js":18,"./tasks/i18n":19,"./tasks/oauth-access-token":20,"./tasks/oauth-gated-access-token":21,"./tasks/post-locale-config":22,"./tasks/pre-locale-config":23,"./tasks/set-layout.js":24}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'accountDetails',
  deps: ['preLocaleConfig', 'oauthAccessToken'],
  execute: function execute(settings, accessToken) {
    var headers = {
      Authorization: 'Bearer ' + accessToken.accessToken,
      'X-Platform': _environment2.default.queryParams.platformId,
      'Cache-Control': 'no-cache',
      Pragma: 'no-cache'
    };

    return fetch(settings.korra_api_accounts_base_url + '/v1/accounts/me/languages', {
      headers: headers
    }).then(function (result) {
      return result.json();
    });
  }
});

},{"../lib/environment":4,"../lib/preflight-operation":7}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _cultureCodeManager = require('../lib/culture-code-manager');

var _cultureCodeManager2 = _interopRequireDefault(_cultureCodeManager);

var _computeBrowserLocale = require('../lib/compute-browser-locale');

var _computeBrowserLocale2 = _interopRequireDefault(_computeBrowserLocale);

var _environment = require('../lib/environment.js');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @module Preflight
 * @class BootstrapCultureCodeOperation
 */

exports.default = new _preflightOperation2.default({
  name: 'bootstrapCultureCode',
  execute: function execute() {
    var bootstrapLocale = (0, _computeBrowserLocale2.default)(_environment2.default.navigator, _environment2.default.queryParams, 'en', 'GB');

    // check for an override
    bootstrapLocale = _environment2.default.queryParams.browserLocale || bootstrapLocale;

    var cultureCode = (0, _cultureCodeManager2.default)(bootstrapLocale);

    if (_environment2.default.queryParams.showLocalizedKeys) {
      cultureCode.getString = function (language, stringKey) {
        return '[[[' + stringKey + ']]]';
      };
    } else {
      cultureCode.getString = window.valkyrie.transact.bootstrap;
    }

    return cultureCode;
  }
});

},{"../lib/compute-browser-locale":1,"../lib/culture-code-manager":2,"../lib/environment.js":4,"../lib/preflight-operation":7}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _cultureCodeManager = require('../lib/culture-code-manager');

var _cultureCodeManager2 = _interopRequireDefault(_cultureCodeManager);

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'cultureCode',
  deps: ['accountDetails'],
  execute: function execute(accountDetails) {
    return (0, _cultureCodeManager2.default)(_environment2.default.queryParams.overrideLocale || accountDetails.language);
  }
}); /**
     * @module Preflight
     * @class CultureCodeOperation
     */

},{"../lib/culture-code-manager":2,"../lib/environment":4,"../lib/preflight-operation":7}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'fetchAccountIdHash',
  deps: ['preLocaleConfig', 'oauthAccessToken'],
  execute: function execute(settings, accessToken) {
    var headers = {
      Authorization: 'Bearer ' + accessToken.accessToken,
      // Kamaji commerce is returning as plain text by default, so tell it to return JSON instead
      Accept: 'application/json'
    };

    return fetch(settings.kamaji_commerce_api_base_url + '/users/me/account/id', {
      headers: headers
    }).then(function (result) {
      return result.json();
    }).then(function (response) {
      return response.accountId;
    });
  }
});

},{"../lib/preflight-operation":7}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Retreive currency details from the API (for preflight use).
 *
 * @module Preflight
 * @class FetchCurrencyDetails
 */

exports.default = new _preflightOperation2.default({
  name: 'fetchCurrencyDetails',
  deps: ['preLocaleConfig', 'oauthAccessToken'],
  execute: function execute(settings, accessToken) {
    var headers = {
      Authorization: 'Bearer ' + accessToken.accessToken,
      'X-Platform': _environment2.default.queryParams.platformId,
      'Cache-Control': 'no-cache',
      Pragma: 'no-cache'
    };
    return fetch(settings.korra_api_wallets_base_url + '/v1/wallets/me/currencyDetails', {
      headers: headers
    }).then(function (result) {
      return result.json();
    });
  }
});

},{"../lib/environment":4,"../lib/preflight-operation":7}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'gcAuth',
  deps: ['preLocaleConfig', 'bootstrapCultureCode'],
  execute: function execute(settings, bootstrapCultureCode) {
    if (!window.GrandCentralCore) {
      throw new Error('Grand Central must be loaded before preflight can execte.');
    }

    var auth = {};

    var useLegacyAuth = _environment2.default.queryParams.authConfig === 'legacy' || _environment2.default.queryParams.disableWindows === 'true';

    var normalOptions = {
      accessToken: {
        clientId: settings.oauth.implicit_grant.client_id,
        scopes: settings.oauth.implicit_grant.scopes,
        ui: useLegacyAuth ? 'pr_legacy' : 'pr'
      },
      authCode: {
        clientId: 'dummyId',
        scopes: []
      },
      authorizationUri: settings.oauth_authorize_url,
      redirectUri: _environment2.default.location.protocol + '//' + _environment2.default.location.host + _environment2.default.ember.baseURL + 'html/webIframeRedirect.html',
      loginRedirectUri: window.location.href,
      loginFormParameters: {
        hidePageElements: 'SENLogo',
        disableLinks: 'SENLink',
        request_locale: bootstrapCultureCode.locale.replace('-', '_'),
        date_of_birth: '',
        ui: useLegacyAuth ? 'pr_legacy' : 'pr'
      }
    };
    auth.normalAuth = new window.GrandCentralCore.WebIframeAuth(normalOptions);

    var gatedOptions = JSON.parse(JSON.stringify(normalOptions)); // clone
    gatedOptions.accessToken.scopes = normalOptions.accessToken.scopes.concat(settings.oauth.implicit_grant.gated_scopes);
    auth.gatedAuth = new window.GrandCentralCore.WebIframeAuth(gatedOptions);

    auth.fetchAccessToken = function (isGated) {
      return isGated ? this.gatedAuth.fetchAccessToken() : this.normalAuth.fetchAccessToken();
    };
    auth.clearAccessToken = function (isGated) {
      return isGated ? this.gatedAuth.clearAccessToken() : this.normalAuth.clearAccessToken();
    };

    return auth;
  }
});

},{"../lib/environment":4,"../lib/preflight-operation":7}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!window.ClientConfigService) {
  throw new Error('Grand Central Client Config Service must be loaded before preflight can execute.');
} /**
   * @module Preflight
   */

exports.default = new _preflightOperation2.default({
  name: 'gcClientConfig',
  deps: [],
  execute: function execute() {
    return new window.ClientConfigService();
  }
});

},{"../lib/preflight-operation":7}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildAdobeReportSuite = buildAdobeReportSuite;

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _detectCreditCardNumbers = require('../../../utilities/detect-credit-card-numbers');

var _detectCreditCardNumbers2 = _interopRequireDefault(_detectCreditCardNumbers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                     * @module Preflight
                                                                                                                                                                                                     * @class GrandCentralTelemetry
                                                                                                                                                                                                     */

var GCTelemetry = window.GrandCentralTelemetry;
if (!GCTelemetry || !GCTelemetry.TelemetryService) {
  console.error('Grand Central Telemetry Service lib must exist before preflight can execute.');
}

function buildAdobeReportSuite(env, settings) {
  var reportSuites = new Set(settings['gct_plugins_adobe_report-suite'] || []);

  if (env.queryParams.reportSuite) {
    env.queryParams.reportSuite.split(',').forEach(function (suite) {
      return reportSuites.add(suite);
    });
  }

  // Return a distinct array because we're passing this back to GCT.
  return [].concat(_toConsumableArray(reportSuites));
}

exports.default = new _preflightOperation2.default({
  name: 'gcTelemetry',
  deps: ['postLocaleConfig', 'cultureCode', 'fetchAccountIdHash'],
  execute: function execute(settings, cultureCode, accountIdHash) {
    // Instantiate grand-central-telemetry service
    var gctClient = void 0;
    var config = void 0;
    try {
      // Configure service (once only)
      config = {
        env: {
          appName: settings['gct_app-name'],
          charset: settings.gct_charset,

          // These two properties have replaced env.locale
          psnAccountRegion: cultureCode.kamaji.country,
          psnAccountLanguage: cultureCode.kamaji.language,

          // Application build version.
          buildVersion: _environment2.default.ember.buildVersion || '---',

          // For Valkyrie-Transact it suppose to be 'true' when we enter any page.
          // Set to false if not signed in (if signed in is false, visitorId is not needed).
          signedIn: true,

          visitorId: accountIdHash,

          // TODO: It suppose to be the unique device ID that come from the parent application. Not supported for now.
          deviceId: '-UNSUPPORTED-FOR-NOW-',

          // TODO: There is no support for this in Valkyrie-Transact. Use 'WEB' for all devices.
          // Use 'WEB' for desktop browser, or 'MWEB' for mobile browser.
          deviceType: GCTelemetry.DEVICES.WEB,

          // Platform privacy setting
          platformPrivacyWs1: _environment2.default.queryParams.platformPrivacyWs1 || settings['gct_default_platform-privacy']
        },

        // Optional, you can set the log level to debug to see logs to understand what happens behind the scenes.
        logLevel: settings['gct_log-level'],

        plugins: {
          adobe: {
            // We use host app report suite and append our app report suite from app config.
            // NOTE: reportSuite should be Array of strings by the GC-Telemetry spec.
            reportSuite: buildAdobeReportSuite(_environment2.default, settings),
            // Optional, set dryRun to true to skip sending the data to Adobe.
            dryRun: settings['gct_plugins_adobe_dry-run'] || false
          },
          kamaji: {
            env: settings.gct_plugins_kamaji_env,
            // Optional, set dryRun to true to skip sending the data to Kamaji
            dryRun: settings['gct_plugins_kamaji_dry-run'] || false,
            eventUrl: settings['gct_plugins_kamaji_event-url']
          },
          clairvoyance: {
            env: settings.gct_plugins_clairvoyance_env,
            metricsMap: _environment2.default.clairvoyance.metrics,
            // Optional, set dryRun to true to skip sending the data to Clairvoyance
            dryRun: settings['gct_plugins_clairvoyance_dry-run'],
            eventUrl: settings['gct_plugins_clairvoyance_event-url']
          }
        },

        events: {
          PageView: settings['gct_events_page-view'] || [],
          Click: settings.gct_events_click || [],
          UserFacingError: settings['gct_events_user-facing-error'] || [],
          LoadTime: settings['gct_events_load-time'] || [],
          Startup: settings.gct_events_startup || []
        },

        // Allows throttling the volume of data sent to events server by effectively sampling the tracking (0% to 100%).
        // Number between 0 and 1.
        samplingChance: settings.gct_sampling_chance,

        // Allows to throttle the volume of data sent to events server by effectively sampling the tracking
        samplingThresholds: {
          // Numbers between 0 and 1
          adobe: {
            PageView: settings['gct_sampling-thresholds_adobe_page-view'],
            Click: settings['gct_sampling-thresholds_adobe_click'],
            UserFacingError: settings['gct_sampling-thresholds_adobe_user-facing-error']
          },
          kamaji: {
            UserFacingError: settings['gct_sampling-thresholds_kamaji_user-facing-error'],
            Startup: settings['gct_sampling-thresholds_kamaji_startup']
          },
          clairvoyance: {
            LoadTime: settings['gct_sampling-thresholds_clairvoyance_load-time']
          }
        },

        // Enable filtering of events so we can remove any credit card numbers detected in events.
        // Add the query parameter that details the query parameter
        schema: {
          filters: [_detectCreditCardNumbers2.default.detect],
          overrideId: _environment2.default.queryParams.schemaOverride,
          enabled: !!_environment2.default.queryParams.schemaOverride
        }
      };

      gctClient = new GCTelemetry.TelemetryService(config);
    } catch (ex) {
      console.error(ex);
    }

    return {
      // We need GCTelemetry to expose event classes and constants defined in Grand-Central-Telemetry.
      service: GCTelemetry,
      client: gctClient,
      PageViewEvent: GCTelemetry ? GCTelemetry.PageViewEvent : null,
      ClickEvent: GCTelemetry ? GCTelemetry.ClickEvent : null,
      UserFacingErrorEvent: GCTelemetry ? GCTelemetry.UserFacingErrorEvent : null,
      LoadTimeEvent: GCTelemetry ? GCTelemetry.LoadTimeEvent : null,
      StartupEvent: GCTelemetry ? GCTelemetry.StartupEvent : null,

      setPlatformPrivacy: function setPlatformPrivacy(setting) {
        var newConfig = config;
        config.env.platformPrivacyWs1 = setting;
        this.client = new GCTelemetry.TelemetryService(newConfig);
      },


      // Externally provided Grand-Central-Telemetry options.
      options: {
        // SMCID should be provided form the host application.
        smcid: _environment2.default.queryParams.smcid || undefined,
        // EMCID should be provided form the host application.
        emcid: _environment2.default.queryParams.emcid || undefined,
        // ETCID should be provided form the host application.
        etcid: _environment2.default.queryParams.etcid || undefined,
        // ETRID should be provided form the host application.
        etrid: _environment2.default.queryParams.etrid || undefined
      }
    };
  }
});

},{"../../../utilities/detect-credit-card-numbers":26,"../lib/environment":4,"../lib/preflight-operation":7}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _pendingStrings = require('../../../pending-strings');

var _environment = require('../lib/environment');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Spits out to the console any pending strings which override real ones
 * @param {object} realStrings
 * @param {object} pendingStrings
 * @return void
 */
function checkPendingCollisions(realStrings, stringsToCheck) {

  // If for some reason we have no strings (e.g. no bootstrap strings are defined),
  // we'll bail as there are no collisions!
  if (!realStrings || !stringsToCheck) {
    return;
  }

  var collisions = Object.keys(stringsToCheck).filter(function (ps) {
    return ps in realStrings;
  });

  // if you see this, then go to app/pending-strings.js and remove the keys highlighted.
  // don't necessarily remove every single string however, only remove the ones that are in gensen.
  if (collisions.length > 0) {
    console.warn('The following strings need to be removed from app/pending-strings.js: ' + collisions.join(','));
  }
} /**
   * @module Preflight
   * @class I18nOperation
   */

function fetchI18nResource(locale) {
  var showLocalizedKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var showLongStrings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var basename = showLongStrings ? 'fake' : locale.toLowerCase();

  return fetch('/i18n/' + basename + '.json').then(function (result) {
    if (!result.ok && result.status === 404) {
      throw result;
    }
    return result.json();
  }).then(function (strings) {
    // let's tell the developers in case our pending strings have shown up in gensen, so that they can
    // be removed from the pending-strings list.
    checkPendingCollisions(strings, _pendingStrings.pendingStrings);
    checkPendingCollisions(window.valkyrie.transact.bootstrapStrings['en-us'], _pendingStrings.pendingBootstrapStrings);

    // merge pendingStrings into string
    strings = Object.keys(_pendingStrings.pendingStrings).reduce(function (memo, key) {
      memo[key] = strings[key] || _pendingStrings.pendingStrings[key];
      return memo;
    }, strings);

    // modify display if querystring is set to showLocalizedKeys
    if (showLocalizedKeys) {
      strings = Object.keys(strings).reduce(function (memo, key) {
        memo[key] = '[[[' + key + ']]]';
        return memo;
      }, strings);
    }

    return strings;
  });
}

exports.default = new _preflightOperation2.default({
  name: 'i18n',
  deps: ['postLocaleConfig', 'cultureCode'],
  execute: function execute(settings, cultureCode) {
    var fallbackLocale = 'en-GB';
    var gensenLocale = settings.gensen_locale;

    // transact enabled_locales from config are de-DE, but vsf needs to pass in all lowercase de-de
    var lowerCaseLocales = settings.enabled_locales.map(function (locale) {
      return locale.toLowerCase();
    });
    // DAISHO-425 https://jira.sie.sony.com/browse/DAISHO-425

    // Allow a custom locale to be passed in so transact can be loaded with any language string file for localization testing.
    if (_environment2.default.queryParams.customLocale && lowerCaseLocales.indexOf(_environment2.default.queryParams.customLocale.toLowerCase()) >= 0) {
      gensenLocale = _environment2.default.queryParams.customLocale;
    }

    if (!gensenLocale) {
      // If 'null' then gensen locale is the same as locale name.
      if (settings.enabled_locales && settings.enabled_locales.indexOf(cultureCode.locale) >= 0) {
        // Session locale supported in gensen.
        gensenLocale = cultureCode.locale;
      } else {
        console.error('Unsupported gensen locale \'' + gensenLocale + '\'; falling back on \'' + fallbackLocale + '\'');
        gensenLocale = fallbackLocale;
      }
    }

    var showLocalizedKeys = _environment2.default.queryParams.showLocalizedKeys === 'true';
    var showLongStrings = _environment2.default.queryParams.showLongStrings === 'true';
    return fetchI18nResource(gensenLocale.toLowerCase(), showLocalizedKeys, showLongStrings).catch(function (ex) {
      // We attempted to fetch the i18n resource but failed. If it wasn't default locale though,
      // we'll try to fetch that as our fallback.
      if (ex.status === 404 && gensenLocale !== fallbackLocale) {
        console.warn('Unable to load i18n file; falling back on \'' + fallbackLocale.toLowerCase() + '\'');
        return fetchI18nResource(fallbackLocale, showLocalizedKeys);
      } else {
        // Not sure what happened, just reject it
        throw ex;
      }
    });
  }
});

},{"../../../pending-strings":25,"../lib/environment":4,"../lib/preflight-operation":7}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'oauthAccessToken',
  deps: ['gcAuth'],
  execute: function execute(auth) {
    // NOTE: Authorization errors are handled by the Ember application,
    //       when an access token is requested in app/authorization/service.js:fetchAccessToken
    return auth.fetchAccessToken(false).then(function (result) {
      return {
        accessToken: result
      };
    });
  }
});

},{"../lib/preflight-operation":7}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'oauthGatedAccessToken',
  deps: ['gcAuth'],
  execute: function execute(auth) {
    // NOTE: Authorization errors are handled by the Ember application,
    //       when an access token is requested in app/authorization/service.js:fetchAccessToken
    return auth.fetchAccessToken(true).then(function (result) {
      return {
        accessToken: result
      };
    }).catch(function (reason) {
      return {
        accessToken: null,
        reason: reason
      };
    });
  }
});

},{"../lib/preflight-operation":7}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'postLocaleConfig',
  deps: ['gcClientConfig', 'cultureCode', 'preLocaleConfig'],
  execute: function execute(clientConfigService, cultureCode /* , preLocaleConfig*/) {
    // These all have data sets associated with them so we need to make sure they are grouped.
    clientConfigService.addCriteriaVerifier('locale', function (criterion) {
      return clientConfigService.matchesRegExp('(' + criterion + ')', cultureCode.locale);
    });
    clientConfigService.addCriteriaVerifier('language', function (criterion) {
      return clientConfigService.matchesRegExp('(' + criterion + ')', cultureCode.language);
    });
    clientConfigService.addCriteriaVerifier('country', function (criterion) {
      return clientConfigService.matchesRegExp('(' + criterion + ')', cultureCode.country);
    });
    return clientConfigService.computeSettings();
  }
}); /**
     * Available after session has been created and so includes locale-dependent settings.
     * @see pre-locale-config.js
     *
     * @module Preflight
     * @class PostLocaleConfigOperation
     */

},{"../lib/preflight-operation":7}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _loadConfigSettings = require('../lib/load-config-settings');

var _loadConfigSettings2 = _interopRequireDefault(_loadConfigSettings);

var _environment = require('../lib/environment.js');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = new _preflightOperation2.default({
  name: 'preLocaleConfig',
  deps: ['gcClientConfig'],
  execute: function execute(clientConfigService) {
    var configOverrides = null;

    if (_environment2.default.queryParams.config) {
      try {
        configOverrides = JSON.parse(decodeURIComponent(_environment2.default.queryParams.config));
      } catch (ex) {
        console.warn('Config override is not in valid JSON format: ', ex);
      }
    }

    return (0, _loadConfigSettings2.default)(clientConfigService, '/config/', _environment2.default.queryParams.oauth_client_id, configOverrides).then(function () {
      return clientConfigService.computeSettings();
    });
  }
}); /**
     * Available before session has been created but as such does include locale-dependent settings.
     *
     * @see post-locale-config.js
     *
     * @module Preflight
     * @class PreLocaleConfigOperation
     */

},{"../lib/environment.js":4,"../lib/load-config-settings":6,"../lib/preflight-operation":7}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _preflightOperation = require('../lib/preflight-operation');

var _preflightOperation2 = _interopRequireDefault(_preflightOperation);

var _environment = require('../lib/environment.js');

var _environment2 = _interopRequireDefault(_environment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Available before session has been created but as such does include locale-dependent settings.
 *
 * @see post-locale-config.js
 *
 * @module Preflight
 * @class PreLocaleConfigOperation
 */

var layoutMap = {
  flex: 'transact__layout--flex',
  block: 'transact__layout--block'
};

exports.default = new _preflightOperation2.default({
  name: 'setLayout',
  execute: function execute() {
    var layoutClass = layoutMap[_environment2.default.queryParams.layout || 'flex'];

    document.body.classList.add(layoutClass);
  }
});

},{"../lib/environment.js":4,"../lib/preflight-operation":7}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/* eslint-disable max-len */

// this is the pending strings page.
// 1) if you need a string to exist, put it in the pendingStrings object.
// --the pendingStrings object will be merged into the official gensen translations.
// --you can then use the string as if it were in the official translations.
// 2) the pendingStrings list will serve as a list of strings we need to get put into gensen
// --presumably someone will come along, grab this list, forward it to the gensen king or queen, and get it submitted.
// 3) once a string shows up in gensen, some Ember.Logger.logs will go off when we load the pending strings, and it'll
//    be up to a developer to remove the now-translated strings from the pendingString list.

var pendingStrings = exports.pendingStrings = {
  // BEGIN BRANDY-928: https://jira.sie.sony.com/browse/BRANDY-928
  'vt.page.subscriptions.title': 'Subscriptions Management',
  // END BRANDY-928

  // BEGIN BRANDY-1009: https://jira.sie.sony.com/browse/BRANDY-1009
  'vt.page.secure.verification.not.available': 'We are unable to verify this method of payment. Please contact issuer or select a different payment method.',
  // END BRANDY-1009

  // BEGIN BRANDY-1010: https://jira.sie.sony.com/browse/BRANDY-1010
  'vt.page.boku.reverify': 'Verify Mobile Phone',
  'vt.request.code': 'Request Code',
  // END BRANDY-1009

  // BEGIN BRANDY-928: https://jira.sie.sony.com/browse/BRANDY-928
  'vt.remove.mobile.phone': 'Remove Mobile Phone',
  // END BRANDY-928

  'vt.boku.di.error': '',
  'vt.boku.di.already.exists': '',
  'vt.boku.di.declined': '',
  'vt.boku.di.has.expired': '',
  'vt.boku.di.time.out': '',
  'vt.boku.di.deposit.in.progress': '',
  'vt.boku.di.charge.failed': '',
  'vt.boku.di.account.not.found': '',
  'vt.boku.di.account.inactive': ''
};

var pendingBootstrapStrings = exports.pendingBootstrapStrings = {
  // BEGIN S56837: https://rally1.rallydev.com/#/18992946489d/detail/userstory/47082716546
  'vt.page.error.404.title': 'Unable to Find This Page',
  'vt.page.error.404.message': 'It may be unavailable or the address may be incorrect.',
  'vt.page.error.500.title': 'Error',
  'vt.page.error.500.message': 'There was a problem displaying the page you requested.'
  // END S56837
};

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @function detectCreditCardNumbers
 *
 * @module Utilities
 */

/* eslint no-use-before-define: ["error", { "functions": false }] */

// The function references are properties within the detectCreditCardNumbersUtility so that a unit test can test that
// the detect function calls the _detect internal function.  This way, the _detect internal function can also be unit
// tested to work for all possible actions, and not just the one that we are currently using.
var detectCreditCardNumbersUtility = {
  _luhnCheck: _isValidCCNumUsingLuhn,
  _detect: _detectCreditCardNumbers,
  detect: detectCreditCardNumbers
};

exports.default = detectCreditCardNumbersUtility;


function _isValidCCNumUsingLuhn(potentialCCNum) {
  var nCheck = 0;
  var nDigit = void 0;
  var bEven = false;
  for (var n = potentialCCNum.length - 1; n >= 0; n--) {
    var cDigit = potentialCCNum.charAt(n);
    nDigit = parseInt(cDigit, 10);
    if (bEven) {
      nDigit *= 2;
      if (nDigit > 9) {
        nDigit -= 9;
      }
    }
    nCheck += nDigit;
    bEven = !bEven;
  }
  return nCheck % 10 === 0;
}

/**
 * _detectCreditCardNumbers - Find and optionally scrub credit card numbers within given text.
 *
 * @param {string} value - the text in which to search for credit card numbers
 * @param {string} action - the action to be taken if a credit card number is found (block, filter, or allow)
 * @returns {string} - value, if no CC num found;
 *                     scrubbed value, if CC nums found;
 *                     undefined if unexpected property or if entire event value should be ignored.
 */
function _detectCreditCardNumbers(value, action) {
  var filterAction = action || 'block';

  if (filterAction === 'allow') {
    return value;
  }

  var findRegExp = /[0-9]+[0-9-\s]{10}/g; // Match a digit plus 9 further characters of digits, dashes, or spaces
  var extractRegExp = /^[0-9-\s]{10,29}/; // Match first 10 to 29 characters of digits, dashes or spaces

  var scrubbedValue = value;

  // Find first occurrence of digit followed by 9 digits, dashes or spaces
  var match = findRegExp.exec(value);
  var extractedMatch = null;
  var extractedString = void 0;
  var tempValue = void 0;
  var potentialCCNum = void 0;
  var scrubbedString = '';
  var scrubbed = false;

  while (match != null) {
    // Get the string starting at the found position
    tempValue = scrubbedValue.substr(match.index);
    // Extract the string having up to 29 characters of digits, dashes or spaces
    // This accounts for 19 digits and up to 10 dashes or spaces
    extractedMatch = extractRegExp.exec(tempValue);
    if (extractedMatch) {
      extractedString = extractedMatch[0];
      // Remove all the non-digits (dashes and spaces) to just arrive at only a string of digits
      potentialCCNum = extractedString.replace(/\D/g, '');
      while (potentialCCNum.length >= 10) {
        if (potentialCCNum.length <= 19) {
          // Run Luhn algorithm to check if this number could be a valid credit number
          if (_isValidCCNumUsingLuhn(potentialCCNum)) {
            if (filterAction === 'block') {
              return undefined;
            }

            // Replace the extracted string with 'X' characters
            scrubbedString = new Array(extractedString.length + 1).join('X');
            scrubbedValue = scrubbedValue.replace(extractedString, scrubbedString);
            scrubbed = true;
            break;
          }
        }
        // Retry with one less character in the extracted string, since all substrings need to be checked that are
        // 10 characters long up to the extracted string length
        extractedString = extractedString.substr(0, extractedString.length - 1);
        // Remove all the non-digits (dashes and spaces) to just arrive at only a string of digits
        potentialCCNum = extractedString.replace(/\D/g, '');
      }
    }

    // Check if scrubbing occurred in this iteration
    if (scrubbedString.length > 0) {
      // Backtrack the outer search by the extracted string length less the number of characters in the scrubbed string
      findRegExp.lastIndex -= match[0].length - scrubbedString.length;
      scrubbedString = '';
    } else {
      // Backtrack the outer search by last found match string length less one (effectively moving to the next character)
      findRegExp.lastIndex -= match[0].length - 1;
    }
    match = findRegExp.exec(scrubbedValue);
  }

  if (scrubbed) {
    return scrubbedValue;
  }

  // No scrubbing was needed, so just return the input value
  return value;
}

/**
 * detectCreditCardNumbers - Find and optionally scrub credit card numbers within given text.
 *
 * @param {string} value - the text in which to search for credit card numbers
 * @returns {string} - value, if no CC num found;
 *                     scrubbed value, if CC nums found;
 *                     undefined if unexpected property or if entire event value should be ignored.
 */
function detectCreditCardNumbers(value) {
  if (typeof value !== 'string') {
    return value;
  }

  var action = 'block'; // or 'allow' or 'filter'
  return detectCreditCardNumbersUtility._detect(value, action);
}

},{}]},{},[10]);

</script>

    <link rel="stylesheet" href="assets/vendor-d41d8cd98f00b204e9800998ecf8427e.css" integrity="">
    <link rel="stylesheet" href="assets/psst-73306ca5ad2f30cdfebcd14d12db5013.css" integrity="">

    

    <div id="psst"></div>

    <script src="assets/vendor-9b63638465479f9d366b0648da8bbfbb.js" integrity="sha256-JgvSOUxJGjELd7Q1IMdYpwF0fvBzjei5OasiQrlXw9g= sha512-Y/RhyJtUQ8E4j3AA+xfFjmBRhLLyW3fanyVNs2wnsV8LP6f1hgQ9fEwpqWxknnh69xiH4qcdM27ENFMWVzY9Jw==" ></script>
    <script src="assets/psst-4c048fabb32df3996c3a2c5b8a8125f9.js" integrity="sha256-U8e88dAt6N7eYNrJDPvfVXckBwiI4NchxgmzC6JeV/k= sha512-EYtIingneYqmUv4iuteWgRPud8oKjIBgwIInJ+HD19JzDSjLpup6XGMjJsnSfmyAP/ZNoVmHj3oFRl68diXSRQ==" ></script>

    

    

    <!-- Load NuData widget for 3DS2 -->
    <script>
      window.ndsapi = {
        config: {
          q: [],
          ready(cb) {
            this.q = [cb];
          },
        },
      };
    </script>
    <script id="nudata-widget" src="https://api-sony.nd-mtf.nudatasecurity.com/2.2/w/w-934908/sync/js/"></script>

    <!-- Workaround <BRANDY-601> -->
    <script>
      WidgetBrowserData.prototype.setBrowserLanguage = function(a) {
          this.browserLanguage = a;
          this.browserAcceptHeader = "*/*";
      };
      WidgetBrowserData.prototype.setBrowserAcceptHeader = function() {
        this.browserAcceptHeader = "*/*";
      };
      WidgetBrowserData.prototype.getBrowserAcceptHeader = function() {
        return "*/*";
      };
      WidgetBrowserData.FieldMetadata.browserAcceptHeader = (new FieldMetadata).setValueRetriever(function(a) {
          return a instanceof WidgetBrowserData ? a.getBrowserLanguage() : null
      }).setValueSetter(function(a, b) {
        var c = FieldMetadata.SetterResult.NOT_APPLICABLE;
        a instanceof WidgetBrowserData && (c = FieldMetadata.SetterResult.FAILURE,
        MetadataUtils.isInstanceOf(b, String, "String") && (a.setBrowserAcceptHeader(b),
        c = FieldMetadata.SetterResult.SUCCESS));
        return c
      }).setValueInitializer(function(a) {
          return MetadataUtils.isInstanceOf(a, String, "String") ? a : null
      }).enableSerialization().setSerializationTarget("browserAcceptHeader").setFieldType(Init.Type.String).addValidator((new FieldMetadata.ValidatorMetadata.Builder).setDelegate(FieldMetadata.ValidationDelegate.STRING).addContext(FieldMetadata.ValidatorContext.T).addProperty(Property.MAX_LENGTH, 8).addProperty(Property.MIN_LENGTH, 1).build()).addValidator((new FieldMetadata.ValidatorMetadata.Builder).setDelegate(FieldMetadata.ValidationDelegate.OBJECT).addContext(FieldMetadata.ValidatorContext.THIS).build());
    </script>
    <!-- Workaround </BRANDY-601> -->
  </body>
</html>
<!-- Built from 6361dccacdece2ad97b1915578c104c3e805aefc -->
<!-- Describe: V34.2.0-0-g6361dcca -->
